// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: apache/rocketmq/v2/definition.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_apache_2frocketmq_2fv2_2fdefinition_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_apache_2frocketmq_2fv2_2fdefinition_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_apache_2frocketmq_2fv2_2fdefinition_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_apache_2frocketmq_2fv2_2fdefinition_2eproto;
namespace apache {
namespace rocketmq {
namespace v2 {
class Address;
struct AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
class Assignment;
struct AssignmentDefaultTypeInternal;
extern AssignmentDefaultTypeInternal _Assignment_default_instance_;
class Broker;
struct BrokerDefaultTypeInternal;
extern BrokerDefaultTypeInternal _Broker_default_instance_;
class CustomizedBackoff;
struct CustomizedBackoffDefaultTypeInternal;
extern CustomizedBackoffDefaultTypeInternal _CustomizedBackoff_default_instance_;
class Digest;
struct DigestDefaultTypeInternal;
extern DigestDefaultTypeInternal _Digest_default_instance_;
class Endpoints;
struct EndpointsDefaultTypeInternal;
extern EndpointsDefaultTypeInternal _Endpoints_default_instance_;
class ExponentialBackoff;
struct ExponentialBackoffDefaultTypeInternal;
extern ExponentialBackoffDefaultTypeInternal _ExponentialBackoff_default_instance_;
class FilterExpression;
struct FilterExpressionDefaultTypeInternal;
extern FilterExpressionDefaultTypeInternal _FilterExpression_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class MessageQueue;
struct MessageQueueDefaultTypeInternal;
extern MessageQueueDefaultTypeInternal _MessageQueue_default_instance_;
class Message_UserPropertiesEntry_DoNotUse;
struct Message_UserPropertiesEntry_DoNotUseDefaultTypeInternal;
extern Message_UserPropertiesEntry_DoNotUseDefaultTypeInternal _Message_UserPropertiesEntry_DoNotUse_default_instance_;
class Resource;
struct ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
class RetryPolicy;
struct RetryPolicyDefaultTypeInternal;
extern RetryPolicyDefaultTypeInternal _RetryPolicy_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class SubscriptionEntry;
struct SubscriptionEntryDefaultTypeInternal;
extern SubscriptionEntryDefaultTypeInternal _SubscriptionEntry_default_instance_;
class SystemProperties;
struct SystemPropertiesDefaultTypeInternal;
extern SystemPropertiesDefaultTypeInternal _SystemProperties_default_instance_;
class UA;
struct UADefaultTypeInternal;
extern UADefaultTypeInternal _UA_default_instance_;
}  // namespace v2
}  // namespace rocketmq
}  // namespace apache
PROTOBUF_NAMESPACE_OPEN
template<> ::apache::rocketmq::v2::Address* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Address>(Arena*);
template<> ::apache::rocketmq::v2::Assignment* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Assignment>(Arena*);
template<> ::apache::rocketmq::v2::Broker* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Broker>(Arena*);
template<> ::apache::rocketmq::v2::CustomizedBackoff* Arena::CreateMaybeMessage<::apache::rocketmq::v2::CustomizedBackoff>(Arena*);
template<> ::apache::rocketmq::v2::Digest* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Digest>(Arena*);
template<> ::apache::rocketmq::v2::Endpoints* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Endpoints>(Arena*);
template<> ::apache::rocketmq::v2::ExponentialBackoff* Arena::CreateMaybeMessage<::apache::rocketmq::v2::ExponentialBackoff>(Arena*);
template<> ::apache::rocketmq::v2::FilterExpression* Arena::CreateMaybeMessage<::apache::rocketmq::v2::FilterExpression>(Arena*);
template<> ::apache::rocketmq::v2::Message* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Message>(Arena*);
template<> ::apache::rocketmq::v2::MessageQueue* Arena::CreateMaybeMessage<::apache::rocketmq::v2::MessageQueue>(Arena*);
template<> ::apache::rocketmq::v2::Message_UserPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Message_UserPropertiesEntry_DoNotUse>(Arena*);
template<> ::apache::rocketmq::v2::Resource* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Resource>(Arena*);
template<> ::apache::rocketmq::v2::RetryPolicy* Arena::CreateMaybeMessage<::apache::rocketmq::v2::RetryPolicy>(Arena*);
template<> ::apache::rocketmq::v2::Status* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Status>(Arena*);
template<> ::apache::rocketmq::v2::SubscriptionEntry* Arena::CreateMaybeMessage<::apache::rocketmq::v2::SubscriptionEntry>(Arena*);
template<> ::apache::rocketmq::v2::SystemProperties* Arena::CreateMaybeMessage<::apache::rocketmq::v2::SystemProperties>(Arena*);
template<> ::apache::rocketmq::v2::UA* Arena::CreateMaybeMessage<::apache::rocketmq::v2::UA>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apache {
namespace rocketmq {
namespace v2 {

enum TransactionResolution : int {
  TRANSACTION_RESOLUTION_UNSPECIFIED = 0,
  COMMIT = 1,
  ROLLBACK = 2,
  TransactionResolution_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransactionResolution_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransactionResolution_IsValid(int value);
constexpr TransactionResolution TransactionResolution_MIN = TRANSACTION_RESOLUTION_UNSPECIFIED;
constexpr TransactionResolution TransactionResolution_MAX = ROLLBACK;
constexpr int TransactionResolution_ARRAYSIZE = TransactionResolution_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionResolution_descriptor();
template<typename T>
inline const std::string& TransactionResolution_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionResolution>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionResolution_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionResolution_descriptor(), enum_t_value);
}
inline bool TransactionResolution_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionResolution* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionResolution>(
    TransactionResolution_descriptor(), name, value);
}
enum TransactionSource : int {
  SOURCE_UNSPECIFIED = 0,
  SOURCE_CLIENT = 1,
  SOURCE_SERVER_CHECK = 2,
  TransactionSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransactionSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransactionSource_IsValid(int value);
constexpr TransactionSource TransactionSource_MIN = SOURCE_UNSPECIFIED;
constexpr TransactionSource TransactionSource_MAX = SOURCE_SERVER_CHECK;
constexpr int TransactionSource_ARRAYSIZE = TransactionSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionSource_descriptor();
template<typename T>
inline const std::string& TransactionSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionSource_descriptor(), enum_t_value);
}
inline bool TransactionSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionSource>(
    TransactionSource_descriptor(), name, value);
}
enum Permission : int {
  PERMISSION_UNSPECIFIED = 0,
  NONE = 1,
  READ = 2,
  WRITE = 3,
  READ_WRITE = 4,
  Permission_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Permission_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Permission_IsValid(int value);
constexpr Permission Permission_MIN = PERMISSION_UNSPECIFIED;
constexpr Permission Permission_MAX = READ_WRITE;
constexpr int Permission_ARRAYSIZE = Permission_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Permission_descriptor();
template<typename T>
inline const std::string& Permission_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Permission>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Permission_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Permission_descriptor(), enum_t_value);
}
inline bool Permission_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Permission* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Permission>(
    Permission_descriptor(), name, value);
}
enum FilterType : int {
  FILTER_TYPE_UNSPECIFIED = 0,
  TAG = 1,
  SQL = 2,
  FilterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FilterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FilterType_IsValid(int value);
constexpr FilterType FilterType_MIN = FILTER_TYPE_UNSPECIFIED;
constexpr FilterType FilterType_MAX = SQL;
constexpr int FilterType_ARRAYSIZE = FilterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FilterType_descriptor();
template<typename T>
inline const std::string& FilterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FilterType_descriptor(), enum_t_value);
}
inline bool FilterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FilterType>(
    FilterType_descriptor(), name, value);
}
enum AddressScheme : int {
  ADDRESS_SCHEME_UNSPECIFIED = 0,
  IPv4 = 1,
  IPv6 = 2,
  DOMAIN_NAME = 3,
  AddressScheme_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AddressScheme_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AddressScheme_IsValid(int value);
constexpr AddressScheme AddressScheme_MIN = ADDRESS_SCHEME_UNSPECIFIED;
constexpr AddressScheme AddressScheme_MAX = DOMAIN_NAME;
constexpr int AddressScheme_ARRAYSIZE = AddressScheme_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddressScheme_descriptor();
template<typename T>
inline const std::string& AddressScheme_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddressScheme>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddressScheme_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AddressScheme_descriptor(), enum_t_value);
}
inline bool AddressScheme_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AddressScheme* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AddressScheme>(
    AddressScheme_descriptor(), name, value);
}
enum MessageType : int {
  MESSAGE_TYPE_UNSPECIFIED = 0,
  NORMAL = 1,
  FIFO = 2,
  DELAY = 3,
  TRANSACTION = 4,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = MESSAGE_TYPE_UNSPECIFIED;
constexpr MessageType MessageType_MAX = TRANSACTION;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum DigestType : int {
  DIGEST_TYPE_UNSPECIFIED = 0,
  CRC32 = 1,
  MD5 = 2,
  SHA1 = 3,
  DigestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DigestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DigestType_IsValid(int value);
constexpr DigestType DigestType_MIN = DIGEST_TYPE_UNSPECIFIED;
constexpr DigestType DigestType_MAX = SHA1;
constexpr int DigestType_ARRAYSIZE = DigestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DigestType_descriptor();
template<typename T>
inline const std::string& DigestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DigestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DigestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DigestType_descriptor(), enum_t_value);
}
inline bool DigestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DigestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DigestType>(
    DigestType_descriptor(), name, value);
}
enum ClientType : int {
  CLIENT_TYPE_UNSPECIFIED = 0,
  PRODUCER = 1,
  PUSH_CONSUMER = 2,
  SIMPLE_CONSUMER = 3,
  ClientType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClientType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClientType_IsValid(int value);
constexpr ClientType ClientType_MIN = CLIENT_TYPE_UNSPECIFIED;
constexpr ClientType ClientType_MAX = SIMPLE_CONSUMER;
constexpr int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientType_descriptor();
template<typename T>
inline const std::string& ClientType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientType_descriptor(), enum_t_value);
}
inline bool ClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientType>(
    ClientType_descriptor(), name, value);
}
enum Encoding : int {
  ENCODING_UNSPECIFIED = 0,
  IDENTITY = 1,
  GZIP = 2,
  Encoding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Encoding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Encoding_IsValid(int value);
constexpr Encoding Encoding_MIN = ENCODING_UNSPECIFIED;
constexpr Encoding Encoding_MAX = GZIP;
constexpr int Encoding_ARRAYSIZE = Encoding_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Encoding_descriptor();
template<typename T>
inline const std::string& Encoding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Encoding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Encoding_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Encoding_descriptor(), enum_t_value);
}
inline bool Encoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Encoding* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Encoding>(
    Encoding_descriptor(), name, value);
}
enum Code : int {
  CODE_UNSPECIFIED = 0,
  OK = 20000,
  MULTIPLE_RESULTS = 30000,
  BAD_REQUEST = 40000,
  ILLEGAL_ACCESS_POINT = 40001,
  ILLEGAL_TOPIC = 40002,
  ILLEGAL_CONSUMER_GROUP = 40003,
  ILLEGAL_MESSAGE_TAG = 40004,
  ILLEGAL_MESSAGE_KEY = 40005,
  ILLEGAL_MESSAGE_GROUP = 40006,
  ILLEGAL_MESSAGE_PROPERTY_KEY = 40007,
  INVALID_TRANSACTION_ID = 40008,
  ILLEGAL_MESSAGE_ID = 40009,
  ILLEGAL_FILTER_EXPRESSION = 40010,
  ILLEGAL_INVISIBLE_TIME = 40011,
  ILLEGAL_DELIVERY_TIME = 40012,
  INVALID_RECEIPT_HANDLE = 40013,
  MESSAGE_PROPERTY_CONFLICT_WITH_TYPE = 40014,
  UNRECOGNIZED_CLIENT_TYPE = 40015,
  MESSAGE_CORRUPTED = 40016,
  CLIENT_ID_REQUIRED = 40017,
  UNAUTHORIZED = 40100,
  PAYMENT_REQUIRED = 40200,
  FORBIDDEN = 40300,
  NOT_FOUND = 40400,
  MESSAGE_NOT_FOUND = 40401,
  TOPIC_NOT_FOUND = 40402,
  CONSUMER_GROUP_NOT_FOUND = 40403,
  REQUEST_TIMEOUT = 40800,
  PAYLOAD_TOO_LARGE = 41300,
  MESSAGE_BODY_TOO_LARGE = 41301,
  PRECONDITION_FAILED = 42800,
  TOO_MANY_REQUESTS = 42900,
  REQUEST_HEADER_FIELDS_TOO_LARGE = 43100,
  MESSAGE_PROPERTIES_TOO_LARGE = 43101,
  INTERNAL_ERROR = 50000,
  INTERNAL_SERVER_ERROR = 50001,
  HA_NOT_AVAILABLE = 50002,
  NOT_IMPLEMENTED = 50100,
  PROXY_TIMEOUT = 50400,
  MASTER_PERSISTENCE_TIMEOUT = 50401,
  SLAVE_PERSISTENCE_TIMEOUT = 50402,
  UNSUPPORTED = 50500,
  VERSION_UNSUPPORTED = 50501,
  VERIFY_FIFO_MESSAGE_UNSUPPORTED = 50502,
  FAILED_TO_CONSUME_MESSAGE = 60000,
  Code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Code_IsValid(int value);
constexpr Code Code_MIN = CODE_UNSPECIFIED;
constexpr Code Code_MAX = FAILED_TO_CONSUME_MESSAGE;
constexpr int Code_ARRAYSIZE = Code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Code_descriptor();
template<typename T>
inline const std::string& Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Code_descriptor(), enum_t_value);
}
inline bool Code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Code>(
    Code_descriptor(), name, value);
}
enum Language : int {
  LANGUAGE_UNSPECIFIED = 0,
  JAVA = 1,
  CPP = 2,
  DOT_NET = 3,
  GOLANG = 4,
  RUST = 5,
  Language_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Language_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Language_IsValid(int value);
constexpr Language Language_MIN = LANGUAGE_UNSPECIFIED;
constexpr Language Language_MAX = RUST;
constexpr int Language_ARRAYSIZE = Language_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Language_descriptor();
template<typename T>
inline const std::string& Language_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Language>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Language_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Language_descriptor(), enum_t_value);
}
inline bool Language_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Language* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Language>(
    Language_descriptor(), name, value);
}
// ===================================================================

class FilterExpression final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.FilterExpression) */ {
 public:
  inline FilterExpression() : FilterExpression(nullptr) {}
  ~FilterExpression() override;
  explicit PROTOBUF_CONSTEXPR FilterExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilterExpression(const FilterExpression& from);
  FilterExpression(FilterExpression&& from) noexcept
    : FilterExpression() {
    *this = ::std::move(from);
  }

  inline FilterExpression& operator=(const FilterExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterExpression& operator=(FilterExpression&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilterExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilterExpression* internal_default_instance() {
    return reinterpret_cast<const FilterExpression*>(
               &_FilterExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FilterExpression& a, FilterExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(FilterExpression* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilterExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilterExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilterExpression>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FilterExpression& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FilterExpression& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterExpression* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.FilterExpression";
  }
  protected:
  explicit FilterExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpressionFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string expression = 2 [json_name = "expression"];
  void clear_expression();
  const std::string& expression() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expression(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expression();
  PROTOBUF_NODISCARD std::string* release_expression();
  void set_allocated_expression(std::string* expression);
  private:
  const std::string& _internal_expression() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expression(const std::string& value);
  std::string* _internal_mutable_expression();
  public:

  // .apache.rocketmq.v2.FilterType type = 1 [json_name = "type"];
  void clear_type();
  ::apache::rocketmq::v2::FilterType type() const;
  void set_type(::apache::rocketmq::v2::FilterType value);
  private:
  ::apache::rocketmq::v2::FilterType _internal_type() const;
  void _internal_set_type(::apache::rocketmq::v2::FilterType value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.FilterExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expression_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class RetryPolicy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.RetryPolicy) */ {
 public:
  inline RetryPolicy() : RetryPolicy(nullptr) {}
  ~RetryPolicy() override;
  explicit PROTOBUF_CONSTEXPR RetryPolicy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RetryPolicy(const RetryPolicy& from);
  RetryPolicy(RetryPolicy&& from) noexcept
    : RetryPolicy() {
    *this = ::std::move(from);
  }

  inline RetryPolicy& operator=(const RetryPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetryPolicy& operator=(RetryPolicy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RetryPolicy& default_instance() {
    return *internal_default_instance();
  }
  enum StrategyCase {
    kExponentialBackoff = 2,
    kCustomizedBackoff = 3,
    STRATEGY_NOT_SET = 0,
  };

  static inline const RetryPolicy* internal_default_instance() {
    return reinterpret_cast<const RetryPolicy*>(
               &_RetryPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RetryPolicy& a, RetryPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(RetryPolicy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RetryPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RetryPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RetryPolicy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RetryPolicy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RetryPolicy& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetryPolicy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.RetryPolicy";
  }
  protected:
  explicit RetryPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxAttemptsFieldNumber = 1,
    kExponentialBackoffFieldNumber = 2,
    kCustomizedBackoffFieldNumber = 3,
  };
  // int32 max_attempts = 1 [json_name = "maxAttempts"];
  void clear_max_attempts();
  int32_t max_attempts() const;
  void set_max_attempts(int32_t value);
  private:
  int32_t _internal_max_attempts() const;
  void _internal_set_max_attempts(int32_t value);
  public:

  // .apache.rocketmq.v2.ExponentialBackoff exponential_backoff = 2 [json_name = "exponentialBackoff"];
  bool has_exponential_backoff() const;
  private:
  bool _internal_has_exponential_backoff() const;
  public:
  void clear_exponential_backoff();
  const ::apache::rocketmq::v2::ExponentialBackoff& exponential_backoff() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::ExponentialBackoff* release_exponential_backoff();
  ::apache::rocketmq::v2::ExponentialBackoff* mutable_exponential_backoff();
  void set_allocated_exponential_backoff(::apache::rocketmq::v2::ExponentialBackoff* exponential_backoff);
  private:
  const ::apache::rocketmq::v2::ExponentialBackoff& _internal_exponential_backoff() const;
  ::apache::rocketmq::v2::ExponentialBackoff* _internal_mutable_exponential_backoff();
  public:
  void unsafe_arena_set_allocated_exponential_backoff(
      ::apache::rocketmq::v2::ExponentialBackoff* exponential_backoff);
  ::apache::rocketmq::v2::ExponentialBackoff* unsafe_arena_release_exponential_backoff();

  // .apache.rocketmq.v2.CustomizedBackoff customized_backoff = 3 [json_name = "customizedBackoff"];
  bool has_customized_backoff() const;
  private:
  bool _internal_has_customized_backoff() const;
  public:
  void clear_customized_backoff();
  const ::apache::rocketmq::v2::CustomizedBackoff& customized_backoff() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::CustomizedBackoff* release_customized_backoff();
  ::apache::rocketmq::v2::CustomizedBackoff* mutable_customized_backoff();
  void set_allocated_customized_backoff(::apache::rocketmq::v2::CustomizedBackoff* customized_backoff);
  private:
  const ::apache::rocketmq::v2::CustomizedBackoff& _internal_customized_backoff() const;
  ::apache::rocketmq::v2::CustomizedBackoff* _internal_mutable_customized_backoff();
  public:
  void unsafe_arena_set_allocated_customized_backoff(
      ::apache::rocketmq::v2::CustomizedBackoff* customized_backoff);
  ::apache::rocketmq::v2::CustomizedBackoff* unsafe_arena_release_customized_backoff();

  void clear_strategy();
  StrategyCase strategy_case() const;
  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.RetryPolicy)
 private:
  class _Internal;
  void set_has_exponential_backoff();
  void set_has_customized_backoff();

  inline bool has_strategy() const;
  inline void clear_has_strategy();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t max_attempts_;
  union StrategyUnion {
    constexpr StrategyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::apache::rocketmq::v2::ExponentialBackoff* exponential_backoff_;
    ::apache::rocketmq::v2::CustomizedBackoff* customized_backoff_;
  } strategy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class ExponentialBackoff final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.ExponentialBackoff) */ {
 public:
  inline ExponentialBackoff() : ExponentialBackoff(nullptr) {}
  ~ExponentialBackoff() override;
  explicit PROTOBUF_CONSTEXPR ExponentialBackoff(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExponentialBackoff(const ExponentialBackoff& from);
  ExponentialBackoff(ExponentialBackoff&& from) noexcept
    : ExponentialBackoff() {
    *this = ::std::move(from);
  }

  inline ExponentialBackoff& operator=(const ExponentialBackoff& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExponentialBackoff& operator=(ExponentialBackoff&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExponentialBackoff& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExponentialBackoff* internal_default_instance() {
    return reinterpret_cast<const ExponentialBackoff*>(
               &_ExponentialBackoff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ExponentialBackoff& a, ExponentialBackoff& b) {
    a.Swap(&b);
  }
  inline void Swap(ExponentialBackoff* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExponentialBackoff* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExponentialBackoff* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExponentialBackoff>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExponentialBackoff& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExponentialBackoff& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExponentialBackoff* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.ExponentialBackoff";
  }
  protected:
  explicit ExponentialBackoff(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitialFieldNumber = 1,
    kMaxFieldNumber = 2,
    kMultiplierFieldNumber = 3,
  };
  // .google.protobuf.Duration initial = 1 [json_name = "initial"];
  bool has_initial() const;
  private:
  bool _internal_has_initial() const;
  public:
  void clear_initial();
  const ::PROTOBUF_NAMESPACE_ID::Duration& initial() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_initial();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_initial();
  void set_allocated_initial(::PROTOBUF_NAMESPACE_ID::Duration* initial);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_initial() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_initial();
  public:
  void unsafe_arena_set_allocated_initial(
      ::PROTOBUF_NAMESPACE_ID::Duration* initial);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_initial();

  // .google.protobuf.Duration max = 2 [json_name = "max"];
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  const ::PROTOBUF_NAMESPACE_ID::Duration& max() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_max();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_max();
  void set_allocated_max(::PROTOBUF_NAMESPACE_ID::Duration* max);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_max() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_max();
  public:
  void unsafe_arena_set_allocated_max(
      ::PROTOBUF_NAMESPACE_ID::Duration* max);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_max();

  // float multiplier = 3 [json_name = "multiplier"];
  void clear_multiplier();
  float multiplier() const;
  void set_multiplier(float value);
  private:
  float _internal_multiplier() const;
  void _internal_set_multiplier(float value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.ExponentialBackoff)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Duration* initial_;
  ::PROTOBUF_NAMESPACE_ID::Duration* max_;
  float multiplier_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class CustomizedBackoff final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.CustomizedBackoff) */ {
 public:
  inline CustomizedBackoff() : CustomizedBackoff(nullptr) {}
  ~CustomizedBackoff() override;
  explicit PROTOBUF_CONSTEXPR CustomizedBackoff(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomizedBackoff(const CustomizedBackoff& from);
  CustomizedBackoff(CustomizedBackoff&& from) noexcept
    : CustomizedBackoff() {
    *this = ::std::move(from);
  }

  inline CustomizedBackoff& operator=(const CustomizedBackoff& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomizedBackoff& operator=(CustomizedBackoff&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomizedBackoff& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomizedBackoff* internal_default_instance() {
    return reinterpret_cast<const CustomizedBackoff*>(
               &_CustomizedBackoff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CustomizedBackoff& a, CustomizedBackoff& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomizedBackoff* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomizedBackoff* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomizedBackoff* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomizedBackoff>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomizedBackoff& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CustomizedBackoff& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomizedBackoff* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.CustomizedBackoff";
  }
  protected:
  explicit CustomizedBackoff(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextFieldNumber = 1,
  };
  // repeated .google.protobuf.Duration next = 1 [json_name = "next"];
  int next_size() const;
  private:
  int _internal_next_size() const;
  public:
  void clear_next();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_next(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Duration >*
      mutable_next();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_next(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_add_next();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Duration& next(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Duration* add_next();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Duration >&
      next() const;

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.CustomizedBackoff)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Duration > next_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class Resource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.Resource) */ {
 public:
  inline Resource() : Resource(nullptr) {}
  ~Resource() override;
  explicit PROTOBUF_CONSTEXPR Resource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Resource(const Resource& from);
  Resource(Resource&& from) noexcept
    : Resource() {
    *this = ::std::move(from);
  }

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  inline Resource& operator=(Resource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Resource& default_instance() {
    return *internal_default_instance();
  }
  static inline const Resource* internal_default_instance() {
    return reinterpret_cast<const Resource*>(
               &_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Resource& a, Resource& b) {
    a.Swap(&b);
  }
  inline void Swap(Resource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Resource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Resource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Resource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Resource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Resource& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.Resource";
  }
  protected:
  explicit Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceNamespaceFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string resource_namespace = 1 [json_name = "resourceNamespace"];
  void clear_resource_namespace();
  const std::string& resource_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_namespace();
  PROTOBUF_NODISCARD std::string* release_resource_namespace();
  void set_allocated_resource_namespace(std::string* resource_namespace);
  private:
  const std::string& _internal_resource_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_namespace(const std::string& value);
  std::string* _internal_mutable_resource_namespace();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.Resource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.SubscriptionEntry) */ {
 public:
  inline SubscriptionEntry() : SubscriptionEntry(nullptr) {}
  ~SubscriptionEntry() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionEntry(const SubscriptionEntry& from);
  SubscriptionEntry(SubscriptionEntry&& from) noexcept
    : SubscriptionEntry() {
    *this = ::std::move(from);
  }

  inline SubscriptionEntry& operator=(const SubscriptionEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionEntry& operator=(SubscriptionEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionEntry* internal_default_instance() {
    return reinterpret_cast<const SubscriptionEntry*>(
               &_SubscriptionEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SubscriptionEntry& a, SubscriptionEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscriptionEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.SubscriptionEntry";
  }
  protected:
  explicit SubscriptionEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kExpressionFieldNumber = 2,
  };
  // .apache.rocketmq.v2.Resource topic = 1 [json_name = "topic"];
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::apache::rocketmq::v2::Resource& topic() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_topic();
  ::apache::rocketmq::v2::Resource* mutable_topic();
  void set_allocated_topic(::apache::rocketmq::v2::Resource* topic);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_topic() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::apache::rocketmq::v2::Resource* topic);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_topic();

  // .apache.rocketmq.v2.FilterExpression expression = 2 [json_name = "expression"];
  bool has_expression() const;
  private:
  bool _internal_has_expression() const;
  public:
  void clear_expression();
  const ::apache::rocketmq::v2::FilterExpression& expression() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::FilterExpression* release_expression();
  ::apache::rocketmq::v2::FilterExpression* mutable_expression();
  void set_allocated_expression(::apache::rocketmq::v2::FilterExpression* expression);
  private:
  const ::apache::rocketmq::v2::FilterExpression& _internal_expression() const;
  ::apache::rocketmq::v2::FilterExpression* _internal_mutable_expression();
  public:
  void unsafe_arena_set_allocated_expression(
      ::apache::rocketmq::v2::FilterExpression* expression);
  ::apache::rocketmq::v2::FilterExpression* unsafe_arena_release_expression();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.SubscriptionEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apache::rocketmq::v2::Resource* topic_;
  ::apache::rocketmq::v2::FilterExpression* expression_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class Address final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.Address) */ {
 public:
  inline Address() : Address(nullptr) {}
  ~Address() override;
  explicit PROTOBUF_CONSTEXPR Address(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Address(const Address& from);
  Address(Address&& from) noexcept
    : Address() {
    *this = ::std::move(from);
  }

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  inline Address& operator=(Address&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Address& default_instance() {
    return *internal_default_instance();
  }
  static inline const Address* internal_default_instance() {
    return reinterpret_cast<const Address*>(
               &_Address_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Address& a, Address& b) {
    a.Swap(&b);
  }
  inline void Swap(Address* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Address* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Address* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Address>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Address& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Address& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Address* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.Address";
  }
  protected:
  explicit Address(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string host = 1 [json_name = "host"];
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // int32 port = 2 [json_name = "port"];
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.Address)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  int32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class Endpoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.Endpoints) */ {
 public:
  inline Endpoints() : Endpoints(nullptr) {}
  ~Endpoints() override;
  explicit PROTOBUF_CONSTEXPR Endpoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Endpoints(const Endpoints& from);
  Endpoints(Endpoints&& from) noexcept
    : Endpoints() {
    *this = ::std::move(from);
  }

  inline Endpoints& operator=(const Endpoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline Endpoints& operator=(Endpoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Endpoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const Endpoints* internal_default_instance() {
    return reinterpret_cast<const Endpoints*>(
               &_Endpoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Endpoints& a, Endpoints& b) {
    a.Swap(&b);
  }
  inline void Swap(Endpoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Endpoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Endpoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Endpoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Endpoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Endpoints& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Endpoints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.Endpoints";
  }
  protected:
  explicit Endpoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressesFieldNumber = 2,
    kSchemeFieldNumber = 1,
  };
  // repeated .apache.rocketmq.v2.Address addresses = 2 [json_name = "addresses"];
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;
  public:
  void clear_addresses();
  ::apache::rocketmq::v2::Address* mutable_addresses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Address >*
      mutable_addresses();
  private:
  const ::apache::rocketmq::v2::Address& _internal_addresses(int index) const;
  ::apache::rocketmq::v2::Address* _internal_add_addresses();
  public:
  const ::apache::rocketmq::v2::Address& addresses(int index) const;
  ::apache::rocketmq::v2::Address* add_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Address >&
      addresses() const;

  // .apache.rocketmq.v2.AddressScheme scheme = 1 [json_name = "scheme"];
  void clear_scheme();
  ::apache::rocketmq::v2::AddressScheme scheme() const;
  void set_scheme(::apache::rocketmq::v2::AddressScheme value);
  private:
  ::apache::rocketmq::v2::AddressScheme _internal_scheme() const;
  void _internal_set_scheme(::apache::rocketmq::v2::AddressScheme value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.Endpoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Address > addresses_;
  int scheme_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class Broker final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.Broker) */ {
 public:
  inline Broker() : Broker(nullptr) {}
  ~Broker() override;
  explicit PROTOBUF_CONSTEXPR Broker(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Broker(const Broker& from);
  Broker(Broker&& from) noexcept
    : Broker() {
    *this = ::std::move(from);
  }

  inline Broker& operator=(const Broker& from) {
    CopyFrom(from);
    return *this;
  }
  inline Broker& operator=(Broker&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Broker& default_instance() {
    return *internal_default_instance();
  }
  static inline const Broker* internal_default_instance() {
    return reinterpret_cast<const Broker*>(
               &_Broker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Broker& a, Broker& b) {
    a.Swap(&b);
  }
  inline void Swap(Broker* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Broker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Broker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Broker>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Broker& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Broker& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Broker* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.Broker";
  }
  protected:
  explicit Broker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEndpointsFieldNumber = 3,
    kIdFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .apache.rocketmq.v2.Endpoints endpoints = 3 [json_name = "endpoints"];
  bool has_endpoints() const;
  private:
  bool _internal_has_endpoints() const;
  public:
  void clear_endpoints();
  const ::apache::rocketmq::v2::Endpoints& endpoints() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Endpoints* release_endpoints();
  ::apache::rocketmq::v2::Endpoints* mutable_endpoints();
  void set_allocated_endpoints(::apache::rocketmq::v2::Endpoints* endpoints);
  private:
  const ::apache::rocketmq::v2::Endpoints& _internal_endpoints() const;
  ::apache::rocketmq::v2::Endpoints* _internal_mutable_endpoints();
  public:
  void unsafe_arena_set_allocated_endpoints(
      ::apache::rocketmq::v2::Endpoints* endpoints);
  ::apache::rocketmq::v2::Endpoints* unsafe_arena_release_endpoints();

  // int32 id = 2 [json_name = "id"];
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.Broker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::apache::rocketmq::v2::Endpoints* endpoints_;
  int32_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class MessageQueue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.MessageQueue) */ {
 public:
  inline MessageQueue() : MessageQueue(nullptr) {}
  ~MessageQueue() override;
  explicit PROTOBUF_CONSTEXPR MessageQueue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageQueue(const MessageQueue& from);
  MessageQueue(MessageQueue&& from) noexcept
    : MessageQueue() {
    *this = ::std::move(from);
  }

  inline MessageQueue& operator=(const MessageQueue& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageQueue& operator=(MessageQueue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageQueue& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageQueue* internal_default_instance() {
    return reinterpret_cast<const MessageQueue*>(
               &_MessageQueue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MessageQueue& a, MessageQueue& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageQueue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageQueue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageQueue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageQueue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageQueue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MessageQueue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageQueue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.MessageQueue";
  }
  protected:
  explicit MessageQueue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptMessageTypesFieldNumber = 5,
    kTopicFieldNumber = 1,
    kBrokerFieldNumber = 4,
    kIdFieldNumber = 2,
    kPermissionFieldNumber = 3,
  };
  // repeated .apache.rocketmq.v2.MessageType accept_message_types = 5 [json_name = "acceptMessageTypes"];
  int accept_message_types_size() const;
  private:
  int _internal_accept_message_types_size() const;
  public:
  void clear_accept_message_types();
  private:
  ::apache::rocketmq::v2::MessageType _internal_accept_message_types(int index) const;
  void _internal_add_accept_message_types(::apache::rocketmq::v2::MessageType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_accept_message_types();
  public:
  ::apache::rocketmq::v2::MessageType accept_message_types(int index) const;
  void set_accept_message_types(int index, ::apache::rocketmq::v2::MessageType value);
  void add_accept_message_types(::apache::rocketmq::v2::MessageType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& accept_message_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_accept_message_types();

  // .apache.rocketmq.v2.Resource topic = 1 [json_name = "topic"];
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::apache::rocketmq::v2::Resource& topic() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_topic();
  ::apache::rocketmq::v2::Resource* mutable_topic();
  void set_allocated_topic(::apache::rocketmq::v2::Resource* topic);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_topic() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::apache::rocketmq::v2::Resource* topic);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_topic();

  // .apache.rocketmq.v2.Broker broker = 4 [json_name = "broker"];
  bool has_broker() const;
  private:
  bool _internal_has_broker() const;
  public:
  void clear_broker();
  const ::apache::rocketmq::v2::Broker& broker() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Broker* release_broker();
  ::apache::rocketmq::v2::Broker* mutable_broker();
  void set_allocated_broker(::apache::rocketmq::v2::Broker* broker);
  private:
  const ::apache::rocketmq::v2::Broker& _internal_broker() const;
  ::apache::rocketmq::v2::Broker* _internal_mutable_broker();
  public:
  void unsafe_arena_set_allocated_broker(
      ::apache::rocketmq::v2::Broker* broker);
  ::apache::rocketmq::v2::Broker* unsafe_arena_release_broker();

  // int32 id = 2 [json_name = "id"];
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // .apache.rocketmq.v2.Permission permission = 3 [json_name = "permission"];
  void clear_permission();
  ::apache::rocketmq::v2::Permission permission() const;
  void set_permission(::apache::rocketmq::v2::Permission value);
  private:
  ::apache::rocketmq::v2::Permission _internal_permission() const;
  void _internal_set_permission(::apache::rocketmq::v2::Permission value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.MessageQueue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> accept_message_types_;
  mutable std::atomic<int> _accept_message_types_cached_byte_size_;
  ::apache::rocketmq::v2::Resource* topic_;
  ::apache::rocketmq::v2::Broker* broker_;
  int32_t id_;
  int permission_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class Digest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.Digest) */ {
 public:
  inline Digest() : Digest(nullptr) {}
  ~Digest() override;
  explicit PROTOBUF_CONSTEXPR Digest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Digest(const Digest& from);
  Digest(Digest&& from) noexcept
    : Digest() {
    *this = ::std::move(from);
  }

  inline Digest& operator=(const Digest& from) {
    CopyFrom(from);
    return *this;
  }
  inline Digest& operator=(Digest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Digest& default_instance() {
    return *internal_default_instance();
  }
  static inline const Digest* internal_default_instance() {
    return reinterpret_cast<const Digest*>(
               &_Digest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Digest& a, Digest& b) {
    a.Swap(&b);
  }
  inline void Swap(Digest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Digest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Digest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Digest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Digest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Digest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Digest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.Digest";
  }
  protected:
  explicit Digest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChecksumFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string checksum = 2 [json_name = "checksum"];
  void clear_checksum();
  const std::string& checksum() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_checksum(ArgT0&& arg0, ArgT... args);
  std::string* mutable_checksum();
  PROTOBUF_NODISCARD std::string* release_checksum();
  void set_allocated_checksum(std::string* checksum);
  private:
  const std::string& _internal_checksum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checksum(const std::string& value);
  std::string* _internal_mutable_checksum();
  public:

  // .apache.rocketmq.v2.DigestType type = 1 [json_name = "type"];
  void clear_type();
  ::apache::rocketmq::v2::DigestType type() const;
  void set_type(::apache::rocketmq::v2::DigestType value);
  private:
  ::apache::rocketmq::v2::DigestType _internal_type() const;
  void _internal_set_type(::apache::rocketmq::v2::DigestType value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.Digest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr checksum_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class SystemProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.SystemProperties) */ {
 public:
  inline SystemProperties() : SystemProperties(nullptr) {}
  ~SystemProperties() override;
  explicit PROTOBUF_CONSTEXPR SystemProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemProperties(const SystemProperties& from);
  SystemProperties(SystemProperties&& from) noexcept
    : SystemProperties() {
    *this = ::std::move(from);
  }

  inline SystemProperties& operator=(const SystemProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemProperties& operator=(SystemProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemProperties* internal_default_instance() {
    return reinterpret_cast<const SystemProperties*>(
               &_SystemProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SystemProperties& a, SystemProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SystemProperties& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.SystemProperties";
  }
  protected:
  explicit SystemProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kTagFieldNumber = 1,
    kMessageIdFieldNumber = 3,
    kBornHostFieldNumber = 8,
    kStoreHostFieldNumber = 10,
    kReceiptHandleFieldNumber = 12,
    kMessageGroupFieldNumber = 17,
    kTraceContextFieldNumber = 18,
    kBodyDigestFieldNumber = 4,
    kBornTimestampFieldNumber = 7,
    kStoreTimestampFieldNumber = 9,
    kDeliveryTimestampFieldNumber = 11,
    kInvisibleDurationFieldNumber = 15,
    kOrphanedTransactionRecoveryDurationFieldNumber = 19,
    kBodyEncodingFieldNumber = 5,
    kMessageTypeFieldNumber = 6,
    kQueueOffsetFieldNumber = 14,
    kQueueIdFieldNumber = 13,
    kDeliveryAttemptFieldNumber = 16,
  };
  // repeated string keys = 2 [json_name = "keys"];
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // optional string tag = 1 [json_name = "tag"];
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // string message_id = 3 [json_name = "messageId"];
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string born_host = 8 [json_name = "bornHost"];
  void clear_born_host();
  const std::string& born_host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_born_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_born_host();
  PROTOBUF_NODISCARD std::string* release_born_host();
  void set_allocated_born_host(std::string* born_host);
  private:
  const std::string& _internal_born_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_born_host(const std::string& value);
  std::string* _internal_mutable_born_host();
  public:

  // string store_host = 10 [json_name = "storeHost"];
  void clear_store_host();
  const std::string& store_host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_host();
  PROTOBUF_NODISCARD std::string* release_store_host();
  void set_allocated_store_host(std::string* store_host);
  private:
  const std::string& _internal_store_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_host(const std::string& value);
  std::string* _internal_mutable_store_host();
  public:

  // optional string receipt_handle = 12 [json_name = "receiptHandle"];
  bool has_receipt_handle() const;
  private:
  bool _internal_has_receipt_handle() const;
  public:
  void clear_receipt_handle();
  const std::string& receipt_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receipt_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receipt_handle();
  PROTOBUF_NODISCARD std::string* release_receipt_handle();
  void set_allocated_receipt_handle(std::string* receipt_handle);
  private:
  const std::string& _internal_receipt_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receipt_handle(const std::string& value);
  std::string* _internal_mutable_receipt_handle();
  public:

  // optional string message_group = 17 [json_name = "messageGroup"];
  bool has_message_group() const;
  private:
  bool _internal_has_message_group() const;
  public:
  void clear_message_group();
  const std::string& message_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_group();
  PROTOBUF_NODISCARD std::string* release_message_group();
  void set_allocated_message_group(std::string* message_group);
  private:
  const std::string& _internal_message_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_group(const std::string& value);
  std::string* _internal_mutable_message_group();
  public:

  // optional string trace_context = 18 [json_name = "traceContext"];
  bool has_trace_context() const;
  private:
  bool _internal_has_trace_context() const;
  public:
  void clear_trace_context();
  const std::string& trace_context() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_context(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_context();
  PROTOBUF_NODISCARD std::string* release_trace_context();
  void set_allocated_trace_context(std::string* trace_context);
  private:
  const std::string& _internal_trace_context() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_context(const std::string& value);
  std::string* _internal_mutable_trace_context();
  public:

  // .apache.rocketmq.v2.Digest body_digest = 4 [json_name = "bodyDigest"];
  bool has_body_digest() const;
  private:
  bool _internal_has_body_digest() const;
  public:
  void clear_body_digest();
  const ::apache::rocketmq::v2::Digest& body_digest() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Digest* release_body_digest();
  ::apache::rocketmq::v2::Digest* mutable_body_digest();
  void set_allocated_body_digest(::apache::rocketmq::v2::Digest* body_digest);
  private:
  const ::apache::rocketmq::v2::Digest& _internal_body_digest() const;
  ::apache::rocketmq::v2::Digest* _internal_mutable_body_digest();
  public:
  void unsafe_arena_set_allocated_body_digest(
      ::apache::rocketmq::v2::Digest* body_digest);
  ::apache::rocketmq::v2::Digest* unsafe_arena_release_body_digest();

  // .google.protobuf.Timestamp born_timestamp = 7 [json_name = "bornTimestamp"];
  bool has_born_timestamp() const;
  private:
  bool _internal_has_born_timestamp() const;
  public:
  void clear_born_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& born_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_born_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_born_timestamp();
  void set_allocated_born_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* born_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_born_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_born_timestamp();
  public:
  void unsafe_arena_set_allocated_born_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* born_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_born_timestamp();

  // optional .google.protobuf.Timestamp store_timestamp = 9 [json_name = "storeTimestamp"];
  bool has_store_timestamp() const;
  private:
  bool _internal_has_store_timestamp() const;
  public:
  void clear_store_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& store_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_store_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_store_timestamp();
  void set_allocated_store_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* store_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_store_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_store_timestamp();
  public:
  void unsafe_arena_set_allocated_store_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* store_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_store_timestamp();

  // optional .google.protobuf.Timestamp delivery_timestamp = 11 [json_name = "deliveryTimestamp"];
  bool has_delivery_timestamp() const;
  private:
  bool _internal_has_delivery_timestamp() const;
  public:
  void clear_delivery_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& delivery_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_delivery_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_delivery_timestamp();
  void set_allocated_delivery_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_delivery_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_delivery_timestamp();
  public:
  void unsafe_arena_set_allocated_delivery_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_delivery_timestamp();

  // optional .google.protobuf.Duration invisible_duration = 15 [json_name = "invisibleDuration"];
  bool has_invisible_duration() const;
  private:
  bool _internal_has_invisible_duration() const;
  public:
  void clear_invisible_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& invisible_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_invisible_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_invisible_duration();
  void set_allocated_invisible_duration(::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_invisible_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_invisible_duration();
  public:
  void unsafe_arena_set_allocated_invisible_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_invisible_duration();

  // optional .google.protobuf.Duration orphaned_transaction_recovery_duration = 19 [json_name = "orphanedTransactionRecoveryDuration"];
  bool has_orphaned_transaction_recovery_duration() const;
  private:
  bool _internal_has_orphaned_transaction_recovery_duration() const;
  public:
  void clear_orphaned_transaction_recovery_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& orphaned_transaction_recovery_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_orphaned_transaction_recovery_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_orphaned_transaction_recovery_duration();
  void set_allocated_orphaned_transaction_recovery_duration(::PROTOBUF_NAMESPACE_ID::Duration* orphaned_transaction_recovery_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_orphaned_transaction_recovery_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_orphaned_transaction_recovery_duration();
  public:
  void unsafe_arena_set_allocated_orphaned_transaction_recovery_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* orphaned_transaction_recovery_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_orphaned_transaction_recovery_duration();

  // .apache.rocketmq.v2.Encoding body_encoding = 5 [json_name = "bodyEncoding"];
  void clear_body_encoding();
  ::apache::rocketmq::v2::Encoding body_encoding() const;
  void set_body_encoding(::apache::rocketmq::v2::Encoding value);
  private:
  ::apache::rocketmq::v2::Encoding _internal_body_encoding() const;
  void _internal_set_body_encoding(::apache::rocketmq::v2::Encoding value);
  public:

  // .apache.rocketmq.v2.MessageType message_type = 6 [json_name = "messageType"];
  void clear_message_type();
  ::apache::rocketmq::v2::MessageType message_type() const;
  void set_message_type(::apache::rocketmq::v2::MessageType value);
  private:
  ::apache::rocketmq::v2::MessageType _internal_message_type() const;
  void _internal_set_message_type(::apache::rocketmq::v2::MessageType value);
  public:

  // optional int64 queue_offset = 14 [json_name = "queueOffset"];
  bool has_queue_offset() const;
  private:
  bool _internal_has_queue_offset() const;
  public:
  void clear_queue_offset();
  int64_t queue_offset() const;
  void set_queue_offset(int64_t value);
  private:
  int64_t _internal_queue_offset() const;
  void _internal_set_queue_offset(int64_t value);
  public:

  // int32 queue_id = 13 [json_name = "queueId"];
  void clear_queue_id();
  int32_t queue_id() const;
  void set_queue_id(int32_t value);
  private:
  int32_t _internal_queue_id() const;
  void _internal_set_queue_id(int32_t value);
  public:

  // optional int32 delivery_attempt = 16 [json_name = "deliveryAttempt"];
  bool has_delivery_attempt() const;
  private:
  bool _internal_has_delivery_attempt() const;
  public:
  void clear_delivery_attempt();
  int32_t delivery_attempt() const;
  void set_delivery_attempt(int32_t value);
  private:
  int32_t _internal_delivery_attempt() const;
  void _internal_set_delivery_attempt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.SystemProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr born_host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receipt_handle_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_context_;
  ::apache::rocketmq::v2::Digest* body_digest_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* born_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* store_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration_;
  ::PROTOBUF_NAMESPACE_ID::Duration* orphaned_transaction_recovery_duration_;
  int body_encoding_;
  int message_type_;
  int64_t queue_offset_;
  int32_t queue_id_;
  int32_t delivery_attempt_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class Message_UserPropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Message_UserPropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Message_UserPropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Message_UserPropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Message_UserPropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Message_UserPropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Message_UserPropertiesEntry_DoNotUse& other);
  static const Message_UserPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Message_UserPropertiesEntry_DoNotUse*>(&_Message_UserPropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "apache.rocketmq.v2.Message.UserPropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "apache.rocketmq.v2.Message.UserPropertiesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};

// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kUserPropertiesFieldNumber = 2,
    kBodyFieldNumber = 4,
    kTopicFieldNumber = 1,
    kSystemPropertiesFieldNumber = 3,
  };
  // map<string, string> user_properties = 2 [json_name = "userProperties"];
  int user_properties_size() const;
  private:
  int _internal_user_properties_size() const;
  public:
  void clear_user_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_user_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_user_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      user_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_user_properties();

  // bytes body = 4 [json_name = "body"];
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // .apache.rocketmq.v2.Resource topic = 1 [json_name = "topic"];
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::apache::rocketmq::v2::Resource& topic() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_topic();
  ::apache::rocketmq::v2::Resource* mutable_topic();
  void set_allocated_topic(::apache::rocketmq::v2::Resource* topic);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_topic() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::apache::rocketmq::v2::Resource* topic);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_topic();

  // .apache.rocketmq.v2.SystemProperties system_properties = 3 [json_name = "systemProperties"];
  bool has_system_properties() const;
  private:
  bool _internal_has_system_properties() const;
  public:
  void clear_system_properties();
  const ::apache::rocketmq::v2::SystemProperties& system_properties() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::SystemProperties* release_system_properties();
  ::apache::rocketmq::v2::SystemProperties* mutable_system_properties();
  void set_allocated_system_properties(::apache::rocketmq::v2::SystemProperties* system_properties);
  private:
  const ::apache::rocketmq::v2::SystemProperties& _internal_system_properties() const;
  ::apache::rocketmq::v2::SystemProperties* _internal_mutable_system_properties();
  public:
  void unsafe_arena_set_allocated_system_properties(
      ::apache::rocketmq::v2::SystemProperties* system_properties);
  ::apache::rocketmq::v2::SystemProperties* unsafe_arena_release_system_properties();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Message_UserPropertiesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> user_properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
  ::apache::rocketmq::v2::Resource* topic_;
  ::apache::rocketmq::v2::SystemProperties* system_properties_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class Assignment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.Assignment) */ {
 public:
  inline Assignment() : Assignment(nullptr) {}
  ~Assignment() override;
  explicit PROTOBUF_CONSTEXPR Assignment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Assignment(const Assignment& from);
  Assignment(Assignment&& from) noexcept
    : Assignment() {
    *this = ::std::move(from);
  }

  inline Assignment& operator=(const Assignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Assignment& operator=(Assignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Assignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Assignment* internal_default_instance() {
    return reinterpret_cast<const Assignment*>(
               &_Assignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Assignment& a, Assignment& b) {
    a.Swap(&b);
  }
  inline void Swap(Assignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Assignment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Assignment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Assignment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Assignment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Assignment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Assignment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.Assignment";
  }
  protected:
  explicit Assignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageQueueFieldNumber = 1,
  };
  // .apache.rocketmq.v2.MessageQueue message_queue = 1 [json_name = "messageQueue"];
  bool has_message_queue() const;
  private:
  bool _internal_has_message_queue() const;
  public:
  void clear_message_queue();
  const ::apache::rocketmq::v2::MessageQueue& message_queue() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::MessageQueue* release_message_queue();
  ::apache::rocketmq::v2::MessageQueue* mutable_message_queue();
  void set_allocated_message_queue(::apache::rocketmq::v2::MessageQueue* message_queue);
  private:
  const ::apache::rocketmq::v2::MessageQueue& _internal_message_queue() const;
  ::apache::rocketmq::v2::MessageQueue* _internal_mutable_message_queue();
  public:
  void unsafe_arena_set_allocated_message_queue(
      ::apache::rocketmq::v2::MessageQueue* message_queue);
  ::apache::rocketmq::v2::MessageQueue* unsafe_arena_release_message_queue();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.Assignment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apache::rocketmq::v2::MessageQueue* message_queue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit PROTOBUF_CONSTEXPR Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Status& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .apache.rocketmq.v2.Code code = 1 [json_name = "code"];
  void clear_code();
  ::apache::rocketmq::v2::Code code() const;
  void set_code(::apache::rocketmq::v2::Code value);
  private:
  ::apache::rocketmq::v2::Code _internal_code() const;
  void _internal_set_code(::apache::rocketmq::v2::Code value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// -------------------------------------------------------------------

class UA final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.UA) */ {
 public:
  inline UA() : UA(nullptr) {}
  ~UA() override;
  explicit PROTOBUF_CONSTEXPR UA(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UA(const UA& from);
  UA(UA&& from) noexcept
    : UA() {
    *this = ::std::move(from);
  }

  inline UA& operator=(const UA& from) {
    CopyFrom(from);
    return *this;
  }
  inline UA& operator=(UA&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UA& default_instance() {
    return *internal_default_instance();
  }
  static inline const UA* internal_default_instance() {
    return reinterpret_cast<const UA*>(
               &_UA_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UA& a, UA& b) {
    a.Swap(&b);
  }
  inline void Swap(UA* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UA* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UA* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UA>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UA& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UA& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UA* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.UA";
  }
  protected:
  explicit UA(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kPlatformFieldNumber = 3,
    kHostnameFieldNumber = 4,
    kLanguageFieldNumber = 1,
  };
  // string version = 2 [json_name = "version"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string platform = 3 [json_name = "platform"];
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // string hostname = 4 [json_name = "hostname"];
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // .apache.rocketmq.v2.Language language = 1 [json_name = "language"];
  void clear_language();
  ::apache::rocketmq::v2::Language language() const;
  void set_language(::apache::rocketmq::v2::Language value);
  private:
  ::apache::rocketmq::v2::Language _internal_language() const;
  void _internal_set_language(::apache::rocketmq::v2::Language value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.UA)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  int language_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fdefinition_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FilterExpression

// .apache.rocketmq.v2.FilterType type = 1 [json_name = "type"];
inline void FilterExpression::clear_type() {
  type_ = 0;
}
inline ::apache::rocketmq::v2::FilterType FilterExpression::_internal_type() const {
  return static_cast< ::apache::rocketmq::v2::FilterType >(type_);
}
inline ::apache::rocketmq::v2::FilterType FilterExpression::type() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.FilterExpression.type)
  return _internal_type();
}
inline void FilterExpression::_internal_set_type(::apache::rocketmq::v2::FilterType value) {
  
  type_ = value;
}
inline void FilterExpression::set_type(::apache::rocketmq::v2::FilterType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.FilterExpression.type)
}

// string expression = 2 [json_name = "expression"];
inline void FilterExpression::clear_expression() {
  expression_.ClearToEmpty();
}
inline const std::string& FilterExpression::expression() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.FilterExpression.expression)
  return _internal_expression();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FilterExpression::set_expression(ArgT0&& arg0, ArgT... args) {
 
 expression_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.FilterExpression.expression)
}
inline std::string* FilterExpression::mutable_expression() {
  std::string* _s = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.FilterExpression.expression)
  return _s;
}
inline const std::string& FilterExpression::_internal_expression() const {
  return expression_.Get();
}
inline void FilterExpression::_internal_set_expression(const std::string& value) {
  
  expression_.Set(value, GetArenaForAllocation());
}
inline std::string* FilterExpression::_internal_mutable_expression() {
  
  return expression_.Mutable(GetArenaForAllocation());
}
inline std::string* FilterExpression::release_expression() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.FilterExpression.expression)
  return expression_.Release();
}
inline void FilterExpression::set_allocated_expression(std::string* expression) {
  if (expression != nullptr) {
    
  } else {
    
  }
  expression_.SetAllocated(expression, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (expression_.IsDefault()) {
    expression_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.FilterExpression.expression)
}

// -------------------------------------------------------------------

// RetryPolicy

// int32 max_attempts = 1 [json_name = "maxAttempts"];
inline void RetryPolicy::clear_max_attempts() {
  max_attempts_ = 0;
}
inline int32_t RetryPolicy::_internal_max_attempts() const {
  return max_attempts_;
}
inline int32_t RetryPolicy::max_attempts() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.RetryPolicy.max_attempts)
  return _internal_max_attempts();
}
inline void RetryPolicy::_internal_set_max_attempts(int32_t value) {
  
  max_attempts_ = value;
}
inline void RetryPolicy::set_max_attempts(int32_t value) {
  _internal_set_max_attempts(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.RetryPolicy.max_attempts)
}

// .apache.rocketmq.v2.ExponentialBackoff exponential_backoff = 2 [json_name = "exponentialBackoff"];
inline bool RetryPolicy::_internal_has_exponential_backoff() const {
  return strategy_case() == kExponentialBackoff;
}
inline bool RetryPolicy::has_exponential_backoff() const {
  return _internal_has_exponential_backoff();
}
inline void RetryPolicy::set_has_exponential_backoff() {
  _oneof_case_[0] = kExponentialBackoff;
}
inline void RetryPolicy::clear_exponential_backoff() {
  if (_internal_has_exponential_backoff()) {
    if (GetArenaForAllocation() == nullptr) {
      delete strategy_.exponential_backoff_;
    }
    clear_has_strategy();
  }
}
inline ::apache::rocketmq::v2::ExponentialBackoff* RetryPolicy::release_exponential_backoff() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.RetryPolicy.exponential_backoff)
  if (_internal_has_exponential_backoff()) {
    clear_has_strategy();
    ::apache::rocketmq::v2::ExponentialBackoff* temp = strategy_.exponential_backoff_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    strategy_.exponential_backoff_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apache::rocketmq::v2::ExponentialBackoff& RetryPolicy::_internal_exponential_backoff() const {
  return _internal_has_exponential_backoff()
      ? *strategy_.exponential_backoff_
      : reinterpret_cast< ::apache::rocketmq::v2::ExponentialBackoff&>(::apache::rocketmq::v2::_ExponentialBackoff_default_instance_);
}
inline const ::apache::rocketmq::v2::ExponentialBackoff& RetryPolicy::exponential_backoff() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.RetryPolicy.exponential_backoff)
  return _internal_exponential_backoff();
}
inline ::apache::rocketmq::v2::ExponentialBackoff* RetryPolicy::unsafe_arena_release_exponential_backoff() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.RetryPolicy.exponential_backoff)
  if (_internal_has_exponential_backoff()) {
    clear_has_strategy();
    ::apache::rocketmq::v2::ExponentialBackoff* temp = strategy_.exponential_backoff_;
    strategy_.exponential_backoff_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RetryPolicy::unsafe_arena_set_allocated_exponential_backoff(::apache::rocketmq::v2::ExponentialBackoff* exponential_backoff) {
  clear_strategy();
  if (exponential_backoff) {
    set_has_exponential_backoff();
    strategy_.exponential_backoff_ = exponential_backoff;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.RetryPolicy.exponential_backoff)
}
inline ::apache::rocketmq::v2::ExponentialBackoff* RetryPolicy::_internal_mutable_exponential_backoff() {
  if (!_internal_has_exponential_backoff()) {
    clear_strategy();
    set_has_exponential_backoff();
    strategy_.exponential_backoff_ = CreateMaybeMessage< ::apache::rocketmq::v2::ExponentialBackoff >(GetArenaForAllocation());
  }
  return strategy_.exponential_backoff_;
}
inline ::apache::rocketmq::v2::ExponentialBackoff* RetryPolicy::mutable_exponential_backoff() {
  ::apache::rocketmq::v2::ExponentialBackoff* _msg = _internal_mutable_exponential_backoff();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.RetryPolicy.exponential_backoff)
  return _msg;
}

// .apache.rocketmq.v2.CustomizedBackoff customized_backoff = 3 [json_name = "customizedBackoff"];
inline bool RetryPolicy::_internal_has_customized_backoff() const {
  return strategy_case() == kCustomizedBackoff;
}
inline bool RetryPolicy::has_customized_backoff() const {
  return _internal_has_customized_backoff();
}
inline void RetryPolicy::set_has_customized_backoff() {
  _oneof_case_[0] = kCustomizedBackoff;
}
inline void RetryPolicy::clear_customized_backoff() {
  if (_internal_has_customized_backoff()) {
    if (GetArenaForAllocation() == nullptr) {
      delete strategy_.customized_backoff_;
    }
    clear_has_strategy();
  }
}
inline ::apache::rocketmq::v2::CustomizedBackoff* RetryPolicy::release_customized_backoff() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.RetryPolicy.customized_backoff)
  if (_internal_has_customized_backoff()) {
    clear_has_strategy();
    ::apache::rocketmq::v2::CustomizedBackoff* temp = strategy_.customized_backoff_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    strategy_.customized_backoff_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apache::rocketmq::v2::CustomizedBackoff& RetryPolicy::_internal_customized_backoff() const {
  return _internal_has_customized_backoff()
      ? *strategy_.customized_backoff_
      : reinterpret_cast< ::apache::rocketmq::v2::CustomizedBackoff&>(::apache::rocketmq::v2::_CustomizedBackoff_default_instance_);
}
inline const ::apache::rocketmq::v2::CustomizedBackoff& RetryPolicy::customized_backoff() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.RetryPolicy.customized_backoff)
  return _internal_customized_backoff();
}
inline ::apache::rocketmq::v2::CustomizedBackoff* RetryPolicy::unsafe_arena_release_customized_backoff() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.RetryPolicy.customized_backoff)
  if (_internal_has_customized_backoff()) {
    clear_has_strategy();
    ::apache::rocketmq::v2::CustomizedBackoff* temp = strategy_.customized_backoff_;
    strategy_.customized_backoff_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RetryPolicy::unsafe_arena_set_allocated_customized_backoff(::apache::rocketmq::v2::CustomizedBackoff* customized_backoff) {
  clear_strategy();
  if (customized_backoff) {
    set_has_customized_backoff();
    strategy_.customized_backoff_ = customized_backoff;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.RetryPolicy.customized_backoff)
}
inline ::apache::rocketmq::v2::CustomizedBackoff* RetryPolicy::_internal_mutable_customized_backoff() {
  if (!_internal_has_customized_backoff()) {
    clear_strategy();
    set_has_customized_backoff();
    strategy_.customized_backoff_ = CreateMaybeMessage< ::apache::rocketmq::v2::CustomizedBackoff >(GetArenaForAllocation());
  }
  return strategy_.customized_backoff_;
}
inline ::apache::rocketmq::v2::CustomizedBackoff* RetryPolicy::mutable_customized_backoff() {
  ::apache::rocketmq::v2::CustomizedBackoff* _msg = _internal_mutable_customized_backoff();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.RetryPolicy.customized_backoff)
  return _msg;
}

inline bool RetryPolicy::has_strategy() const {
  return strategy_case() != STRATEGY_NOT_SET;
}
inline void RetryPolicy::clear_has_strategy() {
  _oneof_case_[0] = STRATEGY_NOT_SET;
}
inline RetryPolicy::StrategyCase RetryPolicy::strategy_case() const {
  return RetryPolicy::StrategyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExponentialBackoff

// .google.protobuf.Duration initial = 1 [json_name = "initial"];
inline bool ExponentialBackoff::_internal_has_initial() const {
  return this != internal_default_instance() && initial_ != nullptr;
}
inline bool ExponentialBackoff::has_initial() const {
  return _internal_has_initial();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ExponentialBackoff::_internal_initial() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = initial_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ExponentialBackoff::initial() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ExponentialBackoff.initial)
  return _internal_initial();
}
inline void ExponentialBackoff::unsafe_arena_set_allocated_initial(
    ::PROTOBUF_NAMESPACE_ID::Duration* initial) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initial_);
  }
  initial_ = initial;
  if (initial) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ExponentialBackoff.initial)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ExponentialBackoff::release_initial() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = initial_;
  initial_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ExponentialBackoff::unsafe_arena_release_initial() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ExponentialBackoff.initial)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = initial_;
  initial_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ExponentialBackoff::_internal_mutable_initial() {
  
  if (initial_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    initial_ = p;
  }
  return initial_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ExponentialBackoff::mutable_initial() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_initial();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ExponentialBackoff.initial)
  return _msg;
}
inline void ExponentialBackoff::set_allocated_initial(::PROTOBUF_NAMESPACE_ID::Duration* initial) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(initial_);
  }
  if (initial) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initial));
    if (message_arena != submessage_arena) {
      initial = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial, submessage_arena);
    }
    
  } else {
    
  }
  initial_ = initial;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ExponentialBackoff.initial)
}

// .google.protobuf.Duration max = 2 [json_name = "max"];
inline bool ExponentialBackoff::_internal_has_max() const {
  return this != internal_default_instance() && max_ != nullptr;
}
inline bool ExponentialBackoff::has_max() const {
  return _internal_has_max();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ExponentialBackoff::_internal_max() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = max_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ExponentialBackoff::max() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ExponentialBackoff.max)
  return _internal_max();
}
inline void ExponentialBackoff::unsafe_arena_set_allocated_max(
    ::PROTOBUF_NAMESPACE_ID::Duration* max) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_);
  }
  max_ = max;
  if (max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ExponentialBackoff.max)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ExponentialBackoff::release_max() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = max_;
  max_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ExponentialBackoff::unsafe_arena_release_max() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ExponentialBackoff.max)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = max_;
  max_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ExponentialBackoff::_internal_mutable_max() {
  
  if (max_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    max_ = p;
  }
  return max_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ExponentialBackoff::mutable_max() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ExponentialBackoff.max)
  return _msg;
}
inline void ExponentialBackoff::set_allocated_max(::PROTOBUF_NAMESPACE_ID::Duration* max) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_);
  }
  if (max) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max));
    if (message_arena != submessage_arena) {
      max = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max, submessage_arena);
    }
    
  } else {
    
  }
  max_ = max;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ExponentialBackoff.max)
}

// float multiplier = 3 [json_name = "multiplier"];
inline void ExponentialBackoff::clear_multiplier() {
  multiplier_ = 0;
}
inline float ExponentialBackoff::_internal_multiplier() const {
  return multiplier_;
}
inline float ExponentialBackoff::multiplier() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ExponentialBackoff.multiplier)
  return _internal_multiplier();
}
inline void ExponentialBackoff::_internal_set_multiplier(float value) {
  
  multiplier_ = value;
}
inline void ExponentialBackoff::set_multiplier(float value) {
  _internal_set_multiplier(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.ExponentialBackoff.multiplier)
}

// -------------------------------------------------------------------

// CustomizedBackoff

// repeated .google.protobuf.Duration next = 1 [json_name = "next"];
inline int CustomizedBackoff::_internal_next_size() const {
  return next_.size();
}
inline int CustomizedBackoff::next_size() const {
  return _internal_next_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CustomizedBackoff::mutable_next(int index) {
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.CustomizedBackoff.next)
  return next_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Duration >*
CustomizedBackoff::mutable_next() {
  // @@protoc_insertion_point(field_mutable_list:apache.rocketmq.v2.CustomizedBackoff.next)
  return &next_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& CustomizedBackoff::_internal_next(int index) const {
  return next_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& CustomizedBackoff::next(int index) const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.CustomizedBackoff.next)
  return _internal_next(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CustomizedBackoff::_internal_add_next() {
  return next_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CustomizedBackoff::add_next() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _add = _internal_add_next();
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.CustomizedBackoff.next)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Duration >&
CustomizedBackoff::next() const {
  // @@protoc_insertion_point(field_list:apache.rocketmq.v2.CustomizedBackoff.next)
  return next_;
}

// -------------------------------------------------------------------

// Resource

// string resource_namespace = 1 [json_name = "resourceNamespace"];
inline void Resource::clear_resource_namespace() {
  resource_namespace_.ClearToEmpty();
}
inline const std::string& Resource::resource_namespace() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Resource.resource_namespace)
  return _internal_resource_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_resource_namespace(ArgT0&& arg0, ArgT... args) {
 
 resource_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Resource.resource_namespace)
}
inline std::string* Resource::mutable_resource_namespace() {
  std::string* _s = _internal_mutable_resource_namespace();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Resource.resource_namespace)
  return _s;
}
inline const std::string& Resource::_internal_resource_namespace() const {
  return resource_namespace_.Get();
}
inline void Resource::_internal_set_resource_namespace(const std::string& value) {
  
  resource_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_resource_namespace() {
  
  return resource_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_resource_namespace() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Resource.resource_namespace)
  return resource_namespace_.Release();
}
inline void Resource::set_allocated_resource_namespace(std::string* resource_namespace) {
  if (resource_namespace != nullptr) {
    
  } else {
    
  }
  resource_namespace_.SetAllocated(resource_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_namespace_.IsDefault()) {
    resource_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Resource.resource_namespace)
}

// string name = 2 [json_name = "name"];
inline void Resource::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Resource::name() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Resource.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Resource.name)
}
inline std::string* Resource::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Resource.name)
  return _s;
}
inline const std::string& Resource::_internal_name() const {
  return name_.Get();
}
inline void Resource::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_name() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Resource.name)
  return name_.Release();
}
inline void Resource::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Resource.name)
}

// -------------------------------------------------------------------

// SubscriptionEntry

// .apache.rocketmq.v2.Resource topic = 1 [json_name = "topic"];
inline bool SubscriptionEntry::_internal_has_topic() const {
  return this != internal_default_instance() && topic_ != nullptr;
}
inline bool SubscriptionEntry::has_topic() const {
  return _internal_has_topic();
}
inline void SubscriptionEntry::clear_topic() {
  if (GetArenaForAllocation() == nullptr && topic_ != nullptr) {
    delete topic_;
  }
  topic_ = nullptr;
}
inline const ::apache::rocketmq::v2::Resource& SubscriptionEntry::_internal_topic() const {
  const ::apache::rocketmq::v2::Resource* p = topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& SubscriptionEntry::topic() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SubscriptionEntry.topic)
  return _internal_topic();
}
inline void SubscriptionEntry::unsafe_arena_set_allocated_topic(
    ::apache::rocketmq::v2::Resource* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.SubscriptionEntry.topic)
}
inline ::apache::rocketmq::v2::Resource* SubscriptionEntry::release_topic() {
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* SubscriptionEntry::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SubscriptionEntry.topic)
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* SubscriptionEntry::_internal_mutable_topic() {
  
  if (topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    topic_ = p;
  }
  return topic_;
}
inline ::apache::rocketmq::v2::Resource* SubscriptionEntry::mutable_topic() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SubscriptionEntry.topic)
  return _msg;
}
inline void SubscriptionEntry::set_allocated_topic(::apache::rocketmq::v2::Resource* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete topic_;
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(topic);
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SubscriptionEntry.topic)
}

// .apache.rocketmq.v2.FilterExpression expression = 2 [json_name = "expression"];
inline bool SubscriptionEntry::_internal_has_expression() const {
  return this != internal_default_instance() && expression_ != nullptr;
}
inline bool SubscriptionEntry::has_expression() const {
  return _internal_has_expression();
}
inline void SubscriptionEntry::clear_expression() {
  if (GetArenaForAllocation() == nullptr && expression_ != nullptr) {
    delete expression_;
  }
  expression_ = nullptr;
}
inline const ::apache::rocketmq::v2::FilterExpression& SubscriptionEntry::_internal_expression() const {
  const ::apache::rocketmq::v2::FilterExpression* p = expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::FilterExpression&>(
      ::apache::rocketmq::v2::_FilterExpression_default_instance_);
}
inline const ::apache::rocketmq::v2::FilterExpression& SubscriptionEntry::expression() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SubscriptionEntry.expression)
  return _internal_expression();
}
inline void SubscriptionEntry::unsafe_arena_set_allocated_expression(
    ::apache::rocketmq::v2::FilterExpression* expression) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expression_);
  }
  expression_ = expression;
  if (expression) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.SubscriptionEntry.expression)
}
inline ::apache::rocketmq::v2::FilterExpression* SubscriptionEntry::release_expression() {
  
  ::apache::rocketmq::v2::FilterExpression* temp = expression_;
  expression_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::FilterExpression* SubscriptionEntry::unsafe_arena_release_expression() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SubscriptionEntry.expression)
  
  ::apache::rocketmq::v2::FilterExpression* temp = expression_;
  expression_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::FilterExpression* SubscriptionEntry::_internal_mutable_expression() {
  
  if (expression_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::FilterExpression>(GetArenaForAllocation());
    expression_ = p;
  }
  return expression_;
}
inline ::apache::rocketmq::v2::FilterExpression* SubscriptionEntry::mutable_expression() {
  ::apache::rocketmq::v2::FilterExpression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SubscriptionEntry.expression)
  return _msg;
}
inline void SubscriptionEntry::set_allocated_expression(::apache::rocketmq::v2::FilterExpression* expression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete expression_;
  }
  if (expression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expression);
    if (message_arena != submessage_arena) {
      expression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expression, submessage_arena);
    }
    
  } else {
    
  }
  expression_ = expression;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SubscriptionEntry.expression)
}

// -------------------------------------------------------------------

// Address

// string host = 1 [json_name = "host"];
inline void Address::clear_host() {
  host_.ClearToEmpty();
}
inline const std::string& Address::host() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Address.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Address::set_host(ArgT0&& arg0, ArgT... args) {
 
 host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Address.host)
}
inline std::string* Address::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Address.host)
  return _s;
}
inline const std::string& Address::_internal_host() const {
  return host_.Get();
}
inline void Address::_internal_set_host(const std::string& value) {
  
  host_.Set(value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_host() {
  
  return host_.Mutable(GetArenaForAllocation());
}
inline std::string* Address::release_host() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Address.host)
  return host_.Release();
}
inline void Address::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_.IsDefault()) {
    host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Address.host)
}

// int32 port = 2 [json_name = "port"];
inline void Address::clear_port() {
  port_ = 0;
}
inline int32_t Address::_internal_port() const {
  return port_;
}
inline int32_t Address::port() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Address.port)
  return _internal_port();
}
inline void Address::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void Address::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Address.port)
}

// -------------------------------------------------------------------

// Endpoints

// .apache.rocketmq.v2.AddressScheme scheme = 1 [json_name = "scheme"];
inline void Endpoints::clear_scheme() {
  scheme_ = 0;
}
inline ::apache::rocketmq::v2::AddressScheme Endpoints::_internal_scheme() const {
  return static_cast< ::apache::rocketmq::v2::AddressScheme >(scheme_);
}
inline ::apache::rocketmq::v2::AddressScheme Endpoints::scheme() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Endpoints.scheme)
  return _internal_scheme();
}
inline void Endpoints::_internal_set_scheme(::apache::rocketmq::v2::AddressScheme value) {
  
  scheme_ = value;
}
inline void Endpoints::set_scheme(::apache::rocketmq::v2::AddressScheme value) {
  _internal_set_scheme(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Endpoints.scheme)
}

// repeated .apache.rocketmq.v2.Address addresses = 2 [json_name = "addresses"];
inline int Endpoints::_internal_addresses_size() const {
  return addresses_.size();
}
inline int Endpoints::addresses_size() const {
  return _internal_addresses_size();
}
inline void Endpoints::clear_addresses() {
  addresses_.Clear();
}
inline ::apache::rocketmq::v2::Address* Endpoints::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Endpoints.addresses)
  return addresses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Address >*
Endpoints::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:apache.rocketmq.v2.Endpoints.addresses)
  return &addresses_;
}
inline const ::apache::rocketmq::v2::Address& Endpoints::_internal_addresses(int index) const {
  return addresses_.Get(index);
}
inline const ::apache::rocketmq::v2::Address& Endpoints::addresses(int index) const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Endpoints.addresses)
  return _internal_addresses(index);
}
inline ::apache::rocketmq::v2::Address* Endpoints::_internal_add_addresses() {
  return addresses_.Add();
}
inline ::apache::rocketmq::v2::Address* Endpoints::add_addresses() {
  ::apache::rocketmq::v2::Address* _add = _internal_add_addresses();
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.Endpoints.addresses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Address >&
Endpoints::addresses() const {
  // @@protoc_insertion_point(field_list:apache.rocketmq.v2.Endpoints.addresses)
  return addresses_;
}

// -------------------------------------------------------------------

// Broker

// string name = 1 [json_name = "name"];
inline void Broker::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Broker::name() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Broker.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Broker::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Broker.name)
}
inline std::string* Broker::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Broker.name)
  return _s;
}
inline const std::string& Broker::_internal_name() const {
  return name_.Get();
}
inline void Broker::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Broker::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Broker::release_name() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Broker.name)
  return name_.Release();
}
inline void Broker::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Broker.name)
}

// int32 id = 2 [json_name = "id"];
inline void Broker::clear_id() {
  id_ = 0;
}
inline int32_t Broker::_internal_id() const {
  return id_;
}
inline int32_t Broker::id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Broker.id)
  return _internal_id();
}
inline void Broker::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void Broker::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Broker.id)
}

// .apache.rocketmq.v2.Endpoints endpoints = 3 [json_name = "endpoints"];
inline bool Broker::_internal_has_endpoints() const {
  return this != internal_default_instance() && endpoints_ != nullptr;
}
inline bool Broker::has_endpoints() const {
  return _internal_has_endpoints();
}
inline void Broker::clear_endpoints() {
  if (GetArenaForAllocation() == nullptr && endpoints_ != nullptr) {
    delete endpoints_;
  }
  endpoints_ = nullptr;
}
inline const ::apache::rocketmq::v2::Endpoints& Broker::_internal_endpoints() const {
  const ::apache::rocketmq::v2::Endpoints* p = endpoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Endpoints&>(
      ::apache::rocketmq::v2::_Endpoints_default_instance_);
}
inline const ::apache::rocketmq::v2::Endpoints& Broker::endpoints() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Broker.endpoints)
  return _internal_endpoints();
}
inline void Broker::unsafe_arena_set_allocated_endpoints(
    ::apache::rocketmq::v2::Endpoints* endpoints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoints_);
  }
  endpoints_ = endpoints;
  if (endpoints) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Broker.endpoints)
}
inline ::apache::rocketmq::v2::Endpoints* Broker::release_endpoints() {
  
  ::apache::rocketmq::v2::Endpoints* temp = endpoints_;
  endpoints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Endpoints* Broker::unsafe_arena_release_endpoints() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Broker.endpoints)
  
  ::apache::rocketmq::v2::Endpoints* temp = endpoints_;
  endpoints_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Endpoints* Broker::_internal_mutable_endpoints() {
  
  if (endpoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Endpoints>(GetArenaForAllocation());
    endpoints_ = p;
  }
  return endpoints_;
}
inline ::apache::rocketmq::v2::Endpoints* Broker::mutable_endpoints() {
  ::apache::rocketmq::v2::Endpoints* _msg = _internal_mutable_endpoints();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Broker.endpoints)
  return _msg;
}
inline void Broker::set_allocated_endpoints(::apache::rocketmq::v2::Endpoints* endpoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endpoints_;
  }
  if (endpoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(endpoints);
    if (message_arena != submessage_arena) {
      endpoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoints, submessage_arena);
    }
    
  } else {
    
  }
  endpoints_ = endpoints;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Broker.endpoints)
}

// -------------------------------------------------------------------

// MessageQueue

// .apache.rocketmq.v2.Resource topic = 1 [json_name = "topic"];
inline bool MessageQueue::_internal_has_topic() const {
  return this != internal_default_instance() && topic_ != nullptr;
}
inline bool MessageQueue::has_topic() const {
  return _internal_has_topic();
}
inline void MessageQueue::clear_topic() {
  if (GetArenaForAllocation() == nullptr && topic_ != nullptr) {
    delete topic_;
  }
  topic_ = nullptr;
}
inline const ::apache::rocketmq::v2::Resource& MessageQueue::_internal_topic() const {
  const ::apache::rocketmq::v2::Resource* p = topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& MessageQueue::topic() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.MessageQueue.topic)
  return _internal_topic();
}
inline void MessageQueue::unsafe_arena_set_allocated_topic(
    ::apache::rocketmq::v2::Resource* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.MessageQueue.topic)
}
inline ::apache::rocketmq::v2::Resource* MessageQueue::release_topic() {
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* MessageQueue::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.MessageQueue.topic)
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* MessageQueue::_internal_mutable_topic() {
  
  if (topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    topic_ = p;
  }
  return topic_;
}
inline ::apache::rocketmq::v2::Resource* MessageQueue::mutable_topic() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.MessageQueue.topic)
  return _msg;
}
inline void MessageQueue::set_allocated_topic(::apache::rocketmq::v2::Resource* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete topic_;
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(topic);
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.MessageQueue.topic)
}

// int32 id = 2 [json_name = "id"];
inline void MessageQueue::clear_id() {
  id_ = 0;
}
inline int32_t MessageQueue::_internal_id() const {
  return id_;
}
inline int32_t MessageQueue::id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.MessageQueue.id)
  return _internal_id();
}
inline void MessageQueue::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void MessageQueue::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.MessageQueue.id)
}

// .apache.rocketmq.v2.Permission permission = 3 [json_name = "permission"];
inline void MessageQueue::clear_permission() {
  permission_ = 0;
}
inline ::apache::rocketmq::v2::Permission MessageQueue::_internal_permission() const {
  return static_cast< ::apache::rocketmq::v2::Permission >(permission_);
}
inline ::apache::rocketmq::v2::Permission MessageQueue::permission() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.MessageQueue.permission)
  return _internal_permission();
}
inline void MessageQueue::_internal_set_permission(::apache::rocketmq::v2::Permission value) {
  
  permission_ = value;
}
inline void MessageQueue::set_permission(::apache::rocketmq::v2::Permission value) {
  _internal_set_permission(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.MessageQueue.permission)
}

// .apache.rocketmq.v2.Broker broker = 4 [json_name = "broker"];
inline bool MessageQueue::_internal_has_broker() const {
  return this != internal_default_instance() && broker_ != nullptr;
}
inline bool MessageQueue::has_broker() const {
  return _internal_has_broker();
}
inline void MessageQueue::clear_broker() {
  if (GetArenaForAllocation() == nullptr && broker_ != nullptr) {
    delete broker_;
  }
  broker_ = nullptr;
}
inline const ::apache::rocketmq::v2::Broker& MessageQueue::_internal_broker() const {
  const ::apache::rocketmq::v2::Broker* p = broker_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Broker&>(
      ::apache::rocketmq::v2::_Broker_default_instance_);
}
inline const ::apache::rocketmq::v2::Broker& MessageQueue::broker() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.MessageQueue.broker)
  return _internal_broker();
}
inline void MessageQueue::unsafe_arena_set_allocated_broker(
    ::apache::rocketmq::v2::Broker* broker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(broker_);
  }
  broker_ = broker;
  if (broker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.MessageQueue.broker)
}
inline ::apache::rocketmq::v2::Broker* MessageQueue::release_broker() {
  
  ::apache::rocketmq::v2::Broker* temp = broker_;
  broker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Broker* MessageQueue::unsafe_arena_release_broker() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.MessageQueue.broker)
  
  ::apache::rocketmq::v2::Broker* temp = broker_;
  broker_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Broker* MessageQueue::_internal_mutable_broker() {
  
  if (broker_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Broker>(GetArenaForAllocation());
    broker_ = p;
  }
  return broker_;
}
inline ::apache::rocketmq::v2::Broker* MessageQueue::mutable_broker() {
  ::apache::rocketmq::v2::Broker* _msg = _internal_mutable_broker();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.MessageQueue.broker)
  return _msg;
}
inline void MessageQueue::set_allocated_broker(::apache::rocketmq::v2::Broker* broker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete broker_;
  }
  if (broker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(broker);
    if (message_arena != submessage_arena) {
      broker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, broker, submessage_arena);
    }
    
  } else {
    
  }
  broker_ = broker;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.MessageQueue.broker)
}

// repeated .apache.rocketmq.v2.MessageType accept_message_types = 5 [json_name = "acceptMessageTypes"];
inline int MessageQueue::_internal_accept_message_types_size() const {
  return accept_message_types_.size();
}
inline int MessageQueue::accept_message_types_size() const {
  return _internal_accept_message_types_size();
}
inline void MessageQueue::clear_accept_message_types() {
  accept_message_types_.Clear();
}
inline ::apache::rocketmq::v2::MessageType MessageQueue::_internal_accept_message_types(int index) const {
  return static_cast< ::apache::rocketmq::v2::MessageType >(accept_message_types_.Get(index));
}
inline ::apache::rocketmq::v2::MessageType MessageQueue::accept_message_types(int index) const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.MessageQueue.accept_message_types)
  return _internal_accept_message_types(index);
}
inline void MessageQueue::set_accept_message_types(int index, ::apache::rocketmq::v2::MessageType value) {
  accept_message_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.MessageQueue.accept_message_types)
}
inline void MessageQueue::_internal_add_accept_message_types(::apache::rocketmq::v2::MessageType value) {
  accept_message_types_.Add(value);
}
inline void MessageQueue::add_accept_message_types(::apache::rocketmq::v2::MessageType value) {
  _internal_add_accept_message_types(value);
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.MessageQueue.accept_message_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
MessageQueue::accept_message_types() const {
  // @@protoc_insertion_point(field_list:apache.rocketmq.v2.MessageQueue.accept_message_types)
  return accept_message_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MessageQueue::_internal_mutable_accept_message_types() {
  return &accept_message_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MessageQueue::mutable_accept_message_types() {
  // @@protoc_insertion_point(field_mutable_list:apache.rocketmq.v2.MessageQueue.accept_message_types)
  return _internal_mutable_accept_message_types();
}

// -------------------------------------------------------------------

// Digest

// .apache.rocketmq.v2.DigestType type = 1 [json_name = "type"];
inline void Digest::clear_type() {
  type_ = 0;
}
inline ::apache::rocketmq::v2::DigestType Digest::_internal_type() const {
  return static_cast< ::apache::rocketmq::v2::DigestType >(type_);
}
inline ::apache::rocketmq::v2::DigestType Digest::type() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Digest.type)
  return _internal_type();
}
inline void Digest::_internal_set_type(::apache::rocketmq::v2::DigestType value) {
  
  type_ = value;
}
inline void Digest::set_type(::apache::rocketmq::v2::DigestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Digest.type)
}

// string checksum = 2 [json_name = "checksum"];
inline void Digest::clear_checksum() {
  checksum_.ClearToEmpty();
}
inline const std::string& Digest::checksum() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Digest.checksum)
  return _internal_checksum();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Digest::set_checksum(ArgT0&& arg0, ArgT... args) {
 
 checksum_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Digest.checksum)
}
inline std::string* Digest::mutable_checksum() {
  std::string* _s = _internal_mutable_checksum();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Digest.checksum)
  return _s;
}
inline const std::string& Digest::_internal_checksum() const {
  return checksum_.Get();
}
inline void Digest::_internal_set_checksum(const std::string& value) {
  
  checksum_.Set(value, GetArenaForAllocation());
}
inline std::string* Digest::_internal_mutable_checksum() {
  
  return checksum_.Mutable(GetArenaForAllocation());
}
inline std::string* Digest::release_checksum() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Digest.checksum)
  return checksum_.Release();
}
inline void Digest::set_allocated_checksum(std::string* checksum) {
  if (checksum != nullptr) {
    
  } else {
    
  }
  checksum_.SetAllocated(checksum, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (checksum_.IsDefault()) {
    checksum_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Digest.checksum)
}

// -------------------------------------------------------------------

// SystemProperties

// optional string tag = 1 [json_name = "tag"];
inline bool SystemProperties::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SystemProperties::has_tag() const {
  return _internal_has_tag();
}
inline void SystemProperties::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SystemProperties::tag() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemProperties::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.tag)
}
inline std::string* SystemProperties::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.tag)
  return _s;
}
inline const std::string& SystemProperties::_internal_tag() const {
  return tag_.Get();
}
inline void SystemProperties::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemProperties::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemProperties::release_tag() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault()) {
    tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemProperties::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault()) {
    tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.tag)
}

// repeated string keys = 2 [json_name = "keys"];
inline int SystemProperties::_internal_keys_size() const {
  return keys_.size();
}
inline int SystemProperties::keys_size() const {
  return _internal_keys_size();
}
inline void SystemProperties::clear_keys() {
  keys_.Clear();
}
inline std::string* SystemProperties::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:apache.rocketmq.v2.SystemProperties.keys)
  return _s;
}
inline const std::string& SystemProperties::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& SystemProperties::keys(int index) const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.keys)
  return _internal_keys(index);
}
inline std::string* SystemProperties::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.keys)
  return keys_.Mutable(index);
}
inline void SystemProperties::set_keys(int index, const std::string& value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.keys)
}
inline void SystemProperties::set_keys(int index, std::string&& value) {
  keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.keys)
}
inline void SystemProperties::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apache.rocketmq.v2.SystemProperties.keys)
}
inline void SystemProperties::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apache.rocketmq.v2.SystemProperties.keys)
}
inline std::string* SystemProperties::_internal_add_keys() {
  return keys_.Add();
}
inline void SystemProperties::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.SystemProperties.keys)
}
inline void SystemProperties::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.SystemProperties.keys)
}
inline void SystemProperties::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apache.rocketmq.v2.SystemProperties.keys)
}
inline void SystemProperties::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apache.rocketmq.v2.SystemProperties.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SystemProperties::keys() const {
  // @@protoc_insertion_point(field_list:apache.rocketmq.v2.SystemProperties.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SystemProperties::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:apache.rocketmq.v2.SystemProperties.keys)
  return &keys_;
}

// string message_id = 3 [json_name = "messageId"];
inline void SystemProperties::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& SystemProperties::message_id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemProperties::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.message_id)
}
inline std::string* SystemProperties::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.message_id)
  return _s;
}
inline const std::string& SystemProperties::_internal_message_id() const {
  return message_id_.Get();
}
inline void SystemProperties::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemProperties::_internal_mutable_message_id() {
  
  return message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemProperties::release_message_id() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.message_id)
  return message_id_.Release();
}
inline void SystemProperties::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_id_.IsDefault()) {
    message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.message_id)
}

// .apache.rocketmq.v2.Digest body_digest = 4 [json_name = "bodyDigest"];
inline bool SystemProperties::_internal_has_body_digest() const {
  return this != internal_default_instance() && body_digest_ != nullptr;
}
inline bool SystemProperties::has_body_digest() const {
  return _internal_has_body_digest();
}
inline void SystemProperties::clear_body_digest() {
  if (GetArenaForAllocation() == nullptr && body_digest_ != nullptr) {
    delete body_digest_;
  }
  body_digest_ = nullptr;
}
inline const ::apache::rocketmq::v2::Digest& SystemProperties::_internal_body_digest() const {
  const ::apache::rocketmq::v2::Digest* p = body_digest_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Digest&>(
      ::apache::rocketmq::v2::_Digest_default_instance_);
}
inline const ::apache::rocketmq::v2::Digest& SystemProperties::body_digest() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.body_digest)
  return _internal_body_digest();
}
inline void SystemProperties::unsafe_arena_set_allocated_body_digest(
    ::apache::rocketmq::v2::Digest* body_digest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_digest_);
  }
  body_digest_ = body_digest;
  if (body_digest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.SystemProperties.body_digest)
}
inline ::apache::rocketmq::v2::Digest* SystemProperties::release_body_digest() {
  
  ::apache::rocketmq::v2::Digest* temp = body_digest_;
  body_digest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Digest* SystemProperties::unsafe_arena_release_body_digest() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.body_digest)
  
  ::apache::rocketmq::v2::Digest* temp = body_digest_;
  body_digest_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Digest* SystemProperties::_internal_mutable_body_digest() {
  
  if (body_digest_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Digest>(GetArenaForAllocation());
    body_digest_ = p;
  }
  return body_digest_;
}
inline ::apache::rocketmq::v2::Digest* SystemProperties::mutable_body_digest() {
  ::apache::rocketmq::v2::Digest* _msg = _internal_mutable_body_digest();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.body_digest)
  return _msg;
}
inline void SystemProperties::set_allocated_body_digest(::apache::rocketmq::v2::Digest* body_digest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete body_digest_;
  }
  if (body_digest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body_digest);
    if (message_arena != submessage_arena) {
      body_digest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_digest, submessage_arena);
    }
    
  } else {
    
  }
  body_digest_ = body_digest;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.body_digest)
}

// .apache.rocketmq.v2.Encoding body_encoding = 5 [json_name = "bodyEncoding"];
inline void SystemProperties::clear_body_encoding() {
  body_encoding_ = 0;
}
inline ::apache::rocketmq::v2::Encoding SystemProperties::_internal_body_encoding() const {
  return static_cast< ::apache::rocketmq::v2::Encoding >(body_encoding_);
}
inline ::apache::rocketmq::v2::Encoding SystemProperties::body_encoding() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.body_encoding)
  return _internal_body_encoding();
}
inline void SystemProperties::_internal_set_body_encoding(::apache::rocketmq::v2::Encoding value) {
  
  body_encoding_ = value;
}
inline void SystemProperties::set_body_encoding(::apache::rocketmq::v2::Encoding value) {
  _internal_set_body_encoding(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.body_encoding)
}

// .apache.rocketmq.v2.MessageType message_type = 6 [json_name = "messageType"];
inline void SystemProperties::clear_message_type() {
  message_type_ = 0;
}
inline ::apache::rocketmq::v2::MessageType SystemProperties::_internal_message_type() const {
  return static_cast< ::apache::rocketmq::v2::MessageType >(message_type_);
}
inline ::apache::rocketmq::v2::MessageType SystemProperties::message_type() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.message_type)
  return _internal_message_type();
}
inline void SystemProperties::_internal_set_message_type(::apache::rocketmq::v2::MessageType value) {
  
  message_type_ = value;
}
inline void SystemProperties::set_message_type(::apache::rocketmq::v2::MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.message_type)
}

// .google.protobuf.Timestamp born_timestamp = 7 [json_name = "bornTimestamp"];
inline bool SystemProperties::_internal_has_born_timestamp() const {
  return this != internal_default_instance() && born_timestamp_ != nullptr;
}
inline bool SystemProperties::has_born_timestamp() const {
  return _internal_has_born_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SystemProperties::_internal_born_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = born_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SystemProperties::born_timestamp() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.born_timestamp)
  return _internal_born_timestamp();
}
inline void SystemProperties::unsafe_arena_set_allocated_born_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* born_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(born_timestamp_);
  }
  born_timestamp_ = born_timestamp;
  if (born_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.SystemProperties.born_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemProperties::release_born_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = born_timestamp_;
  born_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemProperties::unsafe_arena_release_born_timestamp() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.born_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = born_timestamp_;
  born_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemProperties::_internal_mutable_born_timestamp() {
  
  if (born_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    born_timestamp_ = p;
  }
  return born_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemProperties::mutable_born_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_born_timestamp();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.born_timestamp)
  return _msg;
}
inline void SystemProperties::set_allocated_born_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* born_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(born_timestamp_);
  }
  if (born_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(born_timestamp));
    if (message_arena != submessage_arena) {
      born_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, born_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  born_timestamp_ = born_timestamp;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.born_timestamp)
}

// string born_host = 8 [json_name = "bornHost"];
inline void SystemProperties::clear_born_host() {
  born_host_.ClearToEmpty();
}
inline const std::string& SystemProperties::born_host() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.born_host)
  return _internal_born_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemProperties::set_born_host(ArgT0&& arg0, ArgT... args) {
 
 born_host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.born_host)
}
inline std::string* SystemProperties::mutable_born_host() {
  std::string* _s = _internal_mutable_born_host();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.born_host)
  return _s;
}
inline const std::string& SystemProperties::_internal_born_host() const {
  return born_host_.Get();
}
inline void SystemProperties::_internal_set_born_host(const std::string& value) {
  
  born_host_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemProperties::_internal_mutable_born_host() {
  
  return born_host_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemProperties::release_born_host() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.born_host)
  return born_host_.Release();
}
inline void SystemProperties::set_allocated_born_host(std::string* born_host) {
  if (born_host != nullptr) {
    
  } else {
    
  }
  born_host_.SetAllocated(born_host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (born_host_.IsDefault()) {
    born_host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.born_host)
}

// optional .google.protobuf.Timestamp store_timestamp = 9 [json_name = "storeTimestamp"];
inline bool SystemProperties::_internal_has_store_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || store_timestamp_ != nullptr);
  return value;
}
inline bool SystemProperties::has_store_timestamp() const {
  return _internal_has_store_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SystemProperties::_internal_store_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = store_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SystemProperties::store_timestamp() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.store_timestamp)
  return _internal_store_timestamp();
}
inline void SystemProperties::unsafe_arena_set_allocated_store_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* store_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_timestamp_);
  }
  store_timestamp_ = store_timestamp;
  if (store_timestamp) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.SystemProperties.store_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemProperties::release_store_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = store_timestamp_;
  store_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemProperties::unsafe_arena_release_store_timestamp() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.store_timestamp)
  _has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = store_timestamp_;
  store_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemProperties::_internal_mutable_store_timestamp() {
  _has_bits_[0] |= 0x00000010u;
  if (store_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    store_timestamp_ = p;
  }
  return store_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemProperties::mutable_store_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_store_timestamp();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.store_timestamp)
  return _msg;
}
inline void SystemProperties::set_allocated_store_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* store_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_timestamp_);
  }
  if (store_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_timestamp));
    if (message_arena != submessage_arena) {
      store_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, store_timestamp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  store_timestamp_ = store_timestamp;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.store_timestamp)
}

// string store_host = 10 [json_name = "storeHost"];
inline void SystemProperties::clear_store_host() {
  store_host_.ClearToEmpty();
}
inline const std::string& SystemProperties::store_host() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.store_host)
  return _internal_store_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemProperties::set_store_host(ArgT0&& arg0, ArgT... args) {
 
 store_host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.store_host)
}
inline std::string* SystemProperties::mutable_store_host() {
  std::string* _s = _internal_mutable_store_host();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.store_host)
  return _s;
}
inline const std::string& SystemProperties::_internal_store_host() const {
  return store_host_.Get();
}
inline void SystemProperties::_internal_set_store_host(const std::string& value) {
  
  store_host_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemProperties::_internal_mutable_store_host() {
  
  return store_host_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemProperties::release_store_host() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.store_host)
  return store_host_.Release();
}
inline void SystemProperties::set_allocated_store_host(std::string* store_host) {
  if (store_host != nullptr) {
    
  } else {
    
  }
  store_host_.SetAllocated(store_host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_host_.IsDefault()) {
    store_host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.store_host)
}

// optional .google.protobuf.Timestamp delivery_timestamp = 11 [json_name = "deliveryTimestamp"];
inline bool SystemProperties::_internal_has_delivery_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || delivery_timestamp_ != nullptr);
  return value;
}
inline bool SystemProperties::has_delivery_timestamp() const {
  return _internal_has_delivery_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SystemProperties::_internal_delivery_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = delivery_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SystemProperties::delivery_timestamp() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.delivery_timestamp)
  return _internal_delivery_timestamp();
}
inline void SystemProperties::unsafe_arena_set_allocated_delivery_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delivery_timestamp_);
  }
  delivery_timestamp_ = delivery_timestamp;
  if (delivery_timestamp) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.SystemProperties.delivery_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemProperties::release_delivery_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = delivery_timestamp_;
  delivery_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemProperties::unsafe_arena_release_delivery_timestamp() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.delivery_timestamp)
  _has_bits_[0] &= ~0x00000020u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = delivery_timestamp_;
  delivery_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemProperties::_internal_mutable_delivery_timestamp() {
  _has_bits_[0] |= 0x00000020u;
  if (delivery_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    delivery_timestamp_ = p;
  }
  return delivery_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemProperties::mutable_delivery_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_delivery_timestamp();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.delivery_timestamp)
  return _msg;
}
inline void SystemProperties::set_allocated_delivery_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(delivery_timestamp_);
  }
  if (delivery_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delivery_timestamp));
    if (message_arena != submessage_arena) {
      delivery_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delivery_timestamp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  delivery_timestamp_ = delivery_timestamp;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.delivery_timestamp)
}

// optional string receipt_handle = 12 [json_name = "receiptHandle"];
inline bool SystemProperties::_internal_has_receipt_handle() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SystemProperties::has_receipt_handle() const {
  return _internal_has_receipt_handle();
}
inline void SystemProperties::clear_receipt_handle() {
  receipt_handle_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SystemProperties::receipt_handle() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.receipt_handle)
  return _internal_receipt_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemProperties::set_receipt_handle(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 receipt_handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.receipt_handle)
}
inline std::string* SystemProperties::mutable_receipt_handle() {
  std::string* _s = _internal_mutable_receipt_handle();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.receipt_handle)
  return _s;
}
inline const std::string& SystemProperties::_internal_receipt_handle() const {
  return receipt_handle_.Get();
}
inline void SystemProperties::_internal_set_receipt_handle(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  receipt_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemProperties::_internal_mutable_receipt_handle() {
  _has_bits_[0] |= 0x00000002u;
  return receipt_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemProperties::release_receipt_handle() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.receipt_handle)
  if (!_internal_has_receipt_handle()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = receipt_handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receipt_handle_.IsDefault()) {
    receipt_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemProperties::set_allocated_receipt_handle(std::string* receipt_handle) {
  if (receipt_handle != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  receipt_handle_.SetAllocated(receipt_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receipt_handle_.IsDefault()) {
    receipt_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.receipt_handle)
}

// int32 queue_id = 13 [json_name = "queueId"];
inline void SystemProperties::clear_queue_id() {
  queue_id_ = 0;
}
inline int32_t SystemProperties::_internal_queue_id() const {
  return queue_id_;
}
inline int32_t SystemProperties::queue_id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.queue_id)
  return _internal_queue_id();
}
inline void SystemProperties::_internal_set_queue_id(int32_t value) {
  
  queue_id_ = value;
}
inline void SystemProperties::set_queue_id(int32_t value) {
  _internal_set_queue_id(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.queue_id)
}

// optional int64 queue_offset = 14 [json_name = "queueOffset"];
inline bool SystemProperties::_internal_has_queue_offset() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SystemProperties::has_queue_offset() const {
  return _internal_has_queue_offset();
}
inline void SystemProperties::clear_queue_offset() {
  queue_offset_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline int64_t SystemProperties::_internal_queue_offset() const {
  return queue_offset_;
}
inline int64_t SystemProperties::queue_offset() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.queue_offset)
  return _internal_queue_offset();
}
inline void SystemProperties::_internal_set_queue_offset(int64_t value) {
  _has_bits_[0] |= 0x00000100u;
  queue_offset_ = value;
}
inline void SystemProperties::set_queue_offset(int64_t value) {
  _internal_set_queue_offset(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.queue_offset)
}

// optional .google.protobuf.Duration invisible_duration = 15 [json_name = "invisibleDuration"];
inline bool SystemProperties::_internal_has_invisible_duration() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || invisible_duration_ != nullptr);
  return value;
}
inline bool SystemProperties::has_invisible_duration() const {
  return _internal_has_invisible_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& SystemProperties::_internal_invisible_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = invisible_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& SystemProperties::invisible_duration() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.invisible_duration)
  return _internal_invisible_duration();
}
inline void SystemProperties::unsafe_arena_set_allocated_invisible_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invisible_duration_);
  }
  invisible_duration_ = invisible_duration;
  if (invisible_duration) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.SystemProperties.invisible_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SystemProperties::release_invisible_duration() {
  _has_bits_[0] &= ~0x00000040u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = invisible_duration_;
  invisible_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SystemProperties::unsafe_arena_release_invisible_duration() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.invisible_duration)
  _has_bits_[0] &= ~0x00000040u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = invisible_duration_;
  invisible_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SystemProperties::_internal_mutable_invisible_duration() {
  _has_bits_[0] |= 0x00000040u;
  if (invisible_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    invisible_duration_ = p;
  }
  return invisible_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SystemProperties::mutable_invisible_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_invisible_duration();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.invisible_duration)
  return _msg;
}
inline void SystemProperties::set_allocated_invisible_duration(::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(invisible_duration_);
  }
  if (invisible_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invisible_duration));
    if (message_arena != submessage_arena) {
      invisible_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invisible_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  invisible_duration_ = invisible_duration;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.invisible_duration)
}

// optional int32 delivery_attempt = 16 [json_name = "deliveryAttempt"];
inline bool SystemProperties::_internal_has_delivery_attempt() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SystemProperties::has_delivery_attempt() const {
  return _internal_has_delivery_attempt();
}
inline void SystemProperties::clear_delivery_attempt() {
  delivery_attempt_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t SystemProperties::_internal_delivery_attempt() const {
  return delivery_attempt_;
}
inline int32_t SystemProperties::delivery_attempt() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.delivery_attempt)
  return _internal_delivery_attempt();
}
inline void SystemProperties::_internal_set_delivery_attempt(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  delivery_attempt_ = value;
}
inline void SystemProperties::set_delivery_attempt(int32_t value) {
  _internal_set_delivery_attempt(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.delivery_attempt)
}

// optional string message_group = 17 [json_name = "messageGroup"];
inline bool SystemProperties::_internal_has_message_group() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SystemProperties::has_message_group() const {
  return _internal_has_message_group();
}
inline void SystemProperties::clear_message_group() {
  message_group_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SystemProperties::message_group() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.message_group)
  return _internal_message_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemProperties::set_message_group(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 message_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.message_group)
}
inline std::string* SystemProperties::mutable_message_group() {
  std::string* _s = _internal_mutable_message_group();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.message_group)
  return _s;
}
inline const std::string& SystemProperties::_internal_message_group() const {
  return message_group_.Get();
}
inline void SystemProperties::_internal_set_message_group(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  message_group_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemProperties::_internal_mutable_message_group() {
  _has_bits_[0] |= 0x00000004u;
  return message_group_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemProperties::release_message_group() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.message_group)
  if (!_internal_has_message_group()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = message_group_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_group_.IsDefault()) {
    message_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemProperties::set_allocated_message_group(std::string* message_group) {
  if (message_group != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  message_group_.SetAllocated(message_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_group_.IsDefault()) {
    message_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.message_group)
}

// optional string trace_context = 18 [json_name = "traceContext"];
inline bool SystemProperties::_internal_has_trace_context() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SystemProperties::has_trace_context() const {
  return _internal_has_trace_context();
}
inline void SystemProperties::clear_trace_context() {
  trace_context_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SystemProperties::trace_context() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.trace_context)
  return _internal_trace_context();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemProperties::set_trace_context(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 trace_context_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SystemProperties.trace_context)
}
inline std::string* SystemProperties::mutable_trace_context() {
  std::string* _s = _internal_mutable_trace_context();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.trace_context)
  return _s;
}
inline const std::string& SystemProperties::_internal_trace_context() const {
  return trace_context_.Get();
}
inline void SystemProperties::_internal_set_trace_context(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  trace_context_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemProperties::_internal_mutable_trace_context() {
  _has_bits_[0] |= 0x00000008u;
  return trace_context_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemProperties::release_trace_context() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.trace_context)
  if (!_internal_has_trace_context()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = trace_context_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trace_context_.IsDefault()) {
    trace_context_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemProperties::set_allocated_trace_context(std::string* trace_context) {
  if (trace_context != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  trace_context_.SetAllocated(trace_context, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trace_context_.IsDefault()) {
    trace_context_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.trace_context)
}

// optional .google.protobuf.Duration orphaned_transaction_recovery_duration = 19 [json_name = "orphanedTransactionRecoveryDuration"];
inline bool SystemProperties::_internal_has_orphaned_transaction_recovery_duration() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || orphaned_transaction_recovery_duration_ != nullptr);
  return value;
}
inline bool SystemProperties::has_orphaned_transaction_recovery_duration() const {
  return _internal_has_orphaned_transaction_recovery_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& SystemProperties::_internal_orphaned_transaction_recovery_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = orphaned_transaction_recovery_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& SystemProperties::orphaned_transaction_recovery_duration() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SystemProperties.orphaned_transaction_recovery_duration)
  return _internal_orphaned_transaction_recovery_duration();
}
inline void SystemProperties::unsafe_arena_set_allocated_orphaned_transaction_recovery_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* orphaned_transaction_recovery_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orphaned_transaction_recovery_duration_);
  }
  orphaned_transaction_recovery_duration_ = orphaned_transaction_recovery_duration;
  if (orphaned_transaction_recovery_duration) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.SystemProperties.orphaned_transaction_recovery_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SystemProperties::release_orphaned_transaction_recovery_duration() {
  _has_bits_[0] &= ~0x00000080u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = orphaned_transaction_recovery_duration_;
  orphaned_transaction_recovery_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SystemProperties::unsafe_arena_release_orphaned_transaction_recovery_duration() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SystemProperties.orphaned_transaction_recovery_duration)
  _has_bits_[0] &= ~0x00000080u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = orphaned_transaction_recovery_duration_;
  orphaned_transaction_recovery_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SystemProperties::_internal_mutable_orphaned_transaction_recovery_duration() {
  _has_bits_[0] |= 0x00000080u;
  if (orphaned_transaction_recovery_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    orphaned_transaction_recovery_duration_ = p;
  }
  return orphaned_transaction_recovery_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SystemProperties::mutable_orphaned_transaction_recovery_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_orphaned_transaction_recovery_duration();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SystemProperties.orphaned_transaction_recovery_duration)
  return _msg;
}
inline void SystemProperties::set_allocated_orphaned_transaction_recovery_duration(::PROTOBUF_NAMESPACE_ID::Duration* orphaned_transaction_recovery_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(orphaned_transaction_recovery_duration_);
  }
  if (orphaned_transaction_recovery_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orphaned_transaction_recovery_duration));
    if (message_arena != submessage_arena) {
      orphaned_transaction_recovery_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orphaned_transaction_recovery_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  orphaned_transaction_recovery_duration_ = orphaned_transaction_recovery_duration;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SystemProperties.orphaned_transaction_recovery_duration)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Message

// .apache.rocketmq.v2.Resource topic = 1 [json_name = "topic"];
inline bool Message::_internal_has_topic() const {
  return this != internal_default_instance() && topic_ != nullptr;
}
inline bool Message::has_topic() const {
  return _internal_has_topic();
}
inline void Message::clear_topic() {
  if (GetArenaForAllocation() == nullptr && topic_ != nullptr) {
    delete topic_;
  }
  topic_ = nullptr;
}
inline const ::apache::rocketmq::v2::Resource& Message::_internal_topic() const {
  const ::apache::rocketmq::v2::Resource* p = topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& Message::topic() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Message.topic)
  return _internal_topic();
}
inline void Message::unsafe_arena_set_allocated_topic(
    ::apache::rocketmq::v2::Resource* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Message.topic)
}
inline ::apache::rocketmq::v2::Resource* Message::release_topic() {
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* Message::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Message.topic)
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* Message::_internal_mutable_topic() {
  
  if (topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    topic_ = p;
  }
  return topic_;
}
inline ::apache::rocketmq::v2::Resource* Message::mutable_topic() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Message.topic)
  return _msg;
}
inline void Message::set_allocated_topic(::apache::rocketmq::v2::Resource* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete topic_;
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(topic);
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Message.topic)
}

// map<string, string> user_properties = 2 [json_name = "userProperties"];
inline int Message::_internal_user_properties_size() const {
  return user_properties_.size();
}
inline int Message::user_properties_size() const {
  return _internal_user_properties_size();
}
inline void Message::clear_user_properties() {
  user_properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Message::_internal_user_properties() const {
  return user_properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Message::user_properties() const {
  // @@protoc_insertion_point(field_map:apache.rocketmq.v2.Message.user_properties)
  return _internal_user_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Message::_internal_mutable_user_properties() {
  return user_properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Message::mutable_user_properties() {
  // @@protoc_insertion_point(field_mutable_map:apache.rocketmq.v2.Message.user_properties)
  return _internal_mutable_user_properties();
}

// .apache.rocketmq.v2.SystemProperties system_properties = 3 [json_name = "systemProperties"];
inline bool Message::_internal_has_system_properties() const {
  return this != internal_default_instance() && system_properties_ != nullptr;
}
inline bool Message::has_system_properties() const {
  return _internal_has_system_properties();
}
inline void Message::clear_system_properties() {
  if (GetArenaForAllocation() == nullptr && system_properties_ != nullptr) {
    delete system_properties_;
  }
  system_properties_ = nullptr;
}
inline const ::apache::rocketmq::v2::SystemProperties& Message::_internal_system_properties() const {
  const ::apache::rocketmq::v2::SystemProperties* p = system_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::SystemProperties&>(
      ::apache::rocketmq::v2::_SystemProperties_default_instance_);
}
inline const ::apache::rocketmq::v2::SystemProperties& Message::system_properties() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Message.system_properties)
  return _internal_system_properties();
}
inline void Message::unsafe_arena_set_allocated_system_properties(
    ::apache::rocketmq::v2::SystemProperties* system_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_properties_);
  }
  system_properties_ = system_properties;
  if (system_properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Message.system_properties)
}
inline ::apache::rocketmq::v2::SystemProperties* Message::release_system_properties() {
  
  ::apache::rocketmq::v2::SystemProperties* temp = system_properties_;
  system_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::SystemProperties* Message::unsafe_arena_release_system_properties() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Message.system_properties)
  
  ::apache::rocketmq::v2::SystemProperties* temp = system_properties_;
  system_properties_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::SystemProperties* Message::_internal_mutable_system_properties() {
  
  if (system_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::SystemProperties>(GetArenaForAllocation());
    system_properties_ = p;
  }
  return system_properties_;
}
inline ::apache::rocketmq::v2::SystemProperties* Message::mutable_system_properties() {
  ::apache::rocketmq::v2::SystemProperties* _msg = _internal_mutable_system_properties();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Message.system_properties)
  return _msg;
}
inline void Message::set_allocated_system_properties(::apache::rocketmq::v2::SystemProperties* system_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete system_properties_;
  }
  if (system_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(system_properties);
    if (message_arena != submessage_arena) {
      system_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_properties, submessage_arena);
    }
    
  } else {
    
  }
  system_properties_ = system_properties;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Message.system_properties)
}

// bytes body = 4 [json_name = "body"];
inline void Message::clear_body() {
  body_.ClearToEmpty();
}
inline const std::string& Message::body() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Message.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_body(ArgT0&& arg0, ArgT... args) {
 
 body_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Message.body)
}
inline std::string* Message::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Message.body)
  return _s;
}
inline const std::string& Message::_internal_body() const {
  return body_.Get();
}
inline void Message::_internal_set_body(const std::string& value) {
  
  body_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_body() {
  
  return body_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_body() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Message.body)
  return body_.Release();
}
inline void Message::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault()) {
    body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Message.body)
}

// -------------------------------------------------------------------

// Assignment

// .apache.rocketmq.v2.MessageQueue message_queue = 1 [json_name = "messageQueue"];
inline bool Assignment::_internal_has_message_queue() const {
  return this != internal_default_instance() && message_queue_ != nullptr;
}
inline bool Assignment::has_message_queue() const {
  return _internal_has_message_queue();
}
inline void Assignment::clear_message_queue() {
  if (GetArenaForAllocation() == nullptr && message_queue_ != nullptr) {
    delete message_queue_;
  }
  message_queue_ = nullptr;
}
inline const ::apache::rocketmq::v2::MessageQueue& Assignment::_internal_message_queue() const {
  const ::apache::rocketmq::v2::MessageQueue* p = message_queue_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::MessageQueue&>(
      ::apache::rocketmq::v2::_MessageQueue_default_instance_);
}
inline const ::apache::rocketmq::v2::MessageQueue& Assignment::message_queue() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Assignment.message_queue)
  return _internal_message_queue();
}
inline void Assignment::unsafe_arena_set_allocated_message_queue(
    ::apache::rocketmq::v2::MessageQueue* message_queue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_queue_);
  }
  message_queue_ = message_queue;
  if (message_queue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Assignment.message_queue)
}
inline ::apache::rocketmq::v2::MessageQueue* Assignment::release_message_queue() {
  
  ::apache::rocketmq::v2::MessageQueue* temp = message_queue_;
  message_queue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::MessageQueue* Assignment::unsafe_arena_release_message_queue() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Assignment.message_queue)
  
  ::apache::rocketmq::v2::MessageQueue* temp = message_queue_;
  message_queue_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::MessageQueue* Assignment::_internal_mutable_message_queue() {
  
  if (message_queue_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::MessageQueue>(GetArenaForAllocation());
    message_queue_ = p;
  }
  return message_queue_;
}
inline ::apache::rocketmq::v2::MessageQueue* Assignment::mutable_message_queue() {
  ::apache::rocketmq::v2::MessageQueue* _msg = _internal_mutable_message_queue();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Assignment.message_queue)
  return _msg;
}
inline void Assignment::set_allocated_message_queue(::apache::rocketmq::v2::MessageQueue* message_queue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete message_queue_;
  }
  if (message_queue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message_queue);
    if (message_arena != submessage_arena) {
      message_queue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message_queue, submessage_arena);
    }
    
  } else {
    
  }
  message_queue_ = message_queue;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Assignment.message_queue)
}

// -------------------------------------------------------------------

// Status

// .apache.rocketmq.v2.Code code = 1 [json_name = "code"];
inline void Status::clear_code() {
  code_ = 0;
}
inline ::apache::rocketmq::v2::Code Status::_internal_code() const {
  return static_cast< ::apache::rocketmq::v2::Code >(code_);
}
inline ::apache::rocketmq::v2::Code Status::code() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Status.code)
  return _internal_code();
}
inline void Status::_internal_set_code(::apache::rocketmq::v2::Code value) {
  
  code_ = value;
}
inline void Status::set_code(::apache::rocketmq::v2::Code value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Status.code)
}

// string message = 2 [json_name = "message"];
inline void Status::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& Status::message() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Status.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Status::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Status.message)
}
inline std::string* Status::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Status.message)
  return _s;
}
inline const std::string& Status::_internal_message() const {
  return message_.Get();
}
inline void Status::_internal_set_message(const std::string& value) {
  
  message_.Set(value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_message() {
  
  return message_.Mutable(GetArenaForAllocation());
}
inline std::string* Status::release_message() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Status.message)
  return message_.Release();
}
inline void Status::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault()) {
    message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Status.message)
}

// -------------------------------------------------------------------

// UA

// .apache.rocketmq.v2.Language language = 1 [json_name = "language"];
inline void UA::clear_language() {
  language_ = 0;
}
inline ::apache::rocketmq::v2::Language UA::_internal_language() const {
  return static_cast< ::apache::rocketmq::v2::Language >(language_);
}
inline ::apache::rocketmq::v2::Language UA::language() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.UA.language)
  return _internal_language();
}
inline void UA::_internal_set_language(::apache::rocketmq::v2::Language value) {
  
  language_ = value;
}
inline void UA::set_language(::apache::rocketmq::v2::Language value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.UA.language)
}

// string version = 2 [json_name = "version"];
inline void UA::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& UA::version() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.UA.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UA::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.UA.version)
}
inline std::string* UA::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.UA.version)
  return _s;
}
inline const std::string& UA::_internal_version() const {
  return version_.Get();
}
inline void UA::_internal_set_version(const std::string& value) {
  
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* UA::_internal_mutable_version() {
  
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* UA::release_version() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.UA.version)
  return version_.Release();
}
inline void UA::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.UA.version)
}

// string platform = 3 [json_name = "platform"];
inline void UA::clear_platform() {
  platform_.ClearToEmpty();
}
inline const std::string& UA::platform() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.UA.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UA::set_platform(ArgT0&& arg0, ArgT... args) {
 
 platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.UA.platform)
}
inline std::string* UA::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.UA.platform)
  return _s;
}
inline const std::string& UA::_internal_platform() const {
  return platform_.Get();
}
inline void UA::_internal_set_platform(const std::string& value) {
  
  platform_.Set(value, GetArenaForAllocation());
}
inline std::string* UA::_internal_mutable_platform() {
  
  return platform_.Mutable(GetArenaForAllocation());
}
inline std::string* UA::release_platform() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.UA.platform)
  return platform_.Release();
}
inline void UA::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault()) {
    platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.UA.platform)
}

// string hostname = 4 [json_name = "hostname"];
inline void UA::clear_hostname() {
  hostname_.ClearToEmpty();
}
inline const std::string& UA::hostname() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.UA.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UA::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.UA.hostname)
}
inline std::string* UA::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.UA.hostname)
  return _s;
}
inline const std::string& UA::_internal_hostname() const {
  return hostname_.Get();
}
inline void UA::_internal_set_hostname(const std::string& value) {
  
  hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* UA::_internal_mutable_hostname() {
  
  return hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* UA::release_hostname() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.UA.hostname)
  return hostname_.Release();
}
inline void UA::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hostname_.IsDefault()) {
    hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.UA.hostname)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace rocketmq
}  // namespace apache

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apache::rocketmq::v2::TransactionResolution> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apache::rocketmq::v2::TransactionResolution>() {
  return ::apache::rocketmq::v2::TransactionResolution_descriptor();
}
template <> struct is_proto_enum< ::apache::rocketmq::v2::TransactionSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apache::rocketmq::v2::TransactionSource>() {
  return ::apache::rocketmq::v2::TransactionSource_descriptor();
}
template <> struct is_proto_enum< ::apache::rocketmq::v2::Permission> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apache::rocketmq::v2::Permission>() {
  return ::apache::rocketmq::v2::Permission_descriptor();
}
template <> struct is_proto_enum< ::apache::rocketmq::v2::FilterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apache::rocketmq::v2::FilterType>() {
  return ::apache::rocketmq::v2::FilterType_descriptor();
}
template <> struct is_proto_enum< ::apache::rocketmq::v2::AddressScheme> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apache::rocketmq::v2::AddressScheme>() {
  return ::apache::rocketmq::v2::AddressScheme_descriptor();
}
template <> struct is_proto_enum< ::apache::rocketmq::v2::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apache::rocketmq::v2::MessageType>() {
  return ::apache::rocketmq::v2::MessageType_descriptor();
}
template <> struct is_proto_enum< ::apache::rocketmq::v2::DigestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apache::rocketmq::v2::DigestType>() {
  return ::apache::rocketmq::v2::DigestType_descriptor();
}
template <> struct is_proto_enum< ::apache::rocketmq::v2::ClientType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apache::rocketmq::v2::ClientType>() {
  return ::apache::rocketmq::v2::ClientType_descriptor();
}
template <> struct is_proto_enum< ::apache::rocketmq::v2::Encoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apache::rocketmq::v2::Encoding>() {
  return ::apache::rocketmq::v2::Encoding_descriptor();
}
template <> struct is_proto_enum< ::apache::rocketmq::v2::Code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apache::rocketmq::v2::Code>() {
  return ::apache::rocketmq::v2::Code_descriptor();
}
template <> struct is_proto_enum< ::apache::rocketmq::v2::Language> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apache::rocketmq::v2::Language>() {
  return ::apache::rocketmq::v2::Language_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_apache_2frocketmq_2fv2_2fdefinition_2eproto
