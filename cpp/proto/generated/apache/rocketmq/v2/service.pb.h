// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: apache/rocketmq/v2/service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_apache_2frocketmq_2fv2_2fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_apache_2frocketmq_2fv2_2fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "apache/rocketmq/v2/definition.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_apache_2frocketmq_2fv2_2fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_apache_2frocketmq_2fv2_2fservice_2eproto;
namespace apache {
namespace rocketmq {
namespace v2 {
class AckMessageEntry;
struct AckMessageEntryDefaultTypeInternal;
extern AckMessageEntryDefaultTypeInternal _AckMessageEntry_default_instance_;
class AckMessageRequest;
struct AckMessageRequestDefaultTypeInternal;
extern AckMessageRequestDefaultTypeInternal _AckMessageRequest_default_instance_;
class AckMessageResponse;
struct AckMessageResponseDefaultTypeInternal;
extern AckMessageResponseDefaultTypeInternal _AckMessageResponse_default_instance_;
class AckMessageResultEntry;
struct AckMessageResultEntryDefaultTypeInternal;
extern AckMessageResultEntryDefaultTypeInternal _AckMessageResultEntry_default_instance_;
class ChangeInvisibleDurationRequest;
struct ChangeInvisibleDurationRequestDefaultTypeInternal;
extern ChangeInvisibleDurationRequestDefaultTypeInternal _ChangeInvisibleDurationRequest_default_instance_;
class ChangeInvisibleDurationResponse;
struct ChangeInvisibleDurationResponseDefaultTypeInternal;
extern ChangeInvisibleDurationResponseDefaultTypeInternal _ChangeInvisibleDurationResponse_default_instance_;
class EndTransactionRequest;
struct EndTransactionRequestDefaultTypeInternal;
extern EndTransactionRequestDefaultTypeInternal _EndTransactionRequest_default_instance_;
class EndTransactionResponse;
struct EndTransactionResponseDefaultTypeInternal;
extern EndTransactionResponseDefaultTypeInternal _EndTransactionResponse_default_instance_;
class ForwardMessageToDeadLetterQueueRequest;
struct ForwardMessageToDeadLetterQueueRequestDefaultTypeInternal;
extern ForwardMessageToDeadLetterQueueRequestDefaultTypeInternal _ForwardMessageToDeadLetterQueueRequest_default_instance_;
class ForwardMessageToDeadLetterQueueResponse;
struct ForwardMessageToDeadLetterQueueResponseDefaultTypeInternal;
extern ForwardMessageToDeadLetterQueueResponseDefaultTypeInternal _ForwardMessageToDeadLetterQueueResponse_default_instance_;
class HeartbeatRequest;
struct HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
struct HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class Metric;
struct MetricDefaultTypeInternal;
extern MetricDefaultTypeInternal _Metric_default_instance_;
class NotifyClientTerminationRequest;
struct NotifyClientTerminationRequestDefaultTypeInternal;
extern NotifyClientTerminationRequestDefaultTypeInternal _NotifyClientTerminationRequest_default_instance_;
class NotifyClientTerminationResponse;
struct NotifyClientTerminationResponseDefaultTypeInternal;
extern NotifyClientTerminationResponseDefaultTypeInternal _NotifyClientTerminationResponse_default_instance_;
class PrintThreadStackTraceCommand;
struct PrintThreadStackTraceCommandDefaultTypeInternal;
extern PrintThreadStackTraceCommandDefaultTypeInternal _PrintThreadStackTraceCommand_default_instance_;
class Publishing;
struct PublishingDefaultTypeInternal;
extern PublishingDefaultTypeInternal _Publishing_default_instance_;
class QueryAssignmentRequest;
struct QueryAssignmentRequestDefaultTypeInternal;
extern QueryAssignmentRequestDefaultTypeInternal _QueryAssignmentRequest_default_instance_;
class QueryAssignmentResponse;
struct QueryAssignmentResponseDefaultTypeInternal;
extern QueryAssignmentResponseDefaultTypeInternal _QueryAssignmentResponse_default_instance_;
class QueryRouteRequest;
struct QueryRouteRequestDefaultTypeInternal;
extern QueryRouteRequestDefaultTypeInternal _QueryRouteRequest_default_instance_;
class QueryRouteResponse;
struct QueryRouteResponseDefaultTypeInternal;
extern QueryRouteResponseDefaultTypeInternal _QueryRouteResponse_default_instance_;
class ReceiveMessageRequest;
struct ReceiveMessageRequestDefaultTypeInternal;
extern ReceiveMessageRequestDefaultTypeInternal _ReceiveMessageRequest_default_instance_;
class ReceiveMessageResponse;
struct ReceiveMessageResponseDefaultTypeInternal;
extern ReceiveMessageResponseDefaultTypeInternal _ReceiveMessageResponse_default_instance_;
class RecoverOrphanedTransactionCommand;
struct RecoverOrphanedTransactionCommandDefaultTypeInternal;
extern RecoverOrphanedTransactionCommandDefaultTypeInternal _RecoverOrphanedTransactionCommand_default_instance_;
class SendMessageRequest;
struct SendMessageRequestDefaultTypeInternal;
extern SendMessageRequestDefaultTypeInternal _SendMessageRequest_default_instance_;
class SendMessageResponse;
struct SendMessageResponseDefaultTypeInternal;
extern SendMessageResponseDefaultTypeInternal _SendMessageResponse_default_instance_;
class SendResultEntry;
struct SendResultEntryDefaultTypeInternal;
extern SendResultEntryDefaultTypeInternal _SendResultEntry_default_instance_;
class Settings;
struct SettingsDefaultTypeInternal;
extern SettingsDefaultTypeInternal _Settings_default_instance_;
class Subscription;
struct SubscriptionDefaultTypeInternal;
extern SubscriptionDefaultTypeInternal _Subscription_default_instance_;
class TelemetryCommand;
struct TelemetryCommandDefaultTypeInternal;
extern TelemetryCommandDefaultTypeInternal _TelemetryCommand_default_instance_;
class ThreadStackTrace;
struct ThreadStackTraceDefaultTypeInternal;
extern ThreadStackTraceDefaultTypeInternal _ThreadStackTrace_default_instance_;
class VerifyMessageCommand;
struct VerifyMessageCommandDefaultTypeInternal;
extern VerifyMessageCommandDefaultTypeInternal _VerifyMessageCommand_default_instance_;
class VerifyMessageResult;
struct VerifyMessageResultDefaultTypeInternal;
extern VerifyMessageResultDefaultTypeInternal _VerifyMessageResult_default_instance_;
}  // namespace v2
}  // namespace rocketmq
}  // namespace apache
PROTOBUF_NAMESPACE_OPEN
template<> ::apache::rocketmq::v2::AckMessageEntry* Arena::CreateMaybeMessage<::apache::rocketmq::v2::AckMessageEntry>(Arena*);
template<> ::apache::rocketmq::v2::AckMessageRequest* Arena::CreateMaybeMessage<::apache::rocketmq::v2::AckMessageRequest>(Arena*);
template<> ::apache::rocketmq::v2::AckMessageResponse* Arena::CreateMaybeMessage<::apache::rocketmq::v2::AckMessageResponse>(Arena*);
template<> ::apache::rocketmq::v2::AckMessageResultEntry* Arena::CreateMaybeMessage<::apache::rocketmq::v2::AckMessageResultEntry>(Arena*);
template<> ::apache::rocketmq::v2::ChangeInvisibleDurationRequest* Arena::CreateMaybeMessage<::apache::rocketmq::v2::ChangeInvisibleDurationRequest>(Arena*);
template<> ::apache::rocketmq::v2::ChangeInvisibleDurationResponse* Arena::CreateMaybeMessage<::apache::rocketmq::v2::ChangeInvisibleDurationResponse>(Arena*);
template<> ::apache::rocketmq::v2::EndTransactionRequest* Arena::CreateMaybeMessage<::apache::rocketmq::v2::EndTransactionRequest>(Arena*);
template<> ::apache::rocketmq::v2::EndTransactionResponse* Arena::CreateMaybeMessage<::apache::rocketmq::v2::EndTransactionResponse>(Arena*);
template<> ::apache::rocketmq::v2::ForwardMessageToDeadLetterQueueRequest* Arena::CreateMaybeMessage<::apache::rocketmq::v2::ForwardMessageToDeadLetterQueueRequest>(Arena*);
template<> ::apache::rocketmq::v2::ForwardMessageToDeadLetterQueueResponse* Arena::CreateMaybeMessage<::apache::rocketmq::v2::ForwardMessageToDeadLetterQueueResponse>(Arena*);
template<> ::apache::rocketmq::v2::HeartbeatRequest* Arena::CreateMaybeMessage<::apache::rocketmq::v2::HeartbeatRequest>(Arena*);
template<> ::apache::rocketmq::v2::HeartbeatResponse* Arena::CreateMaybeMessage<::apache::rocketmq::v2::HeartbeatResponse>(Arena*);
template<> ::apache::rocketmq::v2::Metric* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Metric>(Arena*);
template<> ::apache::rocketmq::v2::NotifyClientTerminationRequest* Arena::CreateMaybeMessage<::apache::rocketmq::v2::NotifyClientTerminationRequest>(Arena*);
template<> ::apache::rocketmq::v2::NotifyClientTerminationResponse* Arena::CreateMaybeMessage<::apache::rocketmq::v2::NotifyClientTerminationResponse>(Arena*);
template<> ::apache::rocketmq::v2::PrintThreadStackTraceCommand* Arena::CreateMaybeMessage<::apache::rocketmq::v2::PrintThreadStackTraceCommand>(Arena*);
template<> ::apache::rocketmq::v2::Publishing* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Publishing>(Arena*);
template<> ::apache::rocketmq::v2::QueryAssignmentRequest* Arena::CreateMaybeMessage<::apache::rocketmq::v2::QueryAssignmentRequest>(Arena*);
template<> ::apache::rocketmq::v2::QueryAssignmentResponse* Arena::CreateMaybeMessage<::apache::rocketmq::v2::QueryAssignmentResponse>(Arena*);
template<> ::apache::rocketmq::v2::QueryRouteRequest* Arena::CreateMaybeMessage<::apache::rocketmq::v2::QueryRouteRequest>(Arena*);
template<> ::apache::rocketmq::v2::QueryRouteResponse* Arena::CreateMaybeMessage<::apache::rocketmq::v2::QueryRouteResponse>(Arena*);
template<> ::apache::rocketmq::v2::ReceiveMessageRequest* Arena::CreateMaybeMessage<::apache::rocketmq::v2::ReceiveMessageRequest>(Arena*);
template<> ::apache::rocketmq::v2::ReceiveMessageResponse* Arena::CreateMaybeMessage<::apache::rocketmq::v2::ReceiveMessageResponse>(Arena*);
template<> ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* Arena::CreateMaybeMessage<::apache::rocketmq::v2::RecoverOrphanedTransactionCommand>(Arena*);
template<> ::apache::rocketmq::v2::SendMessageRequest* Arena::CreateMaybeMessage<::apache::rocketmq::v2::SendMessageRequest>(Arena*);
template<> ::apache::rocketmq::v2::SendMessageResponse* Arena::CreateMaybeMessage<::apache::rocketmq::v2::SendMessageResponse>(Arena*);
template<> ::apache::rocketmq::v2::SendResultEntry* Arena::CreateMaybeMessage<::apache::rocketmq::v2::SendResultEntry>(Arena*);
template<> ::apache::rocketmq::v2::Settings* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Settings>(Arena*);
template<> ::apache::rocketmq::v2::Subscription* Arena::CreateMaybeMessage<::apache::rocketmq::v2::Subscription>(Arena*);
template<> ::apache::rocketmq::v2::TelemetryCommand* Arena::CreateMaybeMessage<::apache::rocketmq::v2::TelemetryCommand>(Arena*);
template<> ::apache::rocketmq::v2::ThreadStackTrace* Arena::CreateMaybeMessage<::apache::rocketmq::v2::ThreadStackTrace>(Arena*);
template<> ::apache::rocketmq::v2::VerifyMessageCommand* Arena::CreateMaybeMessage<::apache::rocketmq::v2::VerifyMessageCommand>(Arena*);
template<> ::apache::rocketmq::v2::VerifyMessageResult* Arena::CreateMaybeMessage<::apache::rocketmq::v2::VerifyMessageResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apache {
namespace rocketmq {
namespace v2 {

// ===================================================================

class QueryRouteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.QueryRouteRequest) */ {
 public:
  inline QueryRouteRequest() : QueryRouteRequest(nullptr) {}
  ~QueryRouteRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryRouteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRouteRequest(const QueryRouteRequest& from);
  QueryRouteRequest(QueryRouteRequest&& from) noexcept
    : QueryRouteRequest() {
    *this = ::std::move(from);
  }

  inline QueryRouteRequest& operator=(const QueryRouteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRouteRequest& operator=(QueryRouteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRouteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRouteRequest* internal_default_instance() {
    return reinterpret_cast<const QueryRouteRequest*>(
               &_QueryRouteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(QueryRouteRequest& a, QueryRouteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRouteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRouteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryRouteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryRouteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryRouteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryRouteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRouteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.QueryRouteRequest";
  }
  protected:
  explicit QueryRouteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kEndpointsFieldNumber = 2,
  };
  // .apache.rocketmq.v2.Resource topic = 1 [json_name = "topic"];
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::apache::rocketmq::v2::Resource& topic() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_topic();
  ::apache::rocketmq::v2::Resource* mutable_topic();
  void set_allocated_topic(::apache::rocketmq::v2::Resource* topic);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_topic() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::apache::rocketmq::v2::Resource* topic);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_topic();

  // .apache.rocketmq.v2.Endpoints endpoints = 2 [json_name = "endpoints"];
  bool has_endpoints() const;
  private:
  bool _internal_has_endpoints() const;
  public:
  void clear_endpoints();
  const ::apache::rocketmq::v2::Endpoints& endpoints() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Endpoints* release_endpoints();
  ::apache::rocketmq::v2::Endpoints* mutable_endpoints();
  void set_allocated_endpoints(::apache::rocketmq::v2::Endpoints* endpoints);
  private:
  const ::apache::rocketmq::v2::Endpoints& _internal_endpoints() const;
  ::apache::rocketmq::v2::Endpoints* _internal_mutable_endpoints();
  public:
  void unsafe_arena_set_allocated_endpoints(
      ::apache::rocketmq::v2::Endpoints* endpoints);
  ::apache::rocketmq::v2::Endpoints* unsafe_arena_release_endpoints();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.QueryRouteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apache::rocketmq::v2::Resource* topic_;
  ::apache::rocketmq::v2::Endpoints* endpoints_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class QueryRouteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.QueryRouteResponse) */ {
 public:
  inline QueryRouteResponse() : QueryRouteResponse(nullptr) {}
  ~QueryRouteResponse() override;
  explicit PROTOBUF_CONSTEXPR QueryRouteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRouteResponse(const QueryRouteResponse& from);
  QueryRouteResponse(QueryRouteResponse&& from) noexcept
    : QueryRouteResponse() {
    *this = ::std::move(from);
  }

  inline QueryRouteResponse& operator=(const QueryRouteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRouteResponse& operator=(QueryRouteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRouteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRouteResponse* internal_default_instance() {
    return reinterpret_cast<const QueryRouteResponse*>(
               &_QueryRouteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(QueryRouteResponse& a, QueryRouteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRouteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRouteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryRouteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryRouteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryRouteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryRouteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRouteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.QueryRouteResponse";
  }
  protected:
  explicit QueryRouteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageQueuesFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated .apache.rocketmq.v2.MessageQueue message_queues = 2 [json_name = "messageQueues"];
  int message_queues_size() const;
  private:
  int _internal_message_queues_size() const;
  public:
  void clear_message_queues();
  ::apache::rocketmq::v2::MessageQueue* mutable_message_queues(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::MessageQueue >*
      mutable_message_queues();
  private:
  const ::apache::rocketmq::v2::MessageQueue& _internal_message_queues(int index) const;
  ::apache::rocketmq::v2::MessageQueue* _internal_add_message_queues();
  public:
  const ::apache::rocketmq::v2::MessageQueue& message_queues(int index) const;
  ::apache::rocketmq::v2::MessageQueue* add_message_queues();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::MessageQueue >&
      message_queues() const;

  // .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.QueryRouteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::MessageQueue > message_queues_;
  ::apache::rocketmq::v2::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SendMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.SendMessageRequest) */ {
 public:
  inline SendMessageRequest() : SendMessageRequest(nullptr) {}
  ~SendMessageRequest() override;
  explicit PROTOBUF_CONSTEXPR SendMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageRequest(const SendMessageRequest& from);
  SendMessageRequest(SendMessageRequest&& from) noexcept
    : SendMessageRequest() {
    *this = ::std::move(from);
  }

  inline SendMessageRequest& operator=(const SendMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageRequest& operator=(SendMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageRequest* internal_default_instance() {
    return reinterpret_cast<const SendMessageRequest*>(
               &_SendMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SendMessageRequest& a, SendMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendMessageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.SendMessageRequest";
  }
  protected:
  explicit SendMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .apache.rocketmq.v2.Message messages = 1 [json_name = "messages"];
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::apache::rocketmq::v2::Message* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Message >*
      mutable_messages();
  private:
  const ::apache::rocketmq::v2::Message& _internal_messages(int index) const;
  ::apache::rocketmq::v2::Message* _internal_add_messages();
  public:
  const ::apache::rocketmq::v2::Message& messages(int index) const;
  ::apache::rocketmq::v2::Message* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Message >&
      messages() const;

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.SendMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Message > messages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SendResultEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.SendResultEntry) */ {
 public:
  inline SendResultEntry() : SendResultEntry(nullptr) {}
  ~SendResultEntry() override;
  explicit PROTOBUF_CONSTEXPR SendResultEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendResultEntry(const SendResultEntry& from);
  SendResultEntry(SendResultEntry&& from) noexcept
    : SendResultEntry() {
    *this = ::std::move(from);
  }

  inline SendResultEntry& operator=(const SendResultEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendResultEntry& operator=(SendResultEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendResultEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendResultEntry* internal_default_instance() {
    return reinterpret_cast<const SendResultEntry*>(
               &_SendResultEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SendResultEntry& a, SendResultEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(SendResultEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendResultEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendResultEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendResultEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendResultEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendResultEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendResultEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.SendResultEntry";
  }
  protected:
  explicit SendResultEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 2,
    kTransactionIdFieldNumber = 3,
    kStatusFieldNumber = 1,
    kOffsetFieldNumber = 4,
  };
  // string message_id = 2 [json_name = "messageId"];
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string transaction_id = 3 [json_name = "transactionId"];
  void clear_transaction_id();
  const std::string& transaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_id();
  PROTOBUF_NODISCARD std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // int64 offset = 4 [json_name = "offset"];
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.SendResultEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
  ::apache::rocketmq::v2::Status* status_;
  int64_t offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SendMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.SendMessageResponse) */ {
 public:
  inline SendMessageResponse() : SendMessageResponse(nullptr) {}
  ~SendMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR SendMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageResponse(const SendMessageResponse& from);
  SendMessageResponse(SendMessageResponse&& from) noexcept
    : SendMessageResponse() {
    *this = ::std::move(from);
  }

  inline SendMessageResponse& operator=(const SendMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageResponse& operator=(SendMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageResponse* internal_default_instance() {
    return reinterpret_cast<const SendMessageResponse*>(
               &_SendMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SendMessageResponse& a, SendMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendMessageResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.SendMessageResponse";
  }
  protected:
  explicit SendMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated .apache.rocketmq.v2.SendResultEntry entries = 2 [json_name = "entries"];
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::apache::rocketmq::v2::SendResultEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::SendResultEntry >*
      mutable_entries();
  private:
  const ::apache::rocketmq::v2::SendResultEntry& _internal_entries(int index) const;
  ::apache::rocketmq::v2::SendResultEntry* _internal_add_entries();
  public:
  const ::apache::rocketmq::v2::SendResultEntry& entries(int index) const;
  ::apache::rocketmq::v2::SendResultEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::SendResultEntry >&
      entries() const;

  // .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.SendMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::SendResultEntry > entries_;
  ::apache::rocketmq::v2::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class QueryAssignmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.QueryAssignmentRequest) */ {
 public:
  inline QueryAssignmentRequest() : QueryAssignmentRequest(nullptr) {}
  ~QueryAssignmentRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryAssignmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAssignmentRequest(const QueryAssignmentRequest& from);
  QueryAssignmentRequest(QueryAssignmentRequest&& from) noexcept
    : QueryAssignmentRequest() {
    *this = ::std::move(from);
  }

  inline QueryAssignmentRequest& operator=(const QueryAssignmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAssignmentRequest& operator=(QueryAssignmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAssignmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAssignmentRequest* internal_default_instance() {
    return reinterpret_cast<const QueryAssignmentRequest*>(
               &_QueryAssignmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(QueryAssignmentRequest& a, QueryAssignmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAssignmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAssignmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAssignmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAssignmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAssignmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryAssignmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAssignmentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.QueryAssignmentRequest";
  }
  protected:
  explicit QueryAssignmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kGroupFieldNumber = 2,
    kEndpointsFieldNumber = 3,
  };
  // .apache.rocketmq.v2.Resource topic = 1 [json_name = "topic"];
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::apache::rocketmq::v2::Resource& topic() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_topic();
  ::apache::rocketmq::v2::Resource* mutable_topic();
  void set_allocated_topic(::apache::rocketmq::v2::Resource* topic);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_topic() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::apache::rocketmq::v2::Resource* topic);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_topic();

  // .apache.rocketmq.v2.Resource group = 2 [json_name = "group"];
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::apache::rocketmq::v2::Resource& group() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_group();
  ::apache::rocketmq::v2::Resource* mutable_group();
  void set_allocated_group(::apache::rocketmq::v2::Resource* group);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_group() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::apache::rocketmq::v2::Resource* group);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_group();

  // .apache.rocketmq.v2.Endpoints endpoints = 3 [json_name = "endpoints"];
  bool has_endpoints() const;
  private:
  bool _internal_has_endpoints() const;
  public:
  void clear_endpoints();
  const ::apache::rocketmq::v2::Endpoints& endpoints() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Endpoints* release_endpoints();
  ::apache::rocketmq::v2::Endpoints* mutable_endpoints();
  void set_allocated_endpoints(::apache::rocketmq::v2::Endpoints* endpoints);
  private:
  const ::apache::rocketmq::v2::Endpoints& _internal_endpoints() const;
  ::apache::rocketmq::v2::Endpoints* _internal_mutable_endpoints();
  public:
  void unsafe_arena_set_allocated_endpoints(
      ::apache::rocketmq::v2::Endpoints* endpoints);
  ::apache::rocketmq::v2::Endpoints* unsafe_arena_release_endpoints();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.QueryAssignmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apache::rocketmq::v2::Resource* topic_;
  ::apache::rocketmq::v2::Resource* group_;
  ::apache::rocketmq::v2::Endpoints* endpoints_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class QueryAssignmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.QueryAssignmentResponse) */ {
 public:
  inline QueryAssignmentResponse() : QueryAssignmentResponse(nullptr) {}
  ~QueryAssignmentResponse() override;
  explicit PROTOBUF_CONSTEXPR QueryAssignmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAssignmentResponse(const QueryAssignmentResponse& from);
  QueryAssignmentResponse(QueryAssignmentResponse&& from) noexcept
    : QueryAssignmentResponse() {
    *this = ::std::move(from);
  }

  inline QueryAssignmentResponse& operator=(const QueryAssignmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAssignmentResponse& operator=(QueryAssignmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAssignmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAssignmentResponse* internal_default_instance() {
    return reinterpret_cast<const QueryAssignmentResponse*>(
               &_QueryAssignmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(QueryAssignmentResponse& a, QueryAssignmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAssignmentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAssignmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAssignmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAssignmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAssignmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryAssignmentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAssignmentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.QueryAssignmentResponse";
  }
  protected:
  explicit QueryAssignmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssignmentsFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated .apache.rocketmq.v2.Assignment assignments = 2 [json_name = "assignments"];
  int assignments_size() const;
  private:
  int _internal_assignments_size() const;
  public:
  void clear_assignments();
  ::apache::rocketmq::v2::Assignment* mutable_assignments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Assignment >*
      mutable_assignments();
  private:
  const ::apache::rocketmq::v2::Assignment& _internal_assignments(int index) const;
  ::apache::rocketmq::v2::Assignment* _internal_add_assignments();
  public:
  const ::apache::rocketmq::v2::Assignment& assignments(int index) const;
  ::apache::rocketmq::v2::Assignment* add_assignments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Assignment >&
      assignments() const;

  // .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.QueryAssignmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Assignment > assignments_;
  ::apache::rocketmq::v2::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ReceiveMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.ReceiveMessageRequest) */ {
 public:
  inline ReceiveMessageRequest() : ReceiveMessageRequest(nullptr) {}
  ~ReceiveMessageRequest() override;
  explicit PROTOBUF_CONSTEXPR ReceiveMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveMessageRequest(const ReceiveMessageRequest& from);
  ReceiveMessageRequest(ReceiveMessageRequest&& from) noexcept
    : ReceiveMessageRequest() {
    *this = ::std::move(from);
  }

  inline ReceiveMessageRequest& operator=(const ReceiveMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveMessageRequest& operator=(ReceiveMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveMessageRequest* internal_default_instance() {
    return reinterpret_cast<const ReceiveMessageRequest*>(
               &_ReceiveMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReceiveMessageRequest& a, ReceiveMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReceiveMessageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.ReceiveMessageRequest";
  }
  protected:
  explicit ReceiveMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kMessageQueueFieldNumber = 2,
    kFilterExpressionFieldNumber = 3,
    kInvisibleDurationFieldNumber = 5,
    kBatchSizeFieldNumber = 4,
    kAutoRenewFieldNumber = 6,
  };
  // .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::apache::rocketmq::v2::Resource& group() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_group();
  ::apache::rocketmq::v2::Resource* mutable_group();
  void set_allocated_group(::apache::rocketmq::v2::Resource* group);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_group() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::apache::rocketmq::v2::Resource* group);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_group();

  // .apache.rocketmq.v2.MessageQueue message_queue = 2 [json_name = "messageQueue"];
  bool has_message_queue() const;
  private:
  bool _internal_has_message_queue() const;
  public:
  void clear_message_queue();
  const ::apache::rocketmq::v2::MessageQueue& message_queue() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::MessageQueue* release_message_queue();
  ::apache::rocketmq::v2::MessageQueue* mutable_message_queue();
  void set_allocated_message_queue(::apache::rocketmq::v2::MessageQueue* message_queue);
  private:
  const ::apache::rocketmq::v2::MessageQueue& _internal_message_queue() const;
  ::apache::rocketmq::v2::MessageQueue* _internal_mutable_message_queue();
  public:
  void unsafe_arena_set_allocated_message_queue(
      ::apache::rocketmq::v2::MessageQueue* message_queue);
  ::apache::rocketmq::v2::MessageQueue* unsafe_arena_release_message_queue();

  // .apache.rocketmq.v2.FilterExpression filter_expression = 3 [json_name = "filterExpression"];
  bool has_filter_expression() const;
  private:
  bool _internal_has_filter_expression() const;
  public:
  void clear_filter_expression();
  const ::apache::rocketmq::v2::FilterExpression& filter_expression() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::FilterExpression* release_filter_expression();
  ::apache::rocketmq::v2::FilterExpression* mutable_filter_expression();
  void set_allocated_filter_expression(::apache::rocketmq::v2::FilterExpression* filter_expression);
  private:
  const ::apache::rocketmq::v2::FilterExpression& _internal_filter_expression() const;
  ::apache::rocketmq::v2::FilterExpression* _internal_mutable_filter_expression();
  public:
  void unsafe_arena_set_allocated_filter_expression(
      ::apache::rocketmq::v2::FilterExpression* filter_expression);
  ::apache::rocketmq::v2::FilterExpression* unsafe_arena_release_filter_expression();

  // optional .google.protobuf.Duration invisible_duration = 5 [json_name = "invisibleDuration"];
  bool has_invisible_duration() const;
  private:
  bool _internal_has_invisible_duration() const;
  public:
  void clear_invisible_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& invisible_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_invisible_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_invisible_duration();
  void set_allocated_invisible_duration(::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_invisible_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_invisible_duration();
  public:
  void unsafe_arena_set_allocated_invisible_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_invisible_duration();

  // int32 batch_size = 4 [json_name = "batchSize"];
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // bool auto_renew = 6 [json_name = "autoRenew"];
  void clear_auto_renew();
  bool auto_renew() const;
  void set_auto_renew(bool value);
  private:
  bool _internal_auto_renew() const;
  void _internal_set_auto_renew(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.ReceiveMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apache::rocketmq::v2::Resource* group_;
  ::apache::rocketmq::v2::MessageQueue* message_queue_;
  ::apache::rocketmq::v2::FilterExpression* filter_expression_;
  ::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration_;
  int32_t batch_size_;
  bool auto_renew_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ReceiveMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.ReceiveMessageResponse) */ {
 public:
  inline ReceiveMessageResponse() : ReceiveMessageResponse(nullptr) {}
  ~ReceiveMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR ReceiveMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveMessageResponse(const ReceiveMessageResponse& from);
  ReceiveMessageResponse(ReceiveMessageResponse&& from) noexcept
    : ReceiveMessageResponse() {
    *this = ::std::move(from);
  }

  inline ReceiveMessageResponse& operator=(const ReceiveMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveMessageResponse& operator=(ReceiveMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ContentCase {
    kStatus = 1,
    kMessage = 2,
    kDeliveryTimestamp = 3,
    CONTENT_NOT_SET = 0,
  };

  static inline const ReceiveMessageResponse* internal_default_instance() {
    return reinterpret_cast<const ReceiveMessageResponse*>(
               &_ReceiveMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReceiveMessageResponse& a, ReceiveMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReceiveMessageResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.ReceiveMessageResponse";
  }
  protected:
  explicit ReceiveMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kMessageFieldNumber = 2,
    kDeliveryTimestampFieldNumber = 3,
  };
  // .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // .apache.rocketmq.v2.Message message = 2 [json_name = "message"];
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::apache::rocketmq::v2::Message& message() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Message* release_message();
  ::apache::rocketmq::v2::Message* mutable_message();
  void set_allocated_message(::apache::rocketmq::v2::Message* message);
  private:
  const ::apache::rocketmq::v2::Message& _internal_message() const;
  ::apache::rocketmq::v2::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::apache::rocketmq::v2::Message* message);
  ::apache::rocketmq::v2::Message* unsafe_arena_release_message();

  // .google.protobuf.Timestamp delivery_timestamp = 3 [json_name = "deliveryTimestamp"];
  bool has_delivery_timestamp() const;
  private:
  bool _internal_has_delivery_timestamp() const;
  public:
  void clear_delivery_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& delivery_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_delivery_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_delivery_timestamp();
  void set_allocated_delivery_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_delivery_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_delivery_timestamp();
  public:
  void unsafe_arena_set_allocated_delivery_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_delivery_timestamp();

  void clear_content();
  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.ReceiveMessageResponse)
 private:
  class _Internal;
  void set_has_status();
  void set_has_message();
  void set_has_delivery_timestamp();

  inline bool has_content() const;
  inline void clear_has_content();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ContentUnion {
    constexpr ContentUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::apache::rocketmq::v2::Status* status_;
    ::apache::rocketmq::v2::Message* message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_timestamp_;
  } content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class AckMessageEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.AckMessageEntry) */ {
 public:
  inline AckMessageEntry() : AckMessageEntry(nullptr) {}
  ~AckMessageEntry() override;
  explicit PROTOBUF_CONSTEXPR AckMessageEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckMessageEntry(const AckMessageEntry& from);
  AckMessageEntry(AckMessageEntry&& from) noexcept
    : AckMessageEntry() {
    *this = ::std::move(from);
  }

  inline AckMessageEntry& operator=(const AckMessageEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckMessageEntry& operator=(AckMessageEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AckMessageEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckMessageEntry* internal_default_instance() {
    return reinterpret_cast<const AckMessageEntry*>(
               &_AckMessageEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AckMessageEntry& a, AckMessageEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(AckMessageEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckMessageEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckMessageEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckMessageEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AckMessageEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AckMessageEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckMessageEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.AckMessageEntry";
  }
  protected:
  explicit AckMessageEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kReceiptHandleFieldNumber = 2,
  };
  // string message_id = 1 [json_name = "messageId"];
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string receipt_handle = 2 [json_name = "receiptHandle"];
  void clear_receipt_handle();
  const std::string& receipt_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receipt_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receipt_handle();
  PROTOBUF_NODISCARD std::string* release_receipt_handle();
  void set_allocated_receipt_handle(std::string* receipt_handle);
  private:
  const std::string& _internal_receipt_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receipt_handle(const std::string& value);
  std::string* _internal_mutable_receipt_handle();
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.AckMessageEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receipt_handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class AckMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.AckMessageRequest) */ {
 public:
  inline AckMessageRequest() : AckMessageRequest(nullptr) {}
  ~AckMessageRequest() override;
  explicit PROTOBUF_CONSTEXPR AckMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckMessageRequest(const AckMessageRequest& from);
  AckMessageRequest(AckMessageRequest&& from) noexcept
    : AckMessageRequest() {
    *this = ::std::move(from);
  }

  inline AckMessageRequest& operator=(const AckMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckMessageRequest& operator=(AckMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AckMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckMessageRequest* internal_default_instance() {
    return reinterpret_cast<const AckMessageRequest*>(
               &_AckMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AckMessageRequest& a, AckMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AckMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AckMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AckMessageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.AckMessageRequest";
  }
  protected:
  explicit AckMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 3,
    kGroupFieldNumber = 1,
    kTopicFieldNumber = 2,
  };
  // repeated .apache.rocketmq.v2.AckMessageEntry entries = 3 [json_name = "entries"];
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::apache::rocketmq::v2::AckMessageEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::AckMessageEntry >*
      mutable_entries();
  private:
  const ::apache::rocketmq::v2::AckMessageEntry& _internal_entries(int index) const;
  ::apache::rocketmq::v2::AckMessageEntry* _internal_add_entries();
  public:
  const ::apache::rocketmq::v2::AckMessageEntry& entries(int index) const;
  ::apache::rocketmq::v2::AckMessageEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::AckMessageEntry >&
      entries() const;

  // .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::apache::rocketmq::v2::Resource& group() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_group();
  ::apache::rocketmq::v2::Resource* mutable_group();
  void set_allocated_group(::apache::rocketmq::v2::Resource* group);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_group() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::apache::rocketmq::v2::Resource* group);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_group();

  // .apache.rocketmq.v2.Resource topic = 2 [json_name = "topic"];
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::apache::rocketmq::v2::Resource& topic() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_topic();
  ::apache::rocketmq::v2::Resource* mutable_topic();
  void set_allocated_topic(::apache::rocketmq::v2::Resource* topic);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_topic() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::apache::rocketmq::v2::Resource* topic);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_topic();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.AckMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::AckMessageEntry > entries_;
  ::apache::rocketmq::v2::Resource* group_;
  ::apache::rocketmq::v2::Resource* topic_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class AckMessageResultEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.AckMessageResultEntry) */ {
 public:
  inline AckMessageResultEntry() : AckMessageResultEntry(nullptr) {}
  ~AckMessageResultEntry() override;
  explicit PROTOBUF_CONSTEXPR AckMessageResultEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckMessageResultEntry(const AckMessageResultEntry& from);
  AckMessageResultEntry(AckMessageResultEntry&& from) noexcept
    : AckMessageResultEntry() {
    *this = ::std::move(from);
  }

  inline AckMessageResultEntry& operator=(const AckMessageResultEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckMessageResultEntry& operator=(AckMessageResultEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AckMessageResultEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckMessageResultEntry* internal_default_instance() {
    return reinterpret_cast<const AckMessageResultEntry*>(
               &_AckMessageResultEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AckMessageResultEntry& a, AckMessageResultEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(AckMessageResultEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckMessageResultEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckMessageResultEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckMessageResultEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AckMessageResultEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AckMessageResultEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckMessageResultEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.AckMessageResultEntry";
  }
  protected:
  explicit AckMessageResultEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kReceiptHandleFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string message_id = 1 [json_name = "messageId"];
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string receipt_handle = 2 [json_name = "receiptHandle"];
  void clear_receipt_handle();
  const std::string& receipt_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receipt_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receipt_handle();
  PROTOBUF_NODISCARD std::string* release_receipt_handle();
  void set_allocated_receipt_handle(std::string* receipt_handle);
  private:
  const std::string& _internal_receipt_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receipt_handle(const std::string& value);
  std::string* _internal_mutable_receipt_handle();
  public:

  // .apache.rocketmq.v2.Status status = 3 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.AckMessageResultEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receipt_handle_;
  ::apache::rocketmq::v2::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class AckMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.AckMessageResponse) */ {
 public:
  inline AckMessageResponse() : AckMessageResponse(nullptr) {}
  ~AckMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR AckMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckMessageResponse(const AckMessageResponse& from);
  AckMessageResponse(AckMessageResponse&& from) noexcept
    : AckMessageResponse() {
    *this = ::std::move(from);
  }

  inline AckMessageResponse& operator=(const AckMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckMessageResponse& operator=(AckMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AckMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckMessageResponse* internal_default_instance() {
    return reinterpret_cast<const AckMessageResponse*>(
               &_AckMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AckMessageResponse& a, AckMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AckMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AckMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AckMessageResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.AckMessageResponse";
  }
  protected:
  explicit AckMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated .apache.rocketmq.v2.AckMessageResultEntry entries = 2 [json_name = "entries"];
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::apache::rocketmq::v2::AckMessageResultEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::AckMessageResultEntry >*
      mutable_entries();
  private:
  const ::apache::rocketmq::v2::AckMessageResultEntry& _internal_entries(int index) const;
  ::apache::rocketmq::v2::AckMessageResultEntry* _internal_add_entries();
  public:
  const ::apache::rocketmq::v2::AckMessageResultEntry& entries(int index) const;
  ::apache::rocketmq::v2::AckMessageResultEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::AckMessageResultEntry >&
      entries() const;

  // .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.AckMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::AckMessageResultEntry > entries_;
  ::apache::rocketmq::v2::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ForwardMessageToDeadLetterQueueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest) */ {
 public:
  inline ForwardMessageToDeadLetterQueueRequest() : ForwardMessageToDeadLetterQueueRequest(nullptr) {}
  ~ForwardMessageToDeadLetterQueueRequest() override;
  explicit PROTOBUF_CONSTEXPR ForwardMessageToDeadLetterQueueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForwardMessageToDeadLetterQueueRequest(const ForwardMessageToDeadLetterQueueRequest& from);
  ForwardMessageToDeadLetterQueueRequest(ForwardMessageToDeadLetterQueueRequest&& from) noexcept
    : ForwardMessageToDeadLetterQueueRequest() {
    *this = ::std::move(from);
  }

  inline ForwardMessageToDeadLetterQueueRequest& operator=(const ForwardMessageToDeadLetterQueueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForwardMessageToDeadLetterQueueRequest& operator=(ForwardMessageToDeadLetterQueueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForwardMessageToDeadLetterQueueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForwardMessageToDeadLetterQueueRequest* internal_default_instance() {
    return reinterpret_cast<const ForwardMessageToDeadLetterQueueRequest*>(
               &_ForwardMessageToDeadLetterQueueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ForwardMessageToDeadLetterQueueRequest& a, ForwardMessageToDeadLetterQueueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ForwardMessageToDeadLetterQueueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForwardMessageToDeadLetterQueueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForwardMessageToDeadLetterQueueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForwardMessageToDeadLetterQueueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForwardMessageToDeadLetterQueueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ForwardMessageToDeadLetterQueueRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForwardMessageToDeadLetterQueueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest";
  }
  protected:
  explicit ForwardMessageToDeadLetterQueueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiptHandleFieldNumber = 3,
    kMessageIdFieldNumber = 4,
    kGroupFieldNumber = 1,
    kTopicFieldNumber = 2,
    kDeliveryAttemptFieldNumber = 5,
    kMaxDeliveryAttemptsFieldNumber = 6,
  };
  // string receipt_handle = 3 [json_name = "receiptHandle"];
  void clear_receipt_handle();
  const std::string& receipt_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receipt_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receipt_handle();
  PROTOBUF_NODISCARD std::string* release_receipt_handle();
  void set_allocated_receipt_handle(std::string* receipt_handle);
  private:
  const std::string& _internal_receipt_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receipt_handle(const std::string& value);
  std::string* _internal_mutable_receipt_handle();
  public:

  // string message_id = 4 [json_name = "messageId"];
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::apache::rocketmq::v2::Resource& group() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_group();
  ::apache::rocketmq::v2::Resource* mutable_group();
  void set_allocated_group(::apache::rocketmq::v2::Resource* group);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_group() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::apache::rocketmq::v2::Resource* group);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_group();

  // .apache.rocketmq.v2.Resource topic = 2 [json_name = "topic"];
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::apache::rocketmq::v2::Resource& topic() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_topic();
  ::apache::rocketmq::v2::Resource* mutable_topic();
  void set_allocated_topic(::apache::rocketmq::v2::Resource* topic);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_topic() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::apache::rocketmq::v2::Resource* topic);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_topic();

  // int32 delivery_attempt = 5 [json_name = "deliveryAttempt"];
  void clear_delivery_attempt();
  int32_t delivery_attempt() const;
  void set_delivery_attempt(int32_t value);
  private:
  int32_t _internal_delivery_attempt() const;
  void _internal_set_delivery_attempt(int32_t value);
  public:

  // int32 max_delivery_attempts = 6 [json_name = "maxDeliveryAttempts"];
  void clear_max_delivery_attempts();
  int32_t max_delivery_attempts() const;
  void set_max_delivery_attempts(int32_t value);
  private:
  int32_t _internal_max_delivery_attempts() const;
  void _internal_set_max_delivery_attempts(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receipt_handle_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::apache::rocketmq::v2::Resource* group_;
  ::apache::rocketmq::v2::Resource* topic_;
  int32_t delivery_attempt_;
  int32_t max_delivery_attempts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ForwardMessageToDeadLetterQueueResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueResponse) */ {
 public:
  inline ForwardMessageToDeadLetterQueueResponse() : ForwardMessageToDeadLetterQueueResponse(nullptr) {}
  ~ForwardMessageToDeadLetterQueueResponse() override;
  explicit PROTOBUF_CONSTEXPR ForwardMessageToDeadLetterQueueResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForwardMessageToDeadLetterQueueResponse(const ForwardMessageToDeadLetterQueueResponse& from);
  ForwardMessageToDeadLetterQueueResponse(ForwardMessageToDeadLetterQueueResponse&& from) noexcept
    : ForwardMessageToDeadLetterQueueResponse() {
    *this = ::std::move(from);
  }

  inline ForwardMessageToDeadLetterQueueResponse& operator=(const ForwardMessageToDeadLetterQueueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForwardMessageToDeadLetterQueueResponse& operator=(ForwardMessageToDeadLetterQueueResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForwardMessageToDeadLetterQueueResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForwardMessageToDeadLetterQueueResponse* internal_default_instance() {
    return reinterpret_cast<const ForwardMessageToDeadLetterQueueResponse*>(
               &_ForwardMessageToDeadLetterQueueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ForwardMessageToDeadLetterQueueResponse& a, ForwardMessageToDeadLetterQueueResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ForwardMessageToDeadLetterQueueResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForwardMessageToDeadLetterQueueResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForwardMessageToDeadLetterQueueResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForwardMessageToDeadLetterQueueResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForwardMessageToDeadLetterQueueResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ForwardMessageToDeadLetterQueueResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForwardMessageToDeadLetterQueueResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.ForwardMessageToDeadLetterQueueResponse";
  }
  protected:
  explicit ForwardMessageToDeadLetterQueueResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apache::rocketmq::v2::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.HeartbeatRequest) */ {
 public:
  inline HeartbeatRequest() : HeartbeatRequest(nullptr) {}
  ~HeartbeatRequest() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatRequest(const HeartbeatRequest& from);
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeartbeatRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.HeartbeatRequest";
  }
  protected:
  explicit HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kClientTypeFieldNumber = 2,
  };
  // optional .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::apache::rocketmq::v2::Resource& group() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_group();
  ::apache::rocketmq::v2::Resource* mutable_group();
  void set_allocated_group(::apache::rocketmq::v2::Resource* group);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_group() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::apache::rocketmq::v2::Resource* group);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_group();

  // .apache.rocketmq.v2.ClientType client_type = 2 [json_name = "clientType"];
  void clear_client_type();
  ::apache::rocketmq::v2::ClientType client_type() const;
  void set_client_type(::apache::rocketmq::v2::ClientType value);
  private:
  ::apache::rocketmq::v2::ClientType _internal_client_type() const;
  void _internal_set_client_type(::apache::rocketmq::v2::ClientType value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.HeartbeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apache::rocketmq::v2::Resource* group_;
  int client_type_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.HeartbeatResponse) */ {
 public:
  inline HeartbeatResponse() : HeartbeatResponse(nullptr) {}
  ~HeartbeatResponse() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatResponse(const HeartbeatResponse& from);
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeartbeatResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.HeartbeatResponse";
  }
  protected:
  explicit HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.HeartbeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apache::rocketmq::v2::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class EndTransactionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.EndTransactionRequest) */ {
 public:
  inline EndTransactionRequest() : EndTransactionRequest(nullptr) {}
  ~EndTransactionRequest() override;
  explicit PROTOBUF_CONSTEXPR EndTransactionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndTransactionRequest(const EndTransactionRequest& from);
  EndTransactionRequest(EndTransactionRequest&& from) noexcept
    : EndTransactionRequest() {
    *this = ::std::move(from);
  }

  inline EndTransactionRequest& operator=(const EndTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndTransactionRequest& operator=(EndTransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndTransactionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const EndTransactionRequest*>(
               &_EndTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EndTransactionRequest& a, EndTransactionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EndTransactionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndTransactionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndTransactionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndTransactionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EndTransactionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EndTransactionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndTransactionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.EndTransactionRequest";
  }
  protected:
  explicit EndTransactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 2,
    kTransactionIdFieldNumber = 3,
    kTraceContextFieldNumber = 6,
    kTopicFieldNumber = 1,
    kResolutionFieldNumber = 4,
    kSourceFieldNumber = 5,
  };
  // string message_id = 2 [json_name = "messageId"];
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string transaction_id = 3 [json_name = "transactionId"];
  void clear_transaction_id();
  const std::string& transaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_id();
  PROTOBUF_NODISCARD std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // string trace_context = 6 [json_name = "traceContext"];
  void clear_trace_context();
  const std::string& trace_context() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_context(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_context();
  PROTOBUF_NODISCARD std::string* release_trace_context();
  void set_allocated_trace_context(std::string* trace_context);
  private:
  const std::string& _internal_trace_context() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_context(const std::string& value);
  std::string* _internal_mutable_trace_context();
  public:

  // .apache.rocketmq.v2.Resource topic = 1 [json_name = "topic"];
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::apache::rocketmq::v2::Resource& topic() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_topic();
  ::apache::rocketmq::v2::Resource* mutable_topic();
  void set_allocated_topic(::apache::rocketmq::v2::Resource* topic);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_topic() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::apache::rocketmq::v2::Resource* topic);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_topic();

  // .apache.rocketmq.v2.TransactionResolution resolution = 4 [json_name = "resolution"];
  void clear_resolution();
  ::apache::rocketmq::v2::TransactionResolution resolution() const;
  void set_resolution(::apache::rocketmq::v2::TransactionResolution value);
  private:
  ::apache::rocketmq::v2::TransactionResolution _internal_resolution() const;
  void _internal_set_resolution(::apache::rocketmq::v2::TransactionResolution value);
  public:

  // .apache.rocketmq.v2.TransactionSource source = 5 [json_name = "source"];
  void clear_source();
  ::apache::rocketmq::v2::TransactionSource source() const;
  void set_source(::apache::rocketmq::v2::TransactionSource value);
  private:
  ::apache::rocketmq::v2::TransactionSource _internal_source() const;
  void _internal_set_source(::apache::rocketmq::v2::TransactionSource value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.EndTransactionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_context_;
  ::apache::rocketmq::v2::Resource* topic_;
  int resolution_;
  int source_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class EndTransactionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.EndTransactionResponse) */ {
 public:
  inline EndTransactionResponse() : EndTransactionResponse(nullptr) {}
  ~EndTransactionResponse() override;
  explicit PROTOBUF_CONSTEXPR EndTransactionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndTransactionResponse(const EndTransactionResponse& from);
  EndTransactionResponse(EndTransactionResponse&& from) noexcept
    : EndTransactionResponse() {
    *this = ::std::move(from);
  }

  inline EndTransactionResponse& operator=(const EndTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndTransactionResponse& operator=(EndTransactionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndTransactionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndTransactionResponse* internal_default_instance() {
    return reinterpret_cast<const EndTransactionResponse*>(
               &_EndTransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EndTransactionResponse& a, EndTransactionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EndTransactionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndTransactionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndTransactionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndTransactionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EndTransactionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EndTransactionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndTransactionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.EndTransactionResponse";
  }
  protected:
  explicit EndTransactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.EndTransactionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apache::rocketmq::v2::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class PrintThreadStackTraceCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.PrintThreadStackTraceCommand) */ {
 public:
  inline PrintThreadStackTraceCommand() : PrintThreadStackTraceCommand(nullptr) {}
  ~PrintThreadStackTraceCommand() override;
  explicit PROTOBUF_CONSTEXPR PrintThreadStackTraceCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrintThreadStackTraceCommand(const PrintThreadStackTraceCommand& from);
  PrintThreadStackTraceCommand(PrintThreadStackTraceCommand&& from) noexcept
    : PrintThreadStackTraceCommand() {
    *this = ::std::move(from);
  }

  inline PrintThreadStackTraceCommand& operator=(const PrintThreadStackTraceCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrintThreadStackTraceCommand& operator=(PrintThreadStackTraceCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrintThreadStackTraceCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrintThreadStackTraceCommand* internal_default_instance() {
    return reinterpret_cast<const PrintThreadStackTraceCommand*>(
               &_PrintThreadStackTraceCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PrintThreadStackTraceCommand& a, PrintThreadStackTraceCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(PrintThreadStackTraceCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrintThreadStackTraceCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrintThreadStackTraceCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrintThreadStackTraceCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrintThreadStackTraceCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PrintThreadStackTraceCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrintThreadStackTraceCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.PrintThreadStackTraceCommand";
  }
  protected:
  explicit PrintThreadStackTraceCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // string nonce = 1 [json_name = "nonce"];
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.PrintThreadStackTraceCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ThreadStackTrace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.ThreadStackTrace) */ {
 public:
  inline ThreadStackTrace() : ThreadStackTrace(nullptr) {}
  ~ThreadStackTrace() override;
  explicit PROTOBUF_CONSTEXPR ThreadStackTrace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreadStackTrace(const ThreadStackTrace& from);
  ThreadStackTrace(ThreadStackTrace&& from) noexcept
    : ThreadStackTrace() {
    *this = ::std::move(from);
  }

  inline ThreadStackTrace& operator=(const ThreadStackTrace& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreadStackTrace& operator=(ThreadStackTrace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThreadStackTrace& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreadStackTrace* internal_default_instance() {
    return reinterpret_cast<const ThreadStackTrace*>(
               &_ThreadStackTrace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ThreadStackTrace& a, ThreadStackTrace& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreadStackTrace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreadStackTrace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreadStackTrace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreadStackTrace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThreadStackTrace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ThreadStackTrace& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThreadStackTrace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.ThreadStackTrace";
  }
  protected:
  explicit ThreadStackTrace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
    kThreadStackTraceFieldNumber = 2,
  };
  // string nonce = 1 [json_name = "nonce"];
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // optional string thread_stack_trace = 2 [json_name = "threadStackTrace"];
  bool has_thread_stack_trace() const;
  private:
  bool _internal_has_thread_stack_trace() const;
  public:
  void clear_thread_stack_trace();
  const std::string& thread_stack_trace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thread_stack_trace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thread_stack_trace();
  PROTOBUF_NODISCARD std::string* release_thread_stack_trace();
  void set_allocated_thread_stack_trace(std::string* thread_stack_trace);
  private:
  const std::string& _internal_thread_stack_trace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thread_stack_trace(const std::string& value);
  std::string* _internal_mutable_thread_stack_trace();
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.ThreadStackTrace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thread_stack_trace_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class VerifyMessageCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.VerifyMessageCommand) */ {
 public:
  inline VerifyMessageCommand() : VerifyMessageCommand(nullptr) {}
  ~VerifyMessageCommand() override;
  explicit PROTOBUF_CONSTEXPR VerifyMessageCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyMessageCommand(const VerifyMessageCommand& from);
  VerifyMessageCommand(VerifyMessageCommand&& from) noexcept
    : VerifyMessageCommand() {
    *this = ::std::move(from);
  }

  inline VerifyMessageCommand& operator=(const VerifyMessageCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyMessageCommand& operator=(VerifyMessageCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyMessageCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyMessageCommand* internal_default_instance() {
    return reinterpret_cast<const VerifyMessageCommand*>(
               &_VerifyMessageCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(VerifyMessageCommand& a, VerifyMessageCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyMessageCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyMessageCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyMessageCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyMessageCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyMessageCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VerifyMessageCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyMessageCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.VerifyMessageCommand";
  }
  protected:
  explicit VerifyMessageCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string nonce = 1 [json_name = "nonce"];
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // .apache.rocketmq.v2.Message message = 2 [json_name = "message"];
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::apache::rocketmq::v2::Message& message() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Message* release_message();
  ::apache::rocketmq::v2::Message* mutable_message();
  void set_allocated_message(::apache::rocketmq::v2::Message* message);
  private:
  const ::apache::rocketmq::v2::Message& _internal_message() const;
  ::apache::rocketmq::v2::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::apache::rocketmq::v2::Message* message);
  ::apache::rocketmq::v2::Message* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.VerifyMessageCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
  ::apache::rocketmq::v2::Message* message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class VerifyMessageResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.VerifyMessageResult) */ {
 public:
  inline VerifyMessageResult() : VerifyMessageResult(nullptr) {}
  ~VerifyMessageResult() override;
  explicit PROTOBUF_CONSTEXPR VerifyMessageResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyMessageResult(const VerifyMessageResult& from);
  VerifyMessageResult(VerifyMessageResult&& from) noexcept
    : VerifyMessageResult() {
    *this = ::std::move(from);
  }

  inline VerifyMessageResult& operator=(const VerifyMessageResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyMessageResult& operator=(VerifyMessageResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyMessageResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyMessageResult* internal_default_instance() {
    return reinterpret_cast<const VerifyMessageResult*>(
               &_VerifyMessageResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(VerifyMessageResult& a, VerifyMessageResult& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyMessageResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyMessageResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyMessageResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyMessageResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyMessageResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VerifyMessageResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyMessageResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.VerifyMessageResult";
  }
  protected:
  explicit VerifyMessageResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // string nonce = 1 [json_name = "nonce"];
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.VerifyMessageResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RecoverOrphanedTransactionCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.RecoverOrphanedTransactionCommand) */ {
 public:
  inline RecoverOrphanedTransactionCommand() : RecoverOrphanedTransactionCommand(nullptr) {}
  ~RecoverOrphanedTransactionCommand() override;
  explicit PROTOBUF_CONSTEXPR RecoverOrphanedTransactionCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecoverOrphanedTransactionCommand(const RecoverOrphanedTransactionCommand& from);
  RecoverOrphanedTransactionCommand(RecoverOrphanedTransactionCommand&& from) noexcept
    : RecoverOrphanedTransactionCommand() {
    *this = ::std::move(from);
  }

  inline RecoverOrphanedTransactionCommand& operator=(const RecoverOrphanedTransactionCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoverOrphanedTransactionCommand& operator=(RecoverOrphanedTransactionCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecoverOrphanedTransactionCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecoverOrphanedTransactionCommand* internal_default_instance() {
    return reinterpret_cast<const RecoverOrphanedTransactionCommand*>(
               &_RecoverOrphanedTransactionCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RecoverOrphanedTransactionCommand& a, RecoverOrphanedTransactionCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RecoverOrphanedTransactionCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecoverOrphanedTransactionCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecoverOrphanedTransactionCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecoverOrphanedTransactionCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecoverOrphanedTransactionCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RecoverOrphanedTransactionCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecoverOrphanedTransactionCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.RecoverOrphanedTransactionCommand";
  }
  protected:
  explicit RecoverOrphanedTransactionCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionIdFieldNumber = 2,
    kMessageFieldNumber = 1,
  };
  // string transaction_id = 2 [json_name = "transactionId"];
  void clear_transaction_id();
  const std::string& transaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_id();
  PROTOBUF_NODISCARD std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // .apache.rocketmq.v2.Message message = 1 [json_name = "message"];
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::apache::rocketmq::v2::Message& message() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Message* release_message();
  ::apache::rocketmq::v2::Message* mutable_message();
  void set_allocated_message(::apache::rocketmq::v2::Message* message);
  private:
  const ::apache::rocketmq::v2::Message& _internal_message() const;
  ::apache::rocketmq::v2::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::apache::rocketmq::v2::Message* message);
  ::apache::rocketmq::v2::Message* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.RecoverOrphanedTransactionCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
  ::apache::rocketmq::v2::Message* message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Publishing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.Publishing) */ {
 public:
  inline Publishing() : Publishing(nullptr) {}
  ~Publishing() override;
  explicit PROTOBUF_CONSTEXPR Publishing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Publishing(const Publishing& from);
  Publishing(Publishing&& from) noexcept
    : Publishing() {
    *this = ::std::move(from);
  }

  inline Publishing& operator=(const Publishing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Publishing& operator=(Publishing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Publishing& default_instance() {
    return *internal_default_instance();
  }
  static inline const Publishing* internal_default_instance() {
    return reinterpret_cast<const Publishing*>(
               &_Publishing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Publishing& a, Publishing& b) {
    a.Swap(&b);
  }
  inline void Swap(Publishing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Publishing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Publishing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Publishing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Publishing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Publishing& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Publishing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.Publishing";
  }
  protected:
  explicit Publishing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicsFieldNumber = 1,
    kMaxBodySizeFieldNumber = 2,
    kValidateMessageTypeFieldNumber = 3,
  };
  // repeated .apache.rocketmq.v2.Resource topics = 1 [json_name = "topics"];
  int topics_size() const;
  private:
  int _internal_topics_size() const;
  public:
  void clear_topics();
  ::apache::rocketmq::v2::Resource* mutable_topics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Resource >*
      mutable_topics();
  private:
  const ::apache::rocketmq::v2::Resource& _internal_topics(int index) const;
  ::apache::rocketmq::v2::Resource* _internal_add_topics();
  public:
  const ::apache::rocketmq::v2::Resource& topics(int index) const;
  ::apache::rocketmq::v2::Resource* add_topics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Resource >&
      topics() const;

  // int32 max_body_size = 2 [json_name = "maxBodySize"];
  void clear_max_body_size();
  int32_t max_body_size() const;
  void set_max_body_size(int32_t value);
  private:
  int32_t _internal_max_body_size() const;
  void _internal_set_max_body_size(int32_t value);
  public:

  // bool validate_message_type = 3 [json_name = "validateMessageType"];
  void clear_validate_message_type();
  bool validate_message_type() const;
  void set_validate_message_type(bool value);
  private:
  bool _internal_validate_message_type() const;
  void _internal_set_validate_message_type(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.Publishing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Resource > topics_;
  int32_t max_body_size_;
  bool validate_message_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Subscription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.Subscription) */ {
 public:
  inline Subscription() : Subscription(nullptr) {}
  ~Subscription() override;
  explicit PROTOBUF_CONSTEXPR Subscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subscription(const Subscription& from);
  Subscription(Subscription&& from) noexcept
    : Subscription() {
    *this = ::std::move(from);
  }

  inline Subscription& operator=(const Subscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscription& operator=(Subscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subscription* internal_default_instance() {
    return reinterpret_cast<const Subscription*>(
               &_Subscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Subscription& a, Subscription& b) {
    a.Swap(&b);
  }
  inline void Swap(Subscription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subscription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Subscription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subscription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Subscription& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subscription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.Subscription";
  }
  protected:
  explicit Subscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionsFieldNumber = 2,
    kGroupFieldNumber = 1,
    kLongPollingTimeoutFieldNumber = 5,
    kFifoFieldNumber = 3,
    kReceiveBatchSizeFieldNumber = 4,
  };
  // repeated .apache.rocketmq.v2.SubscriptionEntry subscriptions = 2 [json_name = "subscriptions"];
  int subscriptions_size() const;
  private:
  int _internal_subscriptions_size() const;
  public:
  void clear_subscriptions();
  ::apache::rocketmq::v2::SubscriptionEntry* mutable_subscriptions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::SubscriptionEntry >*
      mutable_subscriptions();
  private:
  const ::apache::rocketmq::v2::SubscriptionEntry& _internal_subscriptions(int index) const;
  ::apache::rocketmq::v2::SubscriptionEntry* _internal_add_subscriptions();
  public:
  const ::apache::rocketmq::v2::SubscriptionEntry& subscriptions(int index) const;
  ::apache::rocketmq::v2::SubscriptionEntry* add_subscriptions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::SubscriptionEntry >&
      subscriptions() const;

  // optional .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::apache::rocketmq::v2::Resource& group() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_group();
  ::apache::rocketmq::v2::Resource* mutable_group();
  void set_allocated_group(::apache::rocketmq::v2::Resource* group);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_group() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::apache::rocketmq::v2::Resource* group);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_group();

  // optional .google.protobuf.Duration long_polling_timeout = 5 [json_name = "longPollingTimeout"];
  bool has_long_polling_timeout() const;
  private:
  bool _internal_has_long_polling_timeout() const;
  public:
  void clear_long_polling_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& long_polling_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_long_polling_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_long_polling_timeout();
  void set_allocated_long_polling_timeout(::PROTOBUF_NAMESPACE_ID::Duration* long_polling_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_long_polling_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_long_polling_timeout();
  public:
  void unsafe_arena_set_allocated_long_polling_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* long_polling_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_long_polling_timeout();

  // optional bool fifo = 3 [json_name = "fifo"];
  bool has_fifo() const;
  private:
  bool _internal_has_fifo() const;
  public:
  void clear_fifo();
  bool fifo() const;
  void set_fifo(bool value);
  private:
  bool _internal_fifo() const;
  void _internal_set_fifo(bool value);
  public:

  // optional int32 receive_batch_size = 4 [json_name = "receiveBatchSize"];
  bool has_receive_batch_size() const;
  private:
  bool _internal_has_receive_batch_size() const;
  public:
  void clear_receive_batch_size();
  int32_t receive_batch_size() const;
  void set_receive_batch_size(int32_t value);
  private:
  int32_t _internal_receive_batch_size() const;
  void _internal_set_receive_batch_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.Subscription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::SubscriptionEntry > subscriptions_;
  ::apache::rocketmq::v2::Resource* group_;
  ::PROTOBUF_NAMESPACE_ID::Duration* long_polling_timeout_;
  bool fifo_;
  int32_t receive_batch_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Metric final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.Metric) */ {
 public:
  inline Metric() : Metric(nullptr) {}
  ~Metric() override;
  explicit PROTOBUF_CONSTEXPR Metric(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metric(const Metric& from);
  Metric(Metric&& from) noexcept
    : Metric() {
    *this = ::std::move(from);
  }

  inline Metric& operator=(const Metric& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metric& operator=(Metric&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metric& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metric* internal_default_instance() {
    return reinterpret_cast<const Metric*>(
               &_Metric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Metric& a, Metric& b) {
    a.Swap(&b);
  }
  inline void Swap(Metric* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metric* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metric* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metric>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metric& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Metric& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metric* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.Metric";
  }
  protected:
  explicit Metric(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointsFieldNumber = 2,
    kOnFieldNumber = 1,
  };
  // optional .apache.rocketmq.v2.Endpoints endpoints = 2 [json_name = "endpoints"];
  bool has_endpoints() const;
  private:
  bool _internal_has_endpoints() const;
  public:
  void clear_endpoints();
  const ::apache::rocketmq::v2::Endpoints& endpoints() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Endpoints* release_endpoints();
  ::apache::rocketmq::v2::Endpoints* mutable_endpoints();
  void set_allocated_endpoints(::apache::rocketmq::v2::Endpoints* endpoints);
  private:
  const ::apache::rocketmq::v2::Endpoints& _internal_endpoints() const;
  ::apache::rocketmq::v2::Endpoints* _internal_mutable_endpoints();
  public:
  void unsafe_arena_set_allocated_endpoints(
      ::apache::rocketmq::v2::Endpoints* endpoints);
  ::apache::rocketmq::v2::Endpoints* unsafe_arena_release_endpoints();

  // bool on = 1 [json_name = "on"];
  void clear_on();
  bool on() const;
  void set_on(bool value);
  private:
  bool _internal_on() const;
  void _internal_set_on(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.Metric)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apache::rocketmq::v2::Endpoints* endpoints_;
  bool on_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Settings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.Settings) */ {
 public:
  inline Settings() : Settings(nullptr) {}
  ~Settings() override;
  explicit PROTOBUF_CONSTEXPR Settings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Settings(const Settings& from);
  Settings(Settings&& from) noexcept
    : Settings() {
    *this = ::std::move(from);
  }

  inline Settings& operator=(const Settings& from) {
    CopyFrom(from);
    return *this;
  }
  inline Settings& operator=(Settings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Settings& default_instance() {
    return *internal_default_instance();
  }
  enum PubSubCase {
    kPublishing = 5,
    kSubscription = 6,
    PUB_SUB_NOT_SET = 0,
  };

  static inline const Settings* internal_default_instance() {
    return reinterpret_cast<const Settings*>(
               &_Settings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Settings& a, Settings& b) {
    a.Swap(&b);
  }
  inline void Swap(Settings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Settings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Settings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Settings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Settings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Settings& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Settings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.Settings";
  }
  protected:
  explicit Settings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessPointFieldNumber = 2,
    kBackoffPolicyFieldNumber = 3,
    kRequestTimeoutFieldNumber = 4,
    kUserAgentFieldNumber = 7,
    kMetricFieldNumber = 8,
    kClientTypeFieldNumber = 1,
    kPublishingFieldNumber = 5,
    kSubscriptionFieldNumber = 6,
  };
  // optional .apache.rocketmq.v2.Endpoints access_point = 2 [json_name = "accessPoint"];
  bool has_access_point() const;
  private:
  bool _internal_has_access_point() const;
  public:
  void clear_access_point();
  const ::apache::rocketmq::v2::Endpoints& access_point() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Endpoints* release_access_point();
  ::apache::rocketmq::v2::Endpoints* mutable_access_point();
  void set_allocated_access_point(::apache::rocketmq::v2::Endpoints* access_point);
  private:
  const ::apache::rocketmq::v2::Endpoints& _internal_access_point() const;
  ::apache::rocketmq::v2::Endpoints* _internal_mutable_access_point();
  public:
  void unsafe_arena_set_allocated_access_point(
      ::apache::rocketmq::v2::Endpoints* access_point);
  ::apache::rocketmq::v2::Endpoints* unsafe_arena_release_access_point();

  // optional .apache.rocketmq.v2.RetryPolicy backoff_policy = 3 [json_name = "backoffPolicy"];
  bool has_backoff_policy() const;
  private:
  bool _internal_has_backoff_policy() const;
  public:
  void clear_backoff_policy();
  const ::apache::rocketmq::v2::RetryPolicy& backoff_policy() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::RetryPolicy* release_backoff_policy();
  ::apache::rocketmq::v2::RetryPolicy* mutable_backoff_policy();
  void set_allocated_backoff_policy(::apache::rocketmq::v2::RetryPolicy* backoff_policy);
  private:
  const ::apache::rocketmq::v2::RetryPolicy& _internal_backoff_policy() const;
  ::apache::rocketmq::v2::RetryPolicy* _internal_mutable_backoff_policy();
  public:
  void unsafe_arena_set_allocated_backoff_policy(
      ::apache::rocketmq::v2::RetryPolicy* backoff_policy);
  ::apache::rocketmq::v2::RetryPolicy* unsafe_arena_release_backoff_policy();

  // optional .google.protobuf.Duration request_timeout = 4 [json_name = "requestTimeout"];
  bool has_request_timeout() const;
  private:
  bool _internal_has_request_timeout() const;
  public:
  void clear_request_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& request_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_request_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_request_timeout();
  void set_allocated_request_timeout(::PROTOBUF_NAMESPACE_ID::Duration* request_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_request_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_request_timeout();
  public:
  void unsafe_arena_set_allocated_request_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* request_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_request_timeout();

  // .apache.rocketmq.v2.UA user_agent = 7 [json_name = "userAgent"];
  bool has_user_agent() const;
  private:
  bool _internal_has_user_agent() const;
  public:
  void clear_user_agent();
  const ::apache::rocketmq::v2::UA& user_agent() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::UA* release_user_agent();
  ::apache::rocketmq::v2::UA* mutable_user_agent();
  void set_allocated_user_agent(::apache::rocketmq::v2::UA* user_agent);
  private:
  const ::apache::rocketmq::v2::UA& _internal_user_agent() const;
  ::apache::rocketmq::v2::UA* _internal_mutable_user_agent();
  public:
  void unsafe_arena_set_allocated_user_agent(
      ::apache::rocketmq::v2::UA* user_agent);
  ::apache::rocketmq::v2::UA* unsafe_arena_release_user_agent();

  // .apache.rocketmq.v2.Metric metric = 8 [json_name = "metric"];
  bool has_metric() const;
  private:
  bool _internal_has_metric() const;
  public:
  void clear_metric();
  const ::apache::rocketmq::v2::Metric& metric() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Metric* release_metric();
  ::apache::rocketmq::v2::Metric* mutable_metric();
  void set_allocated_metric(::apache::rocketmq::v2::Metric* metric);
  private:
  const ::apache::rocketmq::v2::Metric& _internal_metric() const;
  ::apache::rocketmq::v2::Metric* _internal_mutable_metric();
  public:
  void unsafe_arena_set_allocated_metric(
      ::apache::rocketmq::v2::Metric* metric);
  ::apache::rocketmq::v2::Metric* unsafe_arena_release_metric();

  // optional .apache.rocketmq.v2.ClientType client_type = 1 [json_name = "clientType"];
  bool has_client_type() const;
  private:
  bool _internal_has_client_type() const;
  public:
  void clear_client_type();
  ::apache::rocketmq::v2::ClientType client_type() const;
  void set_client_type(::apache::rocketmq::v2::ClientType value);
  private:
  ::apache::rocketmq::v2::ClientType _internal_client_type() const;
  void _internal_set_client_type(::apache::rocketmq::v2::ClientType value);
  public:

  // .apache.rocketmq.v2.Publishing publishing = 5 [json_name = "publishing"];
  bool has_publishing() const;
  private:
  bool _internal_has_publishing() const;
  public:
  void clear_publishing();
  const ::apache::rocketmq::v2::Publishing& publishing() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Publishing* release_publishing();
  ::apache::rocketmq::v2::Publishing* mutable_publishing();
  void set_allocated_publishing(::apache::rocketmq::v2::Publishing* publishing);
  private:
  const ::apache::rocketmq::v2::Publishing& _internal_publishing() const;
  ::apache::rocketmq::v2::Publishing* _internal_mutable_publishing();
  public:
  void unsafe_arena_set_allocated_publishing(
      ::apache::rocketmq::v2::Publishing* publishing);
  ::apache::rocketmq::v2::Publishing* unsafe_arena_release_publishing();

  // .apache.rocketmq.v2.Subscription subscription = 6 [json_name = "subscription"];
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::apache::rocketmq::v2::Subscription& subscription() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Subscription* release_subscription();
  ::apache::rocketmq::v2::Subscription* mutable_subscription();
  void set_allocated_subscription(::apache::rocketmq::v2::Subscription* subscription);
  private:
  const ::apache::rocketmq::v2::Subscription& _internal_subscription() const;
  ::apache::rocketmq::v2::Subscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::apache::rocketmq::v2::Subscription* subscription);
  ::apache::rocketmq::v2::Subscription* unsafe_arena_release_subscription();

  void clear_pub_sub();
  PubSubCase pub_sub_case() const;
  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.Settings)
 private:
  class _Internal;
  void set_has_publishing();
  void set_has_subscription();

  inline bool has_pub_sub() const;
  inline void clear_has_pub_sub();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apache::rocketmq::v2::Endpoints* access_point_;
  ::apache::rocketmq::v2::RetryPolicy* backoff_policy_;
  ::PROTOBUF_NAMESPACE_ID::Duration* request_timeout_;
  ::apache::rocketmq::v2::UA* user_agent_;
  ::apache::rocketmq::v2::Metric* metric_;
  int client_type_;
  union PubSubUnion {
    constexpr PubSubUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::apache::rocketmq::v2::Publishing* publishing_;
    ::apache::rocketmq::v2::Subscription* subscription_;
  } pub_sub_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TelemetryCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.TelemetryCommand) */ {
 public:
  inline TelemetryCommand() : TelemetryCommand(nullptr) {}
  ~TelemetryCommand() override;
  explicit PROTOBUF_CONSTEXPR TelemetryCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryCommand(const TelemetryCommand& from);
  TelemetryCommand(TelemetryCommand&& from) noexcept
    : TelemetryCommand() {
    *this = ::std::move(from);
  }

  inline TelemetryCommand& operator=(const TelemetryCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryCommand& operator=(TelemetryCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TelemetryCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kSettings = 2,
    kThreadStackTrace = 3,
    kVerifyMessageResult = 4,
    kRecoverOrphanedTransactionCommand = 5,
    kPrintThreadStackTraceCommand = 6,
    kVerifyMessageCommand = 7,
    COMMAND_NOT_SET = 0,
  };

  static inline const TelemetryCommand* internal_default_instance() {
    return reinterpret_cast<const TelemetryCommand*>(
               &_TelemetryCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TelemetryCommand& a, TelemetryCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TelemetryCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TelemetryCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TelemetryCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.TelemetryCommand";
  }
  protected:
  explicit TelemetryCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kSettingsFieldNumber = 2,
    kThreadStackTraceFieldNumber = 3,
    kVerifyMessageResultFieldNumber = 4,
    kRecoverOrphanedTransactionCommandFieldNumber = 5,
    kPrintThreadStackTraceCommandFieldNumber = 6,
    kVerifyMessageCommandFieldNumber = 7,
  };
  // optional .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // .apache.rocketmq.v2.Settings settings = 2 [json_name = "settings"];
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::apache::rocketmq::v2::Settings& settings() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Settings* release_settings();
  ::apache::rocketmq::v2::Settings* mutable_settings();
  void set_allocated_settings(::apache::rocketmq::v2::Settings* settings);
  private:
  const ::apache::rocketmq::v2::Settings& _internal_settings() const;
  ::apache::rocketmq::v2::Settings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::apache::rocketmq::v2::Settings* settings);
  ::apache::rocketmq::v2::Settings* unsafe_arena_release_settings();

  // .apache.rocketmq.v2.ThreadStackTrace thread_stack_trace = 3 [json_name = "threadStackTrace"];
  bool has_thread_stack_trace() const;
  private:
  bool _internal_has_thread_stack_trace() const;
  public:
  void clear_thread_stack_trace();
  const ::apache::rocketmq::v2::ThreadStackTrace& thread_stack_trace() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::ThreadStackTrace* release_thread_stack_trace();
  ::apache::rocketmq::v2::ThreadStackTrace* mutable_thread_stack_trace();
  void set_allocated_thread_stack_trace(::apache::rocketmq::v2::ThreadStackTrace* thread_stack_trace);
  private:
  const ::apache::rocketmq::v2::ThreadStackTrace& _internal_thread_stack_trace() const;
  ::apache::rocketmq::v2::ThreadStackTrace* _internal_mutable_thread_stack_trace();
  public:
  void unsafe_arena_set_allocated_thread_stack_trace(
      ::apache::rocketmq::v2::ThreadStackTrace* thread_stack_trace);
  ::apache::rocketmq::v2::ThreadStackTrace* unsafe_arena_release_thread_stack_trace();

  // .apache.rocketmq.v2.VerifyMessageResult verify_message_result = 4 [json_name = "verifyMessageResult"];
  bool has_verify_message_result() const;
  private:
  bool _internal_has_verify_message_result() const;
  public:
  void clear_verify_message_result();
  const ::apache::rocketmq::v2::VerifyMessageResult& verify_message_result() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::VerifyMessageResult* release_verify_message_result();
  ::apache::rocketmq::v2::VerifyMessageResult* mutable_verify_message_result();
  void set_allocated_verify_message_result(::apache::rocketmq::v2::VerifyMessageResult* verify_message_result);
  private:
  const ::apache::rocketmq::v2::VerifyMessageResult& _internal_verify_message_result() const;
  ::apache::rocketmq::v2::VerifyMessageResult* _internal_mutable_verify_message_result();
  public:
  void unsafe_arena_set_allocated_verify_message_result(
      ::apache::rocketmq::v2::VerifyMessageResult* verify_message_result);
  ::apache::rocketmq::v2::VerifyMessageResult* unsafe_arena_release_verify_message_result();

  // .apache.rocketmq.v2.RecoverOrphanedTransactionCommand recover_orphaned_transaction_command = 5 [json_name = "recoverOrphanedTransactionCommand"];
  bool has_recover_orphaned_transaction_command() const;
  private:
  bool _internal_has_recover_orphaned_transaction_command() const;
  public:
  void clear_recover_orphaned_transaction_command();
  const ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand& recover_orphaned_transaction_command() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* release_recover_orphaned_transaction_command();
  ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* mutable_recover_orphaned_transaction_command();
  void set_allocated_recover_orphaned_transaction_command(::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* recover_orphaned_transaction_command);
  private:
  const ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand& _internal_recover_orphaned_transaction_command() const;
  ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* _internal_mutable_recover_orphaned_transaction_command();
  public:
  void unsafe_arena_set_allocated_recover_orphaned_transaction_command(
      ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* recover_orphaned_transaction_command);
  ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* unsafe_arena_release_recover_orphaned_transaction_command();

  // .apache.rocketmq.v2.PrintThreadStackTraceCommand print_thread_stack_trace_command = 6 [json_name = "printThreadStackTraceCommand"];
  bool has_print_thread_stack_trace_command() const;
  private:
  bool _internal_has_print_thread_stack_trace_command() const;
  public:
  void clear_print_thread_stack_trace_command();
  const ::apache::rocketmq::v2::PrintThreadStackTraceCommand& print_thread_stack_trace_command() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::PrintThreadStackTraceCommand* release_print_thread_stack_trace_command();
  ::apache::rocketmq::v2::PrintThreadStackTraceCommand* mutable_print_thread_stack_trace_command();
  void set_allocated_print_thread_stack_trace_command(::apache::rocketmq::v2::PrintThreadStackTraceCommand* print_thread_stack_trace_command);
  private:
  const ::apache::rocketmq::v2::PrintThreadStackTraceCommand& _internal_print_thread_stack_trace_command() const;
  ::apache::rocketmq::v2::PrintThreadStackTraceCommand* _internal_mutable_print_thread_stack_trace_command();
  public:
  void unsafe_arena_set_allocated_print_thread_stack_trace_command(
      ::apache::rocketmq::v2::PrintThreadStackTraceCommand* print_thread_stack_trace_command);
  ::apache::rocketmq::v2::PrintThreadStackTraceCommand* unsafe_arena_release_print_thread_stack_trace_command();

  // .apache.rocketmq.v2.VerifyMessageCommand verify_message_command = 7 [json_name = "verifyMessageCommand"];
  bool has_verify_message_command() const;
  private:
  bool _internal_has_verify_message_command() const;
  public:
  void clear_verify_message_command();
  const ::apache::rocketmq::v2::VerifyMessageCommand& verify_message_command() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::VerifyMessageCommand* release_verify_message_command();
  ::apache::rocketmq::v2::VerifyMessageCommand* mutable_verify_message_command();
  void set_allocated_verify_message_command(::apache::rocketmq::v2::VerifyMessageCommand* verify_message_command);
  private:
  const ::apache::rocketmq::v2::VerifyMessageCommand& _internal_verify_message_command() const;
  ::apache::rocketmq::v2::VerifyMessageCommand* _internal_mutable_verify_message_command();
  public:
  void unsafe_arena_set_allocated_verify_message_command(
      ::apache::rocketmq::v2::VerifyMessageCommand* verify_message_command);
  ::apache::rocketmq::v2::VerifyMessageCommand* unsafe_arena_release_verify_message_command();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.TelemetryCommand)
 private:
  class _Internal;
  void set_has_settings();
  void set_has_thread_stack_trace();
  void set_has_verify_message_result();
  void set_has_recover_orphaned_transaction_command();
  void set_has_print_thread_stack_trace_command();
  void set_has_verify_message_command();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apache::rocketmq::v2::Status* status_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::apache::rocketmq::v2::Settings* settings_;
    ::apache::rocketmq::v2::ThreadStackTrace* thread_stack_trace_;
    ::apache::rocketmq::v2::VerifyMessageResult* verify_message_result_;
    ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* recover_orphaned_transaction_command_;
    ::apache::rocketmq::v2::PrintThreadStackTraceCommand* print_thread_stack_trace_command_;
    ::apache::rocketmq::v2::VerifyMessageCommand* verify_message_command_;
  } command_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class NotifyClientTerminationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.NotifyClientTerminationRequest) */ {
 public:
  inline NotifyClientTerminationRequest() : NotifyClientTerminationRequest(nullptr) {}
  ~NotifyClientTerminationRequest() override;
  explicit PROTOBUF_CONSTEXPR NotifyClientTerminationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyClientTerminationRequest(const NotifyClientTerminationRequest& from);
  NotifyClientTerminationRequest(NotifyClientTerminationRequest&& from) noexcept
    : NotifyClientTerminationRequest() {
    *this = ::std::move(from);
  }

  inline NotifyClientTerminationRequest& operator=(const NotifyClientTerminationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyClientTerminationRequest& operator=(NotifyClientTerminationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyClientTerminationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyClientTerminationRequest* internal_default_instance() {
    return reinterpret_cast<const NotifyClientTerminationRequest*>(
               &_NotifyClientTerminationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(NotifyClientTerminationRequest& a, NotifyClientTerminationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyClientTerminationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyClientTerminationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyClientTerminationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyClientTerminationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyClientTerminationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotifyClientTerminationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyClientTerminationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.NotifyClientTerminationRequest";
  }
  protected:
  explicit NotifyClientTerminationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
  };
  // optional .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::apache::rocketmq::v2::Resource& group() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_group();
  ::apache::rocketmq::v2::Resource* mutable_group();
  void set_allocated_group(::apache::rocketmq::v2::Resource* group);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_group() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::apache::rocketmq::v2::Resource* group);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_group();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.NotifyClientTerminationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apache::rocketmq::v2::Resource* group_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class NotifyClientTerminationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.NotifyClientTerminationResponse) */ {
 public:
  inline NotifyClientTerminationResponse() : NotifyClientTerminationResponse(nullptr) {}
  ~NotifyClientTerminationResponse() override;
  explicit PROTOBUF_CONSTEXPR NotifyClientTerminationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyClientTerminationResponse(const NotifyClientTerminationResponse& from);
  NotifyClientTerminationResponse(NotifyClientTerminationResponse&& from) noexcept
    : NotifyClientTerminationResponse() {
    *this = ::std::move(from);
  }

  inline NotifyClientTerminationResponse& operator=(const NotifyClientTerminationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyClientTerminationResponse& operator=(NotifyClientTerminationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyClientTerminationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyClientTerminationResponse* internal_default_instance() {
    return reinterpret_cast<const NotifyClientTerminationResponse*>(
               &_NotifyClientTerminationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(NotifyClientTerminationResponse& a, NotifyClientTerminationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyClientTerminationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyClientTerminationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyClientTerminationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyClientTerminationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyClientTerminationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotifyClientTerminationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyClientTerminationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.NotifyClientTerminationResponse";
  }
  protected:
  explicit NotifyClientTerminationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.NotifyClientTerminationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apache::rocketmq::v2::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ChangeInvisibleDurationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.ChangeInvisibleDurationRequest) */ {
 public:
  inline ChangeInvisibleDurationRequest() : ChangeInvisibleDurationRequest(nullptr) {}
  ~ChangeInvisibleDurationRequest() override;
  explicit PROTOBUF_CONSTEXPR ChangeInvisibleDurationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeInvisibleDurationRequest(const ChangeInvisibleDurationRequest& from);
  ChangeInvisibleDurationRequest(ChangeInvisibleDurationRequest&& from) noexcept
    : ChangeInvisibleDurationRequest() {
    *this = ::std::move(from);
  }

  inline ChangeInvisibleDurationRequest& operator=(const ChangeInvisibleDurationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeInvisibleDurationRequest& operator=(ChangeInvisibleDurationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeInvisibleDurationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeInvisibleDurationRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeInvisibleDurationRequest*>(
               &_ChangeInvisibleDurationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ChangeInvisibleDurationRequest& a, ChangeInvisibleDurationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeInvisibleDurationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeInvisibleDurationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeInvisibleDurationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeInvisibleDurationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeInvisibleDurationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeInvisibleDurationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeInvisibleDurationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.ChangeInvisibleDurationRequest";
  }
  protected:
  explicit ChangeInvisibleDurationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiptHandleFieldNumber = 3,
    kMessageIdFieldNumber = 5,
    kGroupFieldNumber = 1,
    kTopicFieldNumber = 2,
    kInvisibleDurationFieldNumber = 4,
  };
  // string receipt_handle = 3 [json_name = "receiptHandle"];
  void clear_receipt_handle();
  const std::string& receipt_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receipt_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receipt_handle();
  PROTOBUF_NODISCARD std::string* release_receipt_handle();
  void set_allocated_receipt_handle(std::string* receipt_handle);
  private:
  const std::string& _internal_receipt_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receipt_handle(const std::string& value);
  std::string* _internal_mutable_receipt_handle();
  public:

  // string message_id = 5 [json_name = "messageId"];
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::apache::rocketmq::v2::Resource& group() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_group();
  ::apache::rocketmq::v2::Resource* mutable_group();
  void set_allocated_group(::apache::rocketmq::v2::Resource* group);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_group() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::apache::rocketmq::v2::Resource* group);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_group();

  // .apache.rocketmq.v2.Resource topic = 2 [json_name = "topic"];
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::apache::rocketmq::v2::Resource& topic() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Resource* release_topic();
  ::apache::rocketmq::v2::Resource* mutable_topic();
  void set_allocated_topic(::apache::rocketmq::v2::Resource* topic);
  private:
  const ::apache::rocketmq::v2::Resource& _internal_topic() const;
  ::apache::rocketmq::v2::Resource* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::apache::rocketmq::v2::Resource* topic);
  ::apache::rocketmq::v2::Resource* unsafe_arena_release_topic();

  // .google.protobuf.Duration invisible_duration = 4 [json_name = "invisibleDuration"];
  bool has_invisible_duration() const;
  private:
  bool _internal_has_invisible_duration() const;
  public:
  void clear_invisible_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& invisible_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_invisible_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_invisible_duration();
  void set_allocated_invisible_duration(::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_invisible_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_invisible_duration();
  public:
  void unsafe_arena_set_allocated_invisible_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_invisible_duration();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.ChangeInvisibleDurationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receipt_handle_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::apache::rocketmq::v2::Resource* group_;
  ::apache::rocketmq::v2::Resource* topic_;
  ::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ChangeInvisibleDurationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apache.rocketmq.v2.ChangeInvisibleDurationResponse) */ {
 public:
  inline ChangeInvisibleDurationResponse() : ChangeInvisibleDurationResponse(nullptr) {}
  ~ChangeInvisibleDurationResponse() override;
  explicit PROTOBUF_CONSTEXPR ChangeInvisibleDurationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeInvisibleDurationResponse(const ChangeInvisibleDurationResponse& from);
  ChangeInvisibleDurationResponse(ChangeInvisibleDurationResponse&& from) noexcept
    : ChangeInvisibleDurationResponse() {
    *this = ::std::move(from);
  }

  inline ChangeInvisibleDurationResponse& operator=(const ChangeInvisibleDurationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeInvisibleDurationResponse& operator=(ChangeInvisibleDurationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeInvisibleDurationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeInvisibleDurationResponse* internal_default_instance() {
    return reinterpret_cast<const ChangeInvisibleDurationResponse*>(
               &_ChangeInvisibleDurationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ChangeInvisibleDurationResponse& a, ChangeInvisibleDurationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeInvisibleDurationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeInvisibleDurationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeInvisibleDurationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeInvisibleDurationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeInvisibleDurationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeInvisibleDurationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeInvisibleDurationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apache.rocketmq.v2.ChangeInvisibleDurationResponse";
  }
  protected:
  explicit ChangeInvisibleDurationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiptHandleFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string receipt_handle = 2 [json_name = "receiptHandle"];
  void clear_receipt_handle();
  const std::string& receipt_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receipt_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receipt_handle();
  PROTOBUF_NODISCARD std::string* release_receipt_handle();
  void set_allocated_receipt_handle(std::string* receipt_handle);
  private:
  const std::string& _internal_receipt_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receipt_handle(const std::string& value);
  std::string* _internal_mutable_receipt_handle();
  public:

  // .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::apache::rocketmq::v2::Status& status() const;
  PROTOBUF_NODISCARD ::apache::rocketmq::v2::Status* release_status();
  ::apache::rocketmq::v2::Status* mutable_status();
  void set_allocated_status(::apache::rocketmq::v2::Status* status);
  private:
  const ::apache::rocketmq::v2::Status& _internal_status() const;
  ::apache::rocketmq::v2::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::apache::rocketmq::v2::Status* status);
  ::apache::rocketmq::v2::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:apache.rocketmq.v2.ChangeInvisibleDurationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receipt_handle_;
  ::apache::rocketmq::v2::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_apache_2frocketmq_2fv2_2fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// QueryRouteRequest

// .apache.rocketmq.v2.Resource topic = 1 [json_name = "topic"];
inline bool QueryRouteRequest::_internal_has_topic() const {
  return this != internal_default_instance() && topic_ != nullptr;
}
inline bool QueryRouteRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::apache::rocketmq::v2::Resource& QueryRouteRequest::_internal_topic() const {
  const ::apache::rocketmq::v2::Resource* p = topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& QueryRouteRequest::topic() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.QueryRouteRequest.topic)
  return _internal_topic();
}
inline void QueryRouteRequest::unsafe_arena_set_allocated_topic(
    ::apache::rocketmq::v2::Resource* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.QueryRouteRequest.topic)
}
inline ::apache::rocketmq::v2::Resource* QueryRouteRequest::release_topic() {
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* QueryRouteRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.QueryRouteRequest.topic)
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* QueryRouteRequest::_internal_mutable_topic() {
  
  if (topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    topic_ = p;
  }
  return topic_;
}
inline ::apache::rocketmq::v2::Resource* QueryRouteRequest::mutable_topic() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.QueryRouteRequest.topic)
  return _msg;
}
inline void QueryRouteRequest::set_allocated_topic(::apache::rocketmq::v2::Resource* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.QueryRouteRequest.topic)
}

// .apache.rocketmq.v2.Endpoints endpoints = 2 [json_name = "endpoints"];
inline bool QueryRouteRequest::_internal_has_endpoints() const {
  return this != internal_default_instance() && endpoints_ != nullptr;
}
inline bool QueryRouteRequest::has_endpoints() const {
  return _internal_has_endpoints();
}
inline const ::apache::rocketmq::v2::Endpoints& QueryRouteRequest::_internal_endpoints() const {
  const ::apache::rocketmq::v2::Endpoints* p = endpoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Endpoints&>(
      ::apache::rocketmq::v2::_Endpoints_default_instance_);
}
inline const ::apache::rocketmq::v2::Endpoints& QueryRouteRequest::endpoints() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.QueryRouteRequest.endpoints)
  return _internal_endpoints();
}
inline void QueryRouteRequest::unsafe_arena_set_allocated_endpoints(
    ::apache::rocketmq::v2::Endpoints* endpoints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoints_);
  }
  endpoints_ = endpoints;
  if (endpoints) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.QueryRouteRequest.endpoints)
}
inline ::apache::rocketmq::v2::Endpoints* QueryRouteRequest::release_endpoints() {
  
  ::apache::rocketmq::v2::Endpoints* temp = endpoints_;
  endpoints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Endpoints* QueryRouteRequest::unsafe_arena_release_endpoints() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.QueryRouteRequest.endpoints)
  
  ::apache::rocketmq::v2::Endpoints* temp = endpoints_;
  endpoints_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Endpoints* QueryRouteRequest::_internal_mutable_endpoints() {
  
  if (endpoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Endpoints>(GetArenaForAllocation());
    endpoints_ = p;
  }
  return endpoints_;
}
inline ::apache::rocketmq::v2::Endpoints* QueryRouteRequest::mutable_endpoints() {
  ::apache::rocketmq::v2::Endpoints* _msg = _internal_mutable_endpoints();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.QueryRouteRequest.endpoints)
  return _msg;
}
inline void QueryRouteRequest::set_allocated_endpoints(::apache::rocketmq::v2::Endpoints* endpoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoints_);
  }
  if (endpoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoints));
    if (message_arena != submessage_arena) {
      endpoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoints, submessage_arena);
    }
    
  } else {
    
  }
  endpoints_ = endpoints;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.QueryRouteRequest.endpoints)
}

// -------------------------------------------------------------------

// QueryRouteResponse

// .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
inline bool QueryRouteResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool QueryRouteResponse::has_status() const {
  return _internal_has_status();
}
inline const ::apache::rocketmq::v2::Status& QueryRouteResponse::_internal_status() const {
  const ::apache::rocketmq::v2::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Status&>(
      ::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& QueryRouteResponse::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.QueryRouteResponse.status)
  return _internal_status();
}
inline void QueryRouteResponse::unsafe_arena_set_allocated_status(
    ::apache::rocketmq::v2::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.QueryRouteResponse.status)
}
inline ::apache::rocketmq::v2::Status* QueryRouteResponse::release_status() {
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Status* QueryRouteResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.QueryRouteResponse.status)
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Status* QueryRouteResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::apache::rocketmq::v2::Status* QueryRouteResponse::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.QueryRouteResponse.status)
  return _msg;
}
inline void QueryRouteResponse::set_allocated_status(::apache::rocketmq::v2::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.QueryRouteResponse.status)
}

// repeated .apache.rocketmq.v2.MessageQueue message_queues = 2 [json_name = "messageQueues"];
inline int QueryRouteResponse::_internal_message_queues_size() const {
  return message_queues_.size();
}
inline int QueryRouteResponse::message_queues_size() const {
  return _internal_message_queues_size();
}
inline ::apache::rocketmq::v2::MessageQueue* QueryRouteResponse::mutable_message_queues(int index) {
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.QueryRouteResponse.message_queues)
  return message_queues_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::MessageQueue >*
QueryRouteResponse::mutable_message_queues() {
  // @@protoc_insertion_point(field_mutable_list:apache.rocketmq.v2.QueryRouteResponse.message_queues)
  return &message_queues_;
}
inline const ::apache::rocketmq::v2::MessageQueue& QueryRouteResponse::_internal_message_queues(int index) const {
  return message_queues_.Get(index);
}
inline const ::apache::rocketmq::v2::MessageQueue& QueryRouteResponse::message_queues(int index) const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.QueryRouteResponse.message_queues)
  return _internal_message_queues(index);
}
inline ::apache::rocketmq::v2::MessageQueue* QueryRouteResponse::_internal_add_message_queues() {
  return message_queues_.Add();
}
inline ::apache::rocketmq::v2::MessageQueue* QueryRouteResponse::add_message_queues() {
  ::apache::rocketmq::v2::MessageQueue* _add = _internal_add_message_queues();
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.QueryRouteResponse.message_queues)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::MessageQueue >&
QueryRouteResponse::message_queues() const {
  // @@protoc_insertion_point(field_list:apache.rocketmq.v2.QueryRouteResponse.message_queues)
  return message_queues_;
}

// -------------------------------------------------------------------

// SendMessageRequest

// repeated .apache.rocketmq.v2.Message messages = 1 [json_name = "messages"];
inline int SendMessageRequest::_internal_messages_size() const {
  return messages_.size();
}
inline int SendMessageRequest::messages_size() const {
  return _internal_messages_size();
}
inline ::apache::rocketmq::v2::Message* SendMessageRequest::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SendMessageRequest.messages)
  return messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Message >*
SendMessageRequest::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:apache.rocketmq.v2.SendMessageRequest.messages)
  return &messages_;
}
inline const ::apache::rocketmq::v2::Message& SendMessageRequest::_internal_messages(int index) const {
  return messages_.Get(index);
}
inline const ::apache::rocketmq::v2::Message& SendMessageRequest::messages(int index) const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SendMessageRequest.messages)
  return _internal_messages(index);
}
inline ::apache::rocketmq::v2::Message* SendMessageRequest::_internal_add_messages() {
  return messages_.Add();
}
inline ::apache::rocketmq::v2::Message* SendMessageRequest::add_messages() {
  ::apache::rocketmq::v2::Message* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.SendMessageRequest.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Message >&
SendMessageRequest::messages() const {
  // @@protoc_insertion_point(field_list:apache.rocketmq.v2.SendMessageRequest.messages)
  return messages_;
}

// -------------------------------------------------------------------

// SendResultEntry

// .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
inline bool SendResultEntry::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool SendResultEntry::has_status() const {
  return _internal_has_status();
}
inline const ::apache::rocketmq::v2::Status& SendResultEntry::_internal_status() const {
  const ::apache::rocketmq::v2::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Status&>(
      ::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& SendResultEntry::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SendResultEntry.status)
  return _internal_status();
}
inline void SendResultEntry::unsafe_arena_set_allocated_status(
    ::apache::rocketmq::v2::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.SendResultEntry.status)
}
inline ::apache::rocketmq::v2::Status* SendResultEntry::release_status() {
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Status* SendResultEntry::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SendResultEntry.status)
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Status* SendResultEntry::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::apache::rocketmq::v2::Status* SendResultEntry::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SendResultEntry.status)
  return _msg;
}
inline void SendResultEntry::set_allocated_status(::apache::rocketmq::v2::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SendResultEntry.status)
}

// string message_id = 2 [json_name = "messageId"];
inline void SendResultEntry::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& SendResultEntry::message_id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SendResultEntry.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendResultEntry::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SendResultEntry.message_id)
}
inline std::string* SendResultEntry::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SendResultEntry.message_id)
  return _s;
}
inline const std::string& SendResultEntry::_internal_message_id() const {
  return message_id_.Get();
}
inline void SendResultEntry::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SendResultEntry::_internal_mutable_message_id() {
  
  return message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SendResultEntry::release_message_id() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SendResultEntry.message_id)
  return message_id_.Release();
}
inline void SendResultEntry::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_id_.IsDefault()) {
    message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SendResultEntry.message_id)
}

// string transaction_id = 3 [json_name = "transactionId"];
inline void SendResultEntry::clear_transaction_id() {
  transaction_id_.ClearToEmpty();
}
inline const std::string& SendResultEntry::transaction_id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SendResultEntry.transaction_id)
  return _internal_transaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendResultEntry::set_transaction_id(ArgT0&& arg0, ArgT... args) {
 
 transaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SendResultEntry.transaction_id)
}
inline std::string* SendResultEntry::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SendResultEntry.transaction_id)
  return _s;
}
inline const std::string& SendResultEntry::_internal_transaction_id() const {
  return transaction_id_.Get();
}
inline void SendResultEntry::_internal_set_transaction_id(const std::string& value) {
  
  transaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SendResultEntry::_internal_mutable_transaction_id() {
  
  return transaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SendResultEntry::release_transaction_id() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SendResultEntry.transaction_id)
  return transaction_id_.Release();
}
inline void SendResultEntry::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    
  } else {
    
  }
  transaction_id_.SetAllocated(transaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transaction_id_.IsDefault()) {
    transaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SendResultEntry.transaction_id)
}

// int64 offset = 4 [json_name = "offset"];
inline void SendResultEntry::clear_offset() {
  offset_ = int64_t{0};
}
inline int64_t SendResultEntry::_internal_offset() const {
  return offset_;
}
inline int64_t SendResultEntry::offset() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SendResultEntry.offset)
  return _internal_offset();
}
inline void SendResultEntry::_internal_set_offset(int64_t value) {
  
  offset_ = value;
}
inline void SendResultEntry::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.SendResultEntry.offset)
}

// -------------------------------------------------------------------

// SendMessageResponse

// .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
inline bool SendMessageResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool SendMessageResponse::has_status() const {
  return _internal_has_status();
}
inline const ::apache::rocketmq::v2::Status& SendMessageResponse::_internal_status() const {
  const ::apache::rocketmq::v2::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Status&>(
      ::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& SendMessageResponse::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SendMessageResponse.status)
  return _internal_status();
}
inline void SendMessageResponse::unsafe_arena_set_allocated_status(
    ::apache::rocketmq::v2::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.SendMessageResponse.status)
}
inline ::apache::rocketmq::v2::Status* SendMessageResponse::release_status() {
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Status* SendMessageResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.SendMessageResponse.status)
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Status* SendMessageResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::apache::rocketmq::v2::Status* SendMessageResponse::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SendMessageResponse.status)
  return _msg;
}
inline void SendMessageResponse::set_allocated_status(::apache::rocketmq::v2::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.SendMessageResponse.status)
}

// repeated .apache.rocketmq.v2.SendResultEntry entries = 2 [json_name = "entries"];
inline int SendMessageResponse::_internal_entries_size() const {
  return entries_.size();
}
inline int SendMessageResponse::entries_size() const {
  return _internal_entries_size();
}
inline void SendMessageResponse::clear_entries() {
  entries_.Clear();
}
inline ::apache::rocketmq::v2::SendResultEntry* SendMessageResponse::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.SendMessageResponse.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::SendResultEntry >*
SendMessageResponse::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:apache.rocketmq.v2.SendMessageResponse.entries)
  return &entries_;
}
inline const ::apache::rocketmq::v2::SendResultEntry& SendMessageResponse::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::apache::rocketmq::v2::SendResultEntry& SendMessageResponse::entries(int index) const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.SendMessageResponse.entries)
  return _internal_entries(index);
}
inline ::apache::rocketmq::v2::SendResultEntry* SendMessageResponse::_internal_add_entries() {
  return entries_.Add();
}
inline ::apache::rocketmq::v2::SendResultEntry* SendMessageResponse::add_entries() {
  ::apache::rocketmq::v2::SendResultEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.SendMessageResponse.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::SendResultEntry >&
SendMessageResponse::entries() const {
  // @@protoc_insertion_point(field_list:apache.rocketmq.v2.SendMessageResponse.entries)
  return entries_;
}

// -------------------------------------------------------------------

// QueryAssignmentRequest

// .apache.rocketmq.v2.Resource topic = 1 [json_name = "topic"];
inline bool QueryAssignmentRequest::_internal_has_topic() const {
  return this != internal_default_instance() && topic_ != nullptr;
}
inline bool QueryAssignmentRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::apache::rocketmq::v2::Resource& QueryAssignmentRequest::_internal_topic() const {
  const ::apache::rocketmq::v2::Resource* p = topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& QueryAssignmentRequest::topic() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.QueryAssignmentRequest.topic)
  return _internal_topic();
}
inline void QueryAssignmentRequest::unsafe_arena_set_allocated_topic(
    ::apache::rocketmq::v2::Resource* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.QueryAssignmentRequest.topic)
}
inline ::apache::rocketmq::v2::Resource* QueryAssignmentRequest::release_topic() {
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* QueryAssignmentRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.QueryAssignmentRequest.topic)
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* QueryAssignmentRequest::_internal_mutable_topic() {
  
  if (topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    topic_ = p;
  }
  return topic_;
}
inline ::apache::rocketmq::v2::Resource* QueryAssignmentRequest::mutable_topic() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.QueryAssignmentRequest.topic)
  return _msg;
}
inline void QueryAssignmentRequest::set_allocated_topic(::apache::rocketmq::v2::Resource* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.QueryAssignmentRequest.topic)
}

// .apache.rocketmq.v2.Resource group = 2 [json_name = "group"];
inline bool QueryAssignmentRequest::_internal_has_group() const {
  return this != internal_default_instance() && group_ != nullptr;
}
inline bool QueryAssignmentRequest::has_group() const {
  return _internal_has_group();
}
inline const ::apache::rocketmq::v2::Resource& QueryAssignmentRequest::_internal_group() const {
  const ::apache::rocketmq::v2::Resource* p = group_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& QueryAssignmentRequest::group() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.QueryAssignmentRequest.group)
  return _internal_group();
}
inline void QueryAssignmentRequest::unsafe_arena_set_allocated_group(
    ::apache::rocketmq::v2::Resource* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.QueryAssignmentRequest.group)
}
inline ::apache::rocketmq::v2::Resource* QueryAssignmentRequest::release_group() {
  
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* QueryAssignmentRequest::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.QueryAssignmentRequest.group)
  
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* QueryAssignmentRequest::_internal_mutable_group() {
  
  if (group_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    group_ = p;
  }
  return group_;
}
inline ::apache::rocketmq::v2::Resource* QueryAssignmentRequest::mutable_group() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.QueryAssignmentRequest.group)
  return _msg;
}
inline void QueryAssignmentRequest::set_allocated_group(::apache::rocketmq::v2::Resource* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group));
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.QueryAssignmentRequest.group)
}

// .apache.rocketmq.v2.Endpoints endpoints = 3 [json_name = "endpoints"];
inline bool QueryAssignmentRequest::_internal_has_endpoints() const {
  return this != internal_default_instance() && endpoints_ != nullptr;
}
inline bool QueryAssignmentRequest::has_endpoints() const {
  return _internal_has_endpoints();
}
inline const ::apache::rocketmq::v2::Endpoints& QueryAssignmentRequest::_internal_endpoints() const {
  const ::apache::rocketmq::v2::Endpoints* p = endpoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Endpoints&>(
      ::apache::rocketmq::v2::_Endpoints_default_instance_);
}
inline const ::apache::rocketmq::v2::Endpoints& QueryAssignmentRequest::endpoints() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.QueryAssignmentRequest.endpoints)
  return _internal_endpoints();
}
inline void QueryAssignmentRequest::unsafe_arena_set_allocated_endpoints(
    ::apache::rocketmq::v2::Endpoints* endpoints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoints_);
  }
  endpoints_ = endpoints;
  if (endpoints) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.QueryAssignmentRequest.endpoints)
}
inline ::apache::rocketmq::v2::Endpoints* QueryAssignmentRequest::release_endpoints() {
  
  ::apache::rocketmq::v2::Endpoints* temp = endpoints_;
  endpoints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Endpoints* QueryAssignmentRequest::unsafe_arena_release_endpoints() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.QueryAssignmentRequest.endpoints)
  
  ::apache::rocketmq::v2::Endpoints* temp = endpoints_;
  endpoints_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Endpoints* QueryAssignmentRequest::_internal_mutable_endpoints() {
  
  if (endpoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Endpoints>(GetArenaForAllocation());
    endpoints_ = p;
  }
  return endpoints_;
}
inline ::apache::rocketmq::v2::Endpoints* QueryAssignmentRequest::mutable_endpoints() {
  ::apache::rocketmq::v2::Endpoints* _msg = _internal_mutable_endpoints();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.QueryAssignmentRequest.endpoints)
  return _msg;
}
inline void QueryAssignmentRequest::set_allocated_endpoints(::apache::rocketmq::v2::Endpoints* endpoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoints_);
  }
  if (endpoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoints));
    if (message_arena != submessage_arena) {
      endpoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoints, submessage_arena);
    }
    
  } else {
    
  }
  endpoints_ = endpoints;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.QueryAssignmentRequest.endpoints)
}

// -------------------------------------------------------------------

// QueryAssignmentResponse

// .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
inline bool QueryAssignmentResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool QueryAssignmentResponse::has_status() const {
  return _internal_has_status();
}
inline const ::apache::rocketmq::v2::Status& QueryAssignmentResponse::_internal_status() const {
  const ::apache::rocketmq::v2::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Status&>(
      ::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& QueryAssignmentResponse::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.QueryAssignmentResponse.status)
  return _internal_status();
}
inline void QueryAssignmentResponse::unsafe_arena_set_allocated_status(
    ::apache::rocketmq::v2::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.QueryAssignmentResponse.status)
}
inline ::apache::rocketmq::v2::Status* QueryAssignmentResponse::release_status() {
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Status* QueryAssignmentResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.QueryAssignmentResponse.status)
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Status* QueryAssignmentResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::apache::rocketmq::v2::Status* QueryAssignmentResponse::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.QueryAssignmentResponse.status)
  return _msg;
}
inline void QueryAssignmentResponse::set_allocated_status(::apache::rocketmq::v2::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.QueryAssignmentResponse.status)
}

// repeated .apache.rocketmq.v2.Assignment assignments = 2 [json_name = "assignments"];
inline int QueryAssignmentResponse::_internal_assignments_size() const {
  return assignments_.size();
}
inline int QueryAssignmentResponse::assignments_size() const {
  return _internal_assignments_size();
}
inline ::apache::rocketmq::v2::Assignment* QueryAssignmentResponse::mutable_assignments(int index) {
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.QueryAssignmentResponse.assignments)
  return assignments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Assignment >*
QueryAssignmentResponse::mutable_assignments() {
  // @@protoc_insertion_point(field_mutable_list:apache.rocketmq.v2.QueryAssignmentResponse.assignments)
  return &assignments_;
}
inline const ::apache::rocketmq::v2::Assignment& QueryAssignmentResponse::_internal_assignments(int index) const {
  return assignments_.Get(index);
}
inline const ::apache::rocketmq::v2::Assignment& QueryAssignmentResponse::assignments(int index) const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.QueryAssignmentResponse.assignments)
  return _internal_assignments(index);
}
inline ::apache::rocketmq::v2::Assignment* QueryAssignmentResponse::_internal_add_assignments() {
  return assignments_.Add();
}
inline ::apache::rocketmq::v2::Assignment* QueryAssignmentResponse::add_assignments() {
  ::apache::rocketmq::v2::Assignment* _add = _internal_add_assignments();
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.QueryAssignmentResponse.assignments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Assignment >&
QueryAssignmentResponse::assignments() const {
  // @@protoc_insertion_point(field_list:apache.rocketmq.v2.QueryAssignmentResponse.assignments)
  return assignments_;
}

// -------------------------------------------------------------------

// ReceiveMessageRequest

// .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
inline bool ReceiveMessageRequest::_internal_has_group() const {
  return this != internal_default_instance() && group_ != nullptr;
}
inline bool ReceiveMessageRequest::has_group() const {
  return _internal_has_group();
}
inline const ::apache::rocketmq::v2::Resource& ReceiveMessageRequest::_internal_group() const {
  const ::apache::rocketmq::v2::Resource* p = group_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& ReceiveMessageRequest::group() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ReceiveMessageRequest.group)
  return _internal_group();
}
inline void ReceiveMessageRequest::unsafe_arena_set_allocated_group(
    ::apache::rocketmq::v2::Resource* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ReceiveMessageRequest.group)
}
inline ::apache::rocketmq::v2::Resource* ReceiveMessageRequest::release_group() {
  
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* ReceiveMessageRequest::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ReceiveMessageRequest.group)
  
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* ReceiveMessageRequest::_internal_mutable_group() {
  
  if (group_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    group_ = p;
  }
  return group_;
}
inline ::apache::rocketmq::v2::Resource* ReceiveMessageRequest::mutable_group() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ReceiveMessageRequest.group)
  return _msg;
}
inline void ReceiveMessageRequest::set_allocated_group(::apache::rocketmq::v2::Resource* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group));
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ReceiveMessageRequest.group)
}

// .apache.rocketmq.v2.MessageQueue message_queue = 2 [json_name = "messageQueue"];
inline bool ReceiveMessageRequest::_internal_has_message_queue() const {
  return this != internal_default_instance() && message_queue_ != nullptr;
}
inline bool ReceiveMessageRequest::has_message_queue() const {
  return _internal_has_message_queue();
}
inline const ::apache::rocketmq::v2::MessageQueue& ReceiveMessageRequest::_internal_message_queue() const {
  const ::apache::rocketmq::v2::MessageQueue* p = message_queue_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::MessageQueue&>(
      ::apache::rocketmq::v2::_MessageQueue_default_instance_);
}
inline const ::apache::rocketmq::v2::MessageQueue& ReceiveMessageRequest::message_queue() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ReceiveMessageRequest.message_queue)
  return _internal_message_queue();
}
inline void ReceiveMessageRequest::unsafe_arena_set_allocated_message_queue(
    ::apache::rocketmq::v2::MessageQueue* message_queue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_queue_);
  }
  message_queue_ = message_queue;
  if (message_queue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ReceiveMessageRequest.message_queue)
}
inline ::apache::rocketmq::v2::MessageQueue* ReceiveMessageRequest::release_message_queue() {
  
  ::apache::rocketmq::v2::MessageQueue* temp = message_queue_;
  message_queue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::MessageQueue* ReceiveMessageRequest::unsafe_arena_release_message_queue() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ReceiveMessageRequest.message_queue)
  
  ::apache::rocketmq::v2::MessageQueue* temp = message_queue_;
  message_queue_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::MessageQueue* ReceiveMessageRequest::_internal_mutable_message_queue() {
  
  if (message_queue_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::MessageQueue>(GetArenaForAllocation());
    message_queue_ = p;
  }
  return message_queue_;
}
inline ::apache::rocketmq::v2::MessageQueue* ReceiveMessageRequest::mutable_message_queue() {
  ::apache::rocketmq::v2::MessageQueue* _msg = _internal_mutable_message_queue();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ReceiveMessageRequest.message_queue)
  return _msg;
}
inline void ReceiveMessageRequest::set_allocated_message_queue(::apache::rocketmq::v2::MessageQueue* message_queue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_queue_);
  }
  if (message_queue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_queue));
    if (message_arena != submessage_arena) {
      message_queue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message_queue, submessage_arena);
    }
    
  } else {
    
  }
  message_queue_ = message_queue;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ReceiveMessageRequest.message_queue)
}

// .apache.rocketmq.v2.FilterExpression filter_expression = 3 [json_name = "filterExpression"];
inline bool ReceiveMessageRequest::_internal_has_filter_expression() const {
  return this != internal_default_instance() && filter_expression_ != nullptr;
}
inline bool ReceiveMessageRequest::has_filter_expression() const {
  return _internal_has_filter_expression();
}
inline const ::apache::rocketmq::v2::FilterExpression& ReceiveMessageRequest::_internal_filter_expression() const {
  const ::apache::rocketmq::v2::FilterExpression* p = filter_expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::FilterExpression&>(
      ::apache::rocketmq::v2::_FilterExpression_default_instance_);
}
inline const ::apache::rocketmq::v2::FilterExpression& ReceiveMessageRequest::filter_expression() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ReceiveMessageRequest.filter_expression)
  return _internal_filter_expression();
}
inline void ReceiveMessageRequest::unsafe_arena_set_allocated_filter_expression(
    ::apache::rocketmq::v2::FilterExpression* filter_expression) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_expression_);
  }
  filter_expression_ = filter_expression;
  if (filter_expression) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ReceiveMessageRequest.filter_expression)
}
inline ::apache::rocketmq::v2::FilterExpression* ReceiveMessageRequest::release_filter_expression() {
  
  ::apache::rocketmq::v2::FilterExpression* temp = filter_expression_;
  filter_expression_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::FilterExpression* ReceiveMessageRequest::unsafe_arena_release_filter_expression() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ReceiveMessageRequest.filter_expression)
  
  ::apache::rocketmq::v2::FilterExpression* temp = filter_expression_;
  filter_expression_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::FilterExpression* ReceiveMessageRequest::_internal_mutable_filter_expression() {
  
  if (filter_expression_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::FilterExpression>(GetArenaForAllocation());
    filter_expression_ = p;
  }
  return filter_expression_;
}
inline ::apache::rocketmq::v2::FilterExpression* ReceiveMessageRequest::mutable_filter_expression() {
  ::apache::rocketmq::v2::FilterExpression* _msg = _internal_mutable_filter_expression();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ReceiveMessageRequest.filter_expression)
  return _msg;
}
inline void ReceiveMessageRequest::set_allocated_filter_expression(::apache::rocketmq::v2::FilterExpression* filter_expression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_expression_);
  }
  if (filter_expression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_expression));
    if (message_arena != submessage_arena) {
      filter_expression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter_expression, submessage_arena);
    }
    
  } else {
    
  }
  filter_expression_ = filter_expression;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ReceiveMessageRequest.filter_expression)
}

// int32 batch_size = 4 [json_name = "batchSize"];
inline void ReceiveMessageRequest::clear_batch_size() {
  batch_size_ = 0;
}
inline int32_t ReceiveMessageRequest::_internal_batch_size() const {
  return batch_size_;
}
inline int32_t ReceiveMessageRequest::batch_size() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ReceiveMessageRequest.batch_size)
  return _internal_batch_size();
}
inline void ReceiveMessageRequest::_internal_set_batch_size(int32_t value) {
  
  batch_size_ = value;
}
inline void ReceiveMessageRequest::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.ReceiveMessageRequest.batch_size)
}

// optional .google.protobuf.Duration invisible_duration = 5 [json_name = "invisibleDuration"];
inline bool ReceiveMessageRequest::_internal_has_invisible_duration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || invisible_duration_ != nullptr);
  return value;
}
inline bool ReceiveMessageRequest::has_invisible_duration() const {
  return _internal_has_invisible_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ReceiveMessageRequest::_internal_invisible_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = invisible_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ReceiveMessageRequest::invisible_duration() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ReceiveMessageRequest.invisible_duration)
  return _internal_invisible_duration();
}
inline void ReceiveMessageRequest::unsafe_arena_set_allocated_invisible_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invisible_duration_);
  }
  invisible_duration_ = invisible_duration;
  if (invisible_duration) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ReceiveMessageRequest.invisible_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ReceiveMessageRequest::release_invisible_duration() {
  _has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = invisible_duration_;
  invisible_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ReceiveMessageRequest::unsafe_arena_release_invisible_duration() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ReceiveMessageRequest.invisible_duration)
  _has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = invisible_duration_;
  invisible_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ReceiveMessageRequest::_internal_mutable_invisible_duration() {
  _has_bits_[0] |= 0x00000001u;
  if (invisible_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    invisible_duration_ = p;
  }
  return invisible_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ReceiveMessageRequest::mutable_invisible_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_invisible_duration();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ReceiveMessageRequest.invisible_duration)
  return _msg;
}
inline void ReceiveMessageRequest::set_allocated_invisible_duration(::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(invisible_duration_);
  }
  if (invisible_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invisible_duration));
    if (message_arena != submessage_arena) {
      invisible_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invisible_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  invisible_duration_ = invisible_duration;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ReceiveMessageRequest.invisible_duration)
}

// bool auto_renew = 6 [json_name = "autoRenew"];
inline void ReceiveMessageRequest::clear_auto_renew() {
  auto_renew_ = false;
}
inline bool ReceiveMessageRequest::_internal_auto_renew() const {
  return auto_renew_;
}
inline bool ReceiveMessageRequest::auto_renew() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ReceiveMessageRequest.auto_renew)
  return _internal_auto_renew();
}
inline void ReceiveMessageRequest::_internal_set_auto_renew(bool value) {
  
  auto_renew_ = value;
}
inline void ReceiveMessageRequest::set_auto_renew(bool value) {
  _internal_set_auto_renew(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.ReceiveMessageRequest.auto_renew)
}

// -------------------------------------------------------------------

// ReceiveMessageResponse

// .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
inline bool ReceiveMessageResponse::_internal_has_status() const {
  return content_case() == kStatus;
}
inline bool ReceiveMessageResponse::has_status() const {
  return _internal_has_status();
}
inline void ReceiveMessageResponse::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline ::apache::rocketmq::v2::Status* ReceiveMessageResponse::release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ReceiveMessageResponse.status)
  if (_internal_has_status()) {
    clear_has_content();
    ::apache::rocketmq::v2::Status* temp = content_.status_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apache::rocketmq::v2::Status& ReceiveMessageResponse::_internal_status() const {
  return _internal_has_status()
      ? *content_.status_
      : reinterpret_cast< ::apache::rocketmq::v2::Status&>(::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& ReceiveMessageResponse::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ReceiveMessageResponse.status)
  return _internal_status();
}
inline ::apache::rocketmq::v2::Status* ReceiveMessageResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.ReceiveMessageResponse.status)
  if (_internal_has_status()) {
    clear_has_content();
    ::apache::rocketmq::v2::Status* temp = content_.status_;
    content_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReceiveMessageResponse::unsafe_arena_set_allocated_status(::apache::rocketmq::v2::Status* status) {
  clear_content();
  if (status) {
    set_has_status();
    content_.status_ = status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ReceiveMessageResponse.status)
}
inline ::apache::rocketmq::v2::Status* ReceiveMessageResponse::_internal_mutable_status() {
  if (!_internal_has_status()) {
    clear_content();
    set_has_status();
    content_.status_ = CreateMaybeMessage< ::apache::rocketmq::v2::Status >(GetArenaForAllocation());
  }
  return content_.status_;
}
inline ::apache::rocketmq::v2::Status* ReceiveMessageResponse::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ReceiveMessageResponse.status)
  return _msg;
}

// .apache.rocketmq.v2.Message message = 2 [json_name = "message"];
inline bool ReceiveMessageResponse::_internal_has_message() const {
  return content_case() == kMessage;
}
inline bool ReceiveMessageResponse::has_message() const {
  return _internal_has_message();
}
inline void ReceiveMessageResponse::set_has_message() {
  _oneof_case_[0] = kMessage;
}
inline ::apache::rocketmq::v2::Message* ReceiveMessageResponse::release_message() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ReceiveMessageResponse.message)
  if (_internal_has_message()) {
    clear_has_content();
    ::apache::rocketmq::v2::Message* temp = content_.message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apache::rocketmq::v2::Message& ReceiveMessageResponse::_internal_message() const {
  return _internal_has_message()
      ? *content_.message_
      : reinterpret_cast< ::apache::rocketmq::v2::Message&>(::apache::rocketmq::v2::_Message_default_instance_);
}
inline const ::apache::rocketmq::v2::Message& ReceiveMessageResponse::message() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ReceiveMessageResponse.message)
  return _internal_message();
}
inline ::apache::rocketmq::v2::Message* ReceiveMessageResponse::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.ReceiveMessageResponse.message)
  if (_internal_has_message()) {
    clear_has_content();
    ::apache::rocketmq::v2::Message* temp = content_.message_;
    content_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReceiveMessageResponse::unsafe_arena_set_allocated_message(::apache::rocketmq::v2::Message* message) {
  clear_content();
  if (message) {
    set_has_message();
    content_.message_ = message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ReceiveMessageResponse.message)
}
inline ::apache::rocketmq::v2::Message* ReceiveMessageResponse::_internal_mutable_message() {
  if (!_internal_has_message()) {
    clear_content();
    set_has_message();
    content_.message_ = CreateMaybeMessage< ::apache::rocketmq::v2::Message >(GetArenaForAllocation());
  }
  return content_.message_;
}
inline ::apache::rocketmq::v2::Message* ReceiveMessageResponse::mutable_message() {
  ::apache::rocketmq::v2::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ReceiveMessageResponse.message)
  return _msg;
}

// .google.protobuf.Timestamp delivery_timestamp = 3 [json_name = "deliveryTimestamp"];
inline bool ReceiveMessageResponse::_internal_has_delivery_timestamp() const {
  return content_case() == kDeliveryTimestamp;
}
inline bool ReceiveMessageResponse::has_delivery_timestamp() const {
  return _internal_has_delivery_timestamp();
}
inline void ReceiveMessageResponse::set_has_delivery_timestamp() {
  _oneof_case_[0] = kDeliveryTimestamp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ReceiveMessageResponse::release_delivery_timestamp() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ReceiveMessageResponse.delivery_timestamp)
  if (_internal_has_delivery_timestamp()) {
    clear_has_content();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = content_.delivery_timestamp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.delivery_timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ReceiveMessageResponse::_internal_delivery_timestamp() const {
  return _internal_has_delivery_timestamp()
      ? *content_.delivery_timestamp_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Timestamp&>(::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ReceiveMessageResponse::delivery_timestamp() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ReceiveMessageResponse.delivery_timestamp)
  return _internal_delivery_timestamp();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ReceiveMessageResponse::unsafe_arena_release_delivery_timestamp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.ReceiveMessageResponse.delivery_timestamp)
  if (_internal_has_delivery_timestamp()) {
    clear_has_content();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = content_.delivery_timestamp_;
    content_.delivery_timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReceiveMessageResponse::unsafe_arena_set_allocated_delivery_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_timestamp) {
  clear_content();
  if (delivery_timestamp) {
    set_has_delivery_timestamp();
    content_.delivery_timestamp_ = delivery_timestamp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ReceiveMessageResponse.delivery_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ReceiveMessageResponse::_internal_mutable_delivery_timestamp() {
  if (!_internal_has_delivery_timestamp()) {
    clear_content();
    set_has_delivery_timestamp();
    content_.delivery_timestamp_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Timestamp >(GetArenaForAllocation());
  }
  return content_.delivery_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ReceiveMessageResponse::mutable_delivery_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_delivery_timestamp();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ReceiveMessageResponse.delivery_timestamp)
  return _msg;
}

inline bool ReceiveMessageResponse::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void ReceiveMessageResponse::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline ReceiveMessageResponse::ContentCase ReceiveMessageResponse::content_case() const {
  return ReceiveMessageResponse::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AckMessageEntry

// string message_id = 1 [json_name = "messageId"];
inline void AckMessageEntry::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& AckMessageEntry::message_id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.AckMessageEntry.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AckMessageEntry::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.AckMessageEntry.message_id)
}
inline std::string* AckMessageEntry::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.AckMessageEntry.message_id)
  return _s;
}
inline const std::string& AckMessageEntry::_internal_message_id() const {
  return message_id_.Get();
}
inline void AckMessageEntry::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AckMessageEntry::_internal_mutable_message_id() {
  
  return message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AckMessageEntry::release_message_id() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.AckMessageEntry.message_id)
  return message_id_.Release();
}
inline void AckMessageEntry::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_id_.IsDefault()) {
    message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.AckMessageEntry.message_id)
}

// string receipt_handle = 2 [json_name = "receiptHandle"];
inline void AckMessageEntry::clear_receipt_handle() {
  receipt_handle_.ClearToEmpty();
}
inline const std::string& AckMessageEntry::receipt_handle() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.AckMessageEntry.receipt_handle)
  return _internal_receipt_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AckMessageEntry::set_receipt_handle(ArgT0&& arg0, ArgT... args) {
 
 receipt_handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.AckMessageEntry.receipt_handle)
}
inline std::string* AckMessageEntry::mutable_receipt_handle() {
  std::string* _s = _internal_mutable_receipt_handle();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.AckMessageEntry.receipt_handle)
  return _s;
}
inline const std::string& AckMessageEntry::_internal_receipt_handle() const {
  return receipt_handle_.Get();
}
inline void AckMessageEntry::_internal_set_receipt_handle(const std::string& value) {
  
  receipt_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* AckMessageEntry::_internal_mutable_receipt_handle() {
  
  return receipt_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* AckMessageEntry::release_receipt_handle() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.AckMessageEntry.receipt_handle)
  return receipt_handle_.Release();
}
inline void AckMessageEntry::set_allocated_receipt_handle(std::string* receipt_handle) {
  if (receipt_handle != nullptr) {
    
  } else {
    
  }
  receipt_handle_.SetAllocated(receipt_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receipt_handle_.IsDefault()) {
    receipt_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.AckMessageEntry.receipt_handle)
}

// -------------------------------------------------------------------

// AckMessageRequest

// .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
inline bool AckMessageRequest::_internal_has_group() const {
  return this != internal_default_instance() && group_ != nullptr;
}
inline bool AckMessageRequest::has_group() const {
  return _internal_has_group();
}
inline const ::apache::rocketmq::v2::Resource& AckMessageRequest::_internal_group() const {
  const ::apache::rocketmq::v2::Resource* p = group_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& AckMessageRequest::group() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.AckMessageRequest.group)
  return _internal_group();
}
inline void AckMessageRequest::unsafe_arena_set_allocated_group(
    ::apache::rocketmq::v2::Resource* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.AckMessageRequest.group)
}
inline ::apache::rocketmq::v2::Resource* AckMessageRequest::release_group() {
  
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* AckMessageRequest::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.AckMessageRequest.group)
  
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* AckMessageRequest::_internal_mutable_group() {
  
  if (group_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    group_ = p;
  }
  return group_;
}
inline ::apache::rocketmq::v2::Resource* AckMessageRequest::mutable_group() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.AckMessageRequest.group)
  return _msg;
}
inline void AckMessageRequest::set_allocated_group(::apache::rocketmq::v2::Resource* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group));
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.AckMessageRequest.group)
}

// .apache.rocketmq.v2.Resource topic = 2 [json_name = "topic"];
inline bool AckMessageRequest::_internal_has_topic() const {
  return this != internal_default_instance() && topic_ != nullptr;
}
inline bool AckMessageRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::apache::rocketmq::v2::Resource& AckMessageRequest::_internal_topic() const {
  const ::apache::rocketmq::v2::Resource* p = topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& AckMessageRequest::topic() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.AckMessageRequest.topic)
  return _internal_topic();
}
inline void AckMessageRequest::unsafe_arena_set_allocated_topic(
    ::apache::rocketmq::v2::Resource* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.AckMessageRequest.topic)
}
inline ::apache::rocketmq::v2::Resource* AckMessageRequest::release_topic() {
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* AckMessageRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.AckMessageRequest.topic)
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* AckMessageRequest::_internal_mutable_topic() {
  
  if (topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    topic_ = p;
  }
  return topic_;
}
inline ::apache::rocketmq::v2::Resource* AckMessageRequest::mutable_topic() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.AckMessageRequest.topic)
  return _msg;
}
inline void AckMessageRequest::set_allocated_topic(::apache::rocketmq::v2::Resource* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.AckMessageRequest.topic)
}

// repeated .apache.rocketmq.v2.AckMessageEntry entries = 3 [json_name = "entries"];
inline int AckMessageRequest::_internal_entries_size() const {
  return entries_.size();
}
inline int AckMessageRequest::entries_size() const {
  return _internal_entries_size();
}
inline void AckMessageRequest::clear_entries() {
  entries_.Clear();
}
inline ::apache::rocketmq::v2::AckMessageEntry* AckMessageRequest::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.AckMessageRequest.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::AckMessageEntry >*
AckMessageRequest::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:apache.rocketmq.v2.AckMessageRequest.entries)
  return &entries_;
}
inline const ::apache::rocketmq::v2::AckMessageEntry& AckMessageRequest::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::apache::rocketmq::v2::AckMessageEntry& AckMessageRequest::entries(int index) const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.AckMessageRequest.entries)
  return _internal_entries(index);
}
inline ::apache::rocketmq::v2::AckMessageEntry* AckMessageRequest::_internal_add_entries() {
  return entries_.Add();
}
inline ::apache::rocketmq::v2::AckMessageEntry* AckMessageRequest::add_entries() {
  ::apache::rocketmq::v2::AckMessageEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.AckMessageRequest.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::AckMessageEntry >&
AckMessageRequest::entries() const {
  // @@protoc_insertion_point(field_list:apache.rocketmq.v2.AckMessageRequest.entries)
  return entries_;
}

// -------------------------------------------------------------------

// AckMessageResultEntry

// string message_id = 1 [json_name = "messageId"];
inline void AckMessageResultEntry::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& AckMessageResultEntry::message_id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.AckMessageResultEntry.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AckMessageResultEntry::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.AckMessageResultEntry.message_id)
}
inline std::string* AckMessageResultEntry::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.AckMessageResultEntry.message_id)
  return _s;
}
inline const std::string& AckMessageResultEntry::_internal_message_id() const {
  return message_id_.Get();
}
inline void AckMessageResultEntry::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AckMessageResultEntry::_internal_mutable_message_id() {
  
  return message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AckMessageResultEntry::release_message_id() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.AckMessageResultEntry.message_id)
  return message_id_.Release();
}
inline void AckMessageResultEntry::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_id_.IsDefault()) {
    message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.AckMessageResultEntry.message_id)
}

// string receipt_handle = 2 [json_name = "receiptHandle"];
inline void AckMessageResultEntry::clear_receipt_handle() {
  receipt_handle_.ClearToEmpty();
}
inline const std::string& AckMessageResultEntry::receipt_handle() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.AckMessageResultEntry.receipt_handle)
  return _internal_receipt_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AckMessageResultEntry::set_receipt_handle(ArgT0&& arg0, ArgT... args) {
 
 receipt_handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.AckMessageResultEntry.receipt_handle)
}
inline std::string* AckMessageResultEntry::mutable_receipt_handle() {
  std::string* _s = _internal_mutable_receipt_handle();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.AckMessageResultEntry.receipt_handle)
  return _s;
}
inline const std::string& AckMessageResultEntry::_internal_receipt_handle() const {
  return receipt_handle_.Get();
}
inline void AckMessageResultEntry::_internal_set_receipt_handle(const std::string& value) {
  
  receipt_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* AckMessageResultEntry::_internal_mutable_receipt_handle() {
  
  return receipt_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* AckMessageResultEntry::release_receipt_handle() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.AckMessageResultEntry.receipt_handle)
  return receipt_handle_.Release();
}
inline void AckMessageResultEntry::set_allocated_receipt_handle(std::string* receipt_handle) {
  if (receipt_handle != nullptr) {
    
  } else {
    
  }
  receipt_handle_.SetAllocated(receipt_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receipt_handle_.IsDefault()) {
    receipt_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.AckMessageResultEntry.receipt_handle)
}

// .apache.rocketmq.v2.Status status = 3 [json_name = "status"];
inline bool AckMessageResultEntry::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool AckMessageResultEntry::has_status() const {
  return _internal_has_status();
}
inline const ::apache::rocketmq::v2::Status& AckMessageResultEntry::_internal_status() const {
  const ::apache::rocketmq::v2::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Status&>(
      ::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& AckMessageResultEntry::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.AckMessageResultEntry.status)
  return _internal_status();
}
inline void AckMessageResultEntry::unsafe_arena_set_allocated_status(
    ::apache::rocketmq::v2::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.AckMessageResultEntry.status)
}
inline ::apache::rocketmq::v2::Status* AckMessageResultEntry::release_status() {
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Status* AckMessageResultEntry::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.AckMessageResultEntry.status)
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Status* AckMessageResultEntry::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::apache::rocketmq::v2::Status* AckMessageResultEntry::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.AckMessageResultEntry.status)
  return _msg;
}
inline void AckMessageResultEntry::set_allocated_status(::apache::rocketmq::v2::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.AckMessageResultEntry.status)
}

// -------------------------------------------------------------------

// AckMessageResponse

// .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
inline bool AckMessageResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool AckMessageResponse::has_status() const {
  return _internal_has_status();
}
inline const ::apache::rocketmq::v2::Status& AckMessageResponse::_internal_status() const {
  const ::apache::rocketmq::v2::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Status&>(
      ::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& AckMessageResponse::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.AckMessageResponse.status)
  return _internal_status();
}
inline void AckMessageResponse::unsafe_arena_set_allocated_status(
    ::apache::rocketmq::v2::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.AckMessageResponse.status)
}
inline ::apache::rocketmq::v2::Status* AckMessageResponse::release_status() {
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Status* AckMessageResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.AckMessageResponse.status)
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Status* AckMessageResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::apache::rocketmq::v2::Status* AckMessageResponse::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.AckMessageResponse.status)
  return _msg;
}
inline void AckMessageResponse::set_allocated_status(::apache::rocketmq::v2::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.AckMessageResponse.status)
}

// repeated .apache.rocketmq.v2.AckMessageResultEntry entries = 2 [json_name = "entries"];
inline int AckMessageResponse::_internal_entries_size() const {
  return entries_.size();
}
inline int AckMessageResponse::entries_size() const {
  return _internal_entries_size();
}
inline void AckMessageResponse::clear_entries() {
  entries_.Clear();
}
inline ::apache::rocketmq::v2::AckMessageResultEntry* AckMessageResponse::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.AckMessageResponse.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::AckMessageResultEntry >*
AckMessageResponse::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:apache.rocketmq.v2.AckMessageResponse.entries)
  return &entries_;
}
inline const ::apache::rocketmq::v2::AckMessageResultEntry& AckMessageResponse::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::apache::rocketmq::v2::AckMessageResultEntry& AckMessageResponse::entries(int index) const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.AckMessageResponse.entries)
  return _internal_entries(index);
}
inline ::apache::rocketmq::v2::AckMessageResultEntry* AckMessageResponse::_internal_add_entries() {
  return entries_.Add();
}
inline ::apache::rocketmq::v2::AckMessageResultEntry* AckMessageResponse::add_entries() {
  ::apache::rocketmq::v2::AckMessageResultEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.AckMessageResponse.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::AckMessageResultEntry >&
AckMessageResponse::entries() const {
  // @@protoc_insertion_point(field_list:apache.rocketmq.v2.AckMessageResponse.entries)
  return entries_;
}

// -------------------------------------------------------------------

// ForwardMessageToDeadLetterQueueRequest

// .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
inline bool ForwardMessageToDeadLetterQueueRequest::_internal_has_group() const {
  return this != internal_default_instance() && group_ != nullptr;
}
inline bool ForwardMessageToDeadLetterQueueRequest::has_group() const {
  return _internal_has_group();
}
inline const ::apache::rocketmq::v2::Resource& ForwardMessageToDeadLetterQueueRequest::_internal_group() const {
  const ::apache::rocketmq::v2::Resource* p = group_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& ForwardMessageToDeadLetterQueueRequest::group() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.group)
  return _internal_group();
}
inline void ForwardMessageToDeadLetterQueueRequest::unsafe_arena_set_allocated_group(
    ::apache::rocketmq::v2::Resource* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.group)
}
inline ::apache::rocketmq::v2::Resource* ForwardMessageToDeadLetterQueueRequest::release_group() {
  
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* ForwardMessageToDeadLetterQueueRequest::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.group)
  
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* ForwardMessageToDeadLetterQueueRequest::_internal_mutable_group() {
  
  if (group_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    group_ = p;
  }
  return group_;
}
inline ::apache::rocketmq::v2::Resource* ForwardMessageToDeadLetterQueueRequest::mutable_group() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.group)
  return _msg;
}
inline void ForwardMessageToDeadLetterQueueRequest::set_allocated_group(::apache::rocketmq::v2::Resource* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group));
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.group)
}

// .apache.rocketmq.v2.Resource topic = 2 [json_name = "topic"];
inline bool ForwardMessageToDeadLetterQueueRequest::_internal_has_topic() const {
  return this != internal_default_instance() && topic_ != nullptr;
}
inline bool ForwardMessageToDeadLetterQueueRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::apache::rocketmq::v2::Resource& ForwardMessageToDeadLetterQueueRequest::_internal_topic() const {
  const ::apache::rocketmq::v2::Resource* p = topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& ForwardMessageToDeadLetterQueueRequest::topic() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.topic)
  return _internal_topic();
}
inline void ForwardMessageToDeadLetterQueueRequest::unsafe_arena_set_allocated_topic(
    ::apache::rocketmq::v2::Resource* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.topic)
}
inline ::apache::rocketmq::v2::Resource* ForwardMessageToDeadLetterQueueRequest::release_topic() {
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* ForwardMessageToDeadLetterQueueRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.topic)
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* ForwardMessageToDeadLetterQueueRequest::_internal_mutable_topic() {
  
  if (topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    topic_ = p;
  }
  return topic_;
}
inline ::apache::rocketmq::v2::Resource* ForwardMessageToDeadLetterQueueRequest::mutable_topic() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.topic)
  return _msg;
}
inline void ForwardMessageToDeadLetterQueueRequest::set_allocated_topic(::apache::rocketmq::v2::Resource* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.topic)
}

// string receipt_handle = 3 [json_name = "receiptHandle"];
inline void ForwardMessageToDeadLetterQueueRequest::clear_receipt_handle() {
  receipt_handle_.ClearToEmpty();
}
inline const std::string& ForwardMessageToDeadLetterQueueRequest::receipt_handle() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.receipt_handle)
  return _internal_receipt_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForwardMessageToDeadLetterQueueRequest::set_receipt_handle(ArgT0&& arg0, ArgT... args) {
 
 receipt_handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.receipt_handle)
}
inline std::string* ForwardMessageToDeadLetterQueueRequest::mutable_receipt_handle() {
  std::string* _s = _internal_mutable_receipt_handle();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.receipt_handle)
  return _s;
}
inline const std::string& ForwardMessageToDeadLetterQueueRequest::_internal_receipt_handle() const {
  return receipt_handle_.Get();
}
inline void ForwardMessageToDeadLetterQueueRequest::_internal_set_receipt_handle(const std::string& value) {
  
  receipt_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* ForwardMessageToDeadLetterQueueRequest::_internal_mutable_receipt_handle() {
  
  return receipt_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* ForwardMessageToDeadLetterQueueRequest::release_receipt_handle() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.receipt_handle)
  return receipt_handle_.Release();
}
inline void ForwardMessageToDeadLetterQueueRequest::set_allocated_receipt_handle(std::string* receipt_handle) {
  if (receipt_handle != nullptr) {
    
  } else {
    
  }
  receipt_handle_.SetAllocated(receipt_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receipt_handle_.IsDefault()) {
    receipt_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.receipt_handle)
}

// string message_id = 4 [json_name = "messageId"];
inline void ForwardMessageToDeadLetterQueueRequest::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& ForwardMessageToDeadLetterQueueRequest::message_id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForwardMessageToDeadLetterQueueRequest::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.message_id)
}
inline std::string* ForwardMessageToDeadLetterQueueRequest::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.message_id)
  return _s;
}
inline const std::string& ForwardMessageToDeadLetterQueueRequest::_internal_message_id() const {
  return message_id_.Get();
}
inline void ForwardMessageToDeadLetterQueueRequest::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ForwardMessageToDeadLetterQueueRequest::_internal_mutable_message_id() {
  
  return message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ForwardMessageToDeadLetterQueueRequest::release_message_id() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.message_id)
  return message_id_.Release();
}
inline void ForwardMessageToDeadLetterQueueRequest::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_id_.IsDefault()) {
    message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.message_id)
}

// int32 delivery_attempt = 5 [json_name = "deliveryAttempt"];
inline void ForwardMessageToDeadLetterQueueRequest::clear_delivery_attempt() {
  delivery_attempt_ = 0;
}
inline int32_t ForwardMessageToDeadLetterQueueRequest::_internal_delivery_attempt() const {
  return delivery_attempt_;
}
inline int32_t ForwardMessageToDeadLetterQueueRequest::delivery_attempt() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.delivery_attempt)
  return _internal_delivery_attempt();
}
inline void ForwardMessageToDeadLetterQueueRequest::_internal_set_delivery_attempt(int32_t value) {
  
  delivery_attempt_ = value;
}
inline void ForwardMessageToDeadLetterQueueRequest::set_delivery_attempt(int32_t value) {
  _internal_set_delivery_attempt(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.delivery_attempt)
}

// int32 max_delivery_attempts = 6 [json_name = "maxDeliveryAttempts"];
inline void ForwardMessageToDeadLetterQueueRequest::clear_max_delivery_attempts() {
  max_delivery_attempts_ = 0;
}
inline int32_t ForwardMessageToDeadLetterQueueRequest::_internal_max_delivery_attempts() const {
  return max_delivery_attempts_;
}
inline int32_t ForwardMessageToDeadLetterQueueRequest::max_delivery_attempts() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.max_delivery_attempts)
  return _internal_max_delivery_attempts();
}
inline void ForwardMessageToDeadLetterQueueRequest::_internal_set_max_delivery_attempts(int32_t value) {
  
  max_delivery_attempts_ = value;
}
inline void ForwardMessageToDeadLetterQueueRequest::set_max_delivery_attempts(int32_t value) {
  _internal_set_max_delivery_attempts(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueRequest.max_delivery_attempts)
}

// -------------------------------------------------------------------

// ForwardMessageToDeadLetterQueueResponse

// .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
inline bool ForwardMessageToDeadLetterQueueResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool ForwardMessageToDeadLetterQueueResponse::has_status() const {
  return _internal_has_status();
}
inline const ::apache::rocketmq::v2::Status& ForwardMessageToDeadLetterQueueResponse::_internal_status() const {
  const ::apache::rocketmq::v2::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Status&>(
      ::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& ForwardMessageToDeadLetterQueueResponse::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueResponse.status)
  return _internal_status();
}
inline void ForwardMessageToDeadLetterQueueResponse::unsafe_arena_set_allocated_status(
    ::apache::rocketmq::v2::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueResponse.status)
}
inline ::apache::rocketmq::v2::Status* ForwardMessageToDeadLetterQueueResponse::release_status() {
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Status* ForwardMessageToDeadLetterQueueResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueResponse.status)
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Status* ForwardMessageToDeadLetterQueueResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::apache::rocketmq::v2::Status* ForwardMessageToDeadLetterQueueResponse::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueResponse.status)
  return _msg;
}
inline void ForwardMessageToDeadLetterQueueResponse::set_allocated_status(::apache::rocketmq::v2::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ForwardMessageToDeadLetterQueueResponse.status)
}

// -------------------------------------------------------------------

// HeartbeatRequest

// optional .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
inline bool HeartbeatRequest::_internal_has_group() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || group_ != nullptr);
  return value;
}
inline bool HeartbeatRequest::has_group() const {
  return _internal_has_group();
}
inline const ::apache::rocketmq::v2::Resource& HeartbeatRequest::_internal_group() const {
  const ::apache::rocketmq::v2::Resource* p = group_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& HeartbeatRequest::group() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.HeartbeatRequest.group)
  return _internal_group();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_group(
    ::apache::rocketmq::v2::Resource* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  group_ = group;
  if (group) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.HeartbeatRequest.group)
}
inline ::apache::rocketmq::v2::Resource* HeartbeatRequest::release_group() {
  _has_bits_[0] &= ~0x00000001u;
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* HeartbeatRequest::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.HeartbeatRequest.group)
  _has_bits_[0] &= ~0x00000001u;
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* HeartbeatRequest::_internal_mutable_group() {
  _has_bits_[0] |= 0x00000001u;
  if (group_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    group_ = p;
  }
  return group_;
}
inline ::apache::rocketmq::v2::Resource* HeartbeatRequest::mutable_group() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.HeartbeatRequest.group)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_group(::apache::rocketmq::v2::Resource* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group));
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.HeartbeatRequest.group)
}

// .apache.rocketmq.v2.ClientType client_type = 2 [json_name = "clientType"];
inline void HeartbeatRequest::clear_client_type() {
  client_type_ = 0;
}
inline ::apache::rocketmq::v2::ClientType HeartbeatRequest::_internal_client_type() const {
  return static_cast< ::apache::rocketmq::v2::ClientType >(client_type_);
}
inline ::apache::rocketmq::v2::ClientType HeartbeatRequest::client_type() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.HeartbeatRequest.client_type)
  return _internal_client_type();
}
inline void HeartbeatRequest::_internal_set_client_type(::apache::rocketmq::v2::ClientType value) {
  
  client_type_ = value;
}
inline void HeartbeatRequest::set_client_type(::apache::rocketmq::v2::ClientType value) {
  _internal_set_client_type(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.HeartbeatRequest.client_type)
}

// -------------------------------------------------------------------

// HeartbeatResponse

// .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
inline bool HeartbeatResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool HeartbeatResponse::has_status() const {
  return _internal_has_status();
}
inline const ::apache::rocketmq::v2::Status& HeartbeatResponse::_internal_status() const {
  const ::apache::rocketmq::v2::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Status&>(
      ::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& HeartbeatResponse::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.HeartbeatResponse.status)
  return _internal_status();
}
inline void HeartbeatResponse::unsafe_arena_set_allocated_status(
    ::apache::rocketmq::v2::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.HeartbeatResponse.status)
}
inline ::apache::rocketmq::v2::Status* HeartbeatResponse::release_status() {
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Status* HeartbeatResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.HeartbeatResponse.status)
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Status* HeartbeatResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::apache::rocketmq::v2::Status* HeartbeatResponse::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.HeartbeatResponse.status)
  return _msg;
}
inline void HeartbeatResponse::set_allocated_status(::apache::rocketmq::v2::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.HeartbeatResponse.status)
}

// -------------------------------------------------------------------

// EndTransactionRequest

// .apache.rocketmq.v2.Resource topic = 1 [json_name = "topic"];
inline bool EndTransactionRequest::_internal_has_topic() const {
  return this != internal_default_instance() && topic_ != nullptr;
}
inline bool EndTransactionRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::apache::rocketmq::v2::Resource& EndTransactionRequest::_internal_topic() const {
  const ::apache::rocketmq::v2::Resource* p = topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& EndTransactionRequest::topic() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.EndTransactionRequest.topic)
  return _internal_topic();
}
inline void EndTransactionRequest::unsafe_arena_set_allocated_topic(
    ::apache::rocketmq::v2::Resource* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.EndTransactionRequest.topic)
}
inline ::apache::rocketmq::v2::Resource* EndTransactionRequest::release_topic() {
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* EndTransactionRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.EndTransactionRequest.topic)
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* EndTransactionRequest::_internal_mutable_topic() {
  
  if (topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    topic_ = p;
  }
  return topic_;
}
inline ::apache::rocketmq::v2::Resource* EndTransactionRequest::mutable_topic() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.EndTransactionRequest.topic)
  return _msg;
}
inline void EndTransactionRequest::set_allocated_topic(::apache::rocketmq::v2::Resource* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.EndTransactionRequest.topic)
}

// string message_id = 2 [json_name = "messageId"];
inline void EndTransactionRequest::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& EndTransactionRequest::message_id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.EndTransactionRequest.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EndTransactionRequest::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.EndTransactionRequest.message_id)
}
inline std::string* EndTransactionRequest::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.EndTransactionRequest.message_id)
  return _s;
}
inline const std::string& EndTransactionRequest::_internal_message_id() const {
  return message_id_.Get();
}
inline void EndTransactionRequest::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EndTransactionRequest::_internal_mutable_message_id() {
  
  return message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EndTransactionRequest::release_message_id() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.EndTransactionRequest.message_id)
  return message_id_.Release();
}
inline void EndTransactionRequest::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_id_.IsDefault()) {
    message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.EndTransactionRequest.message_id)
}

// string transaction_id = 3 [json_name = "transactionId"];
inline void EndTransactionRequest::clear_transaction_id() {
  transaction_id_.ClearToEmpty();
}
inline const std::string& EndTransactionRequest::transaction_id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.EndTransactionRequest.transaction_id)
  return _internal_transaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EndTransactionRequest::set_transaction_id(ArgT0&& arg0, ArgT... args) {
 
 transaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.EndTransactionRequest.transaction_id)
}
inline std::string* EndTransactionRequest::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.EndTransactionRequest.transaction_id)
  return _s;
}
inline const std::string& EndTransactionRequest::_internal_transaction_id() const {
  return transaction_id_.Get();
}
inline void EndTransactionRequest::_internal_set_transaction_id(const std::string& value) {
  
  transaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EndTransactionRequest::_internal_mutable_transaction_id() {
  
  return transaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EndTransactionRequest::release_transaction_id() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.EndTransactionRequest.transaction_id)
  return transaction_id_.Release();
}
inline void EndTransactionRequest::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    
  } else {
    
  }
  transaction_id_.SetAllocated(transaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transaction_id_.IsDefault()) {
    transaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.EndTransactionRequest.transaction_id)
}

// .apache.rocketmq.v2.TransactionResolution resolution = 4 [json_name = "resolution"];
inline void EndTransactionRequest::clear_resolution() {
  resolution_ = 0;
}
inline ::apache::rocketmq::v2::TransactionResolution EndTransactionRequest::_internal_resolution() const {
  return static_cast< ::apache::rocketmq::v2::TransactionResolution >(resolution_);
}
inline ::apache::rocketmq::v2::TransactionResolution EndTransactionRequest::resolution() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.EndTransactionRequest.resolution)
  return _internal_resolution();
}
inline void EndTransactionRequest::_internal_set_resolution(::apache::rocketmq::v2::TransactionResolution value) {
  
  resolution_ = value;
}
inline void EndTransactionRequest::set_resolution(::apache::rocketmq::v2::TransactionResolution value) {
  _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.EndTransactionRequest.resolution)
}

// .apache.rocketmq.v2.TransactionSource source = 5 [json_name = "source"];
inline void EndTransactionRequest::clear_source() {
  source_ = 0;
}
inline ::apache::rocketmq::v2::TransactionSource EndTransactionRequest::_internal_source() const {
  return static_cast< ::apache::rocketmq::v2::TransactionSource >(source_);
}
inline ::apache::rocketmq::v2::TransactionSource EndTransactionRequest::source() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.EndTransactionRequest.source)
  return _internal_source();
}
inline void EndTransactionRequest::_internal_set_source(::apache::rocketmq::v2::TransactionSource value) {
  
  source_ = value;
}
inline void EndTransactionRequest::set_source(::apache::rocketmq::v2::TransactionSource value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.EndTransactionRequest.source)
}

// string trace_context = 6 [json_name = "traceContext"];
inline void EndTransactionRequest::clear_trace_context() {
  trace_context_.ClearToEmpty();
}
inline const std::string& EndTransactionRequest::trace_context() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.EndTransactionRequest.trace_context)
  return _internal_trace_context();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EndTransactionRequest::set_trace_context(ArgT0&& arg0, ArgT... args) {
 
 trace_context_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.EndTransactionRequest.trace_context)
}
inline std::string* EndTransactionRequest::mutable_trace_context() {
  std::string* _s = _internal_mutable_trace_context();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.EndTransactionRequest.trace_context)
  return _s;
}
inline const std::string& EndTransactionRequest::_internal_trace_context() const {
  return trace_context_.Get();
}
inline void EndTransactionRequest::_internal_set_trace_context(const std::string& value) {
  
  trace_context_.Set(value, GetArenaForAllocation());
}
inline std::string* EndTransactionRequest::_internal_mutable_trace_context() {
  
  return trace_context_.Mutable(GetArenaForAllocation());
}
inline std::string* EndTransactionRequest::release_trace_context() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.EndTransactionRequest.trace_context)
  return trace_context_.Release();
}
inline void EndTransactionRequest::set_allocated_trace_context(std::string* trace_context) {
  if (trace_context != nullptr) {
    
  } else {
    
  }
  trace_context_.SetAllocated(trace_context, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trace_context_.IsDefault()) {
    trace_context_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.EndTransactionRequest.trace_context)
}

// -------------------------------------------------------------------

// EndTransactionResponse

// .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
inline bool EndTransactionResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool EndTransactionResponse::has_status() const {
  return _internal_has_status();
}
inline const ::apache::rocketmq::v2::Status& EndTransactionResponse::_internal_status() const {
  const ::apache::rocketmq::v2::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Status&>(
      ::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& EndTransactionResponse::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.EndTransactionResponse.status)
  return _internal_status();
}
inline void EndTransactionResponse::unsafe_arena_set_allocated_status(
    ::apache::rocketmq::v2::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.EndTransactionResponse.status)
}
inline ::apache::rocketmq::v2::Status* EndTransactionResponse::release_status() {
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Status* EndTransactionResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.EndTransactionResponse.status)
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Status* EndTransactionResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::apache::rocketmq::v2::Status* EndTransactionResponse::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.EndTransactionResponse.status)
  return _msg;
}
inline void EndTransactionResponse::set_allocated_status(::apache::rocketmq::v2::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.EndTransactionResponse.status)
}

// -------------------------------------------------------------------

// PrintThreadStackTraceCommand

// string nonce = 1 [json_name = "nonce"];
inline void PrintThreadStackTraceCommand::clear_nonce() {
  nonce_.ClearToEmpty();
}
inline const std::string& PrintThreadStackTraceCommand::nonce() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.PrintThreadStackTraceCommand.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrintThreadStackTraceCommand::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 nonce_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.PrintThreadStackTraceCommand.nonce)
}
inline std::string* PrintThreadStackTraceCommand::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.PrintThreadStackTraceCommand.nonce)
  return _s;
}
inline const std::string& PrintThreadStackTraceCommand::_internal_nonce() const {
  return nonce_.Get();
}
inline void PrintThreadStackTraceCommand::_internal_set_nonce(const std::string& value) {
  
  nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* PrintThreadStackTraceCommand::_internal_mutable_nonce() {
  
  return nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* PrintThreadStackTraceCommand::release_nonce() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.PrintThreadStackTraceCommand.nonce)
  return nonce_.Release();
}
inline void PrintThreadStackTraceCommand::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nonce_.IsDefault()) {
    nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.PrintThreadStackTraceCommand.nonce)
}

// -------------------------------------------------------------------

// ThreadStackTrace

// string nonce = 1 [json_name = "nonce"];
inline void ThreadStackTrace::clear_nonce() {
  nonce_.ClearToEmpty();
}
inline const std::string& ThreadStackTrace::nonce() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ThreadStackTrace.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThreadStackTrace::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 nonce_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.ThreadStackTrace.nonce)
}
inline std::string* ThreadStackTrace::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ThreadStackTrace.nonce)
  return _s;
}
inline const std::string& ThreadStackTrace::_internal_nonce() const {
  return nonce_.Get();
}
inline void ThreadStackTrace::_internal_set_nonce(const std::string& value) {
  
  nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* ThreadStackTrace::_internal_mutable_nonce() {
  
  return nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* ThreadStackTrace::release_nonce() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ThreadStackTrace.nonce)
  return nonce_.Release();
}
inline void ThreadStackTrace::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nonce_.IsDefault()) {
    nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ThreadStackTrace.nonce)
}

// optional string thread_stack_trace = 2 [json_name = "threadStackTrace"];
inline bool ThreadStackTrace::_internal_has_thread_stack_trace() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ThreadStackTrace::has_thread_stack_trace() const {
  return _internal_has_thread_stack_trace();
}
inline void ThreadStackTrace::clear_thread_stack_trace() {
  thread_stack_trace_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ThreadStackTrace::thread_stack_trace() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ThreadStackTrace.thread_stack_trace)
  return _internal_thread_stack_trace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThreadStackTrace::set_thread_stack_trace(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 thread_stack_trace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.ThreadStackTrace.thread_stack_trace)
}
inline std::string* ThreadStackTrace::mutable_thread_stack_trace() {
  std::string* _s = _internal_mutable_thread_stack_trace();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ThreadStackTrace.thread_stack_trace)
  return _s;
}
inline const std::string& ThreadStackTrace::_internal_thread_stack_trace() const {
  return thread_stack_trace_.Get();
}
inline void ThreadStackTrace::_internal_set_thread_stack_trace(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  thread_stack_trace_.Set(value, GetArenaForAllocation());
}
inline std::string* ThreadStackTrace::_internal_mutable_thread_stack_trace() {
  _has_bits_[0] |= 0x00000001u;
  return thread_stack_trace_.Mutable(GetArenaForAllocation());
}
inline std::string* ThreadStackTrace::release_thread_stack_trace() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ThreadStackTrace.thread_stack_trace)
  if (!_internal_has_thread_stack_trace()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = thread_stack_trace_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (thread_stack_trace_.IsDefault()) {
    thread_stack_trace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ThreadStackTrace::set_allocated_thread_stack_trace(std::string* thread_stack_trace) {
  if (thread_stack_trace != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  thread_stack_trace_.SetAllocated(thread_stack_trace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (thread_stack_trace_.IsDefault()) {
    thread_stack_trace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ThreadStackTrace.thread_stack_trace)
}

// -------------------------------------------------------------------

// VerifyMessageCommand

// string nonce = 1 [json_name = "nonce"];
inline void VerifyMessageCommand::clear_nonce() {
  nonce_.ClearToEmpty();
}
inline const std::string& VerifyMessageCommand::nonce() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.VerifyMessageCommand.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyMessageCommand::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 nonce_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.VerifyMessageCommand.nonce)
}
inline std::string* VerifyMessageCommand::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.VerifyMessageCommand.nonce)
  return _s;
}
inline const std::string& VerifyMessageCommand::_internal_nonce() const {
  return nonce_.Get();
}
inline void VerifyMessageCommand::_internal_set_nonce(const std::string& value) {
  
  nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyMessageCommand::_internal_mutable_nonce() {
  
  return nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* VerifyMessageCommand::release_nonce() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.VerifyMessageCommand.nonce)
  return nonce_.Release();
}
inline void VerifyMessageCommand::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nonce_.IsDefault()) {
    nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.VerifyMessageCommand.nonce)
}

// .apache.rocketmq.v2.Message message = 2 [json_name = "message"];
inline bool VerifyMessageCommand::_internal_has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline bool VerifyMessageCommand::has_message() const {
  return _internal_has_message();
}
inline const ::apache::rocketmq::v2::Message& VerifyMessageCommand::_internal_message() const {
  const ::apache::rocketmq::v2::Message* p = message_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Message&>(
      ::apache::rocketmq::v2::_Message_default_instance_);
}
inline const ::apache::rocketmq::v2::Message& VerifyMessageCommand::message() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.VerifyMessageCommand.message)
  return _internal_message();
}
inline void VerifyMessageCommand::unsafe_arena_set_allocated_message(
    ::apache::rocketmq::v2::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.VerifyMessageCommand.message)
}
inline ::apache::rocketmq::v2::Message* VerifyMessageCommand::release_message() {
  
  ::apache::rocketmq::v2::Message* temp = message_;
  message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Message* VerifyMessageCommand::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.VerifyMessageCommand.message)
  
  ::apache::rocketmq::v2::Message* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Message* VerifyMessageCommand::_internal_mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Message>(GetArenaForAllocation());
    message_ = p;
  }
  return message_;
}
inline ::apache::rocketmq::v2::Message* VerifyMessageCommand::mutable_message() {
  ::apache::rocketmq::v2::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.VerifyMessageCommand.message)
  return _msg;
}
inline void VerifyMessageCommand::set_allocated_message(::apache::rocketmq::v2::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message));
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.VerifyMessageCommand.message)
}

// -------------------------------------------------------------------

// VerifyMessageResult

// string nonce = 1 [json_name = "nonce"];
inline void VerifyMessageResult::clear_nonce() {
  nonce_.ClearToEmpty();
}
inline const std::string& VerifyMessageResult::nonce() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.VerifyMessageResult.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyMessageResult::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 nonce_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.VerifyMessageResult.nonce)
}
inline std::string* VerifyMessageResult::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.VerifyMessageResult.nonce)
  return _s;
}
inline const std::string& VerifyMessageResult::_internal_nonce() const {
  return nonce_.Get();
}
inline void VerifyMessageResult::_internal_set_nonce(const std::string& value) {
  
  nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyMessageResult::_internal_mutable_nonce() {
  
  return nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* VerifyMessageResult::release_nonce() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.VerifyMessageResult.nonce)
  return nonce_.Release();
}
inline void VerifyMessageResult::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nonce_.IsDefault()) {
    nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.VerifyMessageResult.nonce)
}

// -------------------------------------------------------------------

// RecoverOrphanedTransactionCommand

// .apache.rocketmq.v2.Message message = 1 [json_name = "message"];
inline bool RecoverOrphanedTransactionCommand::_internal_has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline bool RecoverOrphanedTransactionCommand::has_message() const {
  return _internal_has_message();
}
inline const ::apache::rocketmq::v2::Message& RecoverOrphanedTransactionCommand::_internal_message() const {
  const ::apache::rocketmq::v2::Message* p = message_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Message&>(
      ::apache::rocketmq::v2::_Message_default_instance_);
}
inline const ::apache::rocketmq::v2::Message& RecoverOrphanedTransactionCommand::message() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.RecoverOrphanedTransactionCommand.message)
  return _internal_message();
}
inline void RecoverOrphanedTransactionCommand::unsafe_arena_set_allocated_message(
    ::apache::rocketmq::v2::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.RecoverOrphanedTransactionCommand.message)
}
inline ::apache::rocketmq::v2::Message* RecoverOrphanedTransactionCommand::release_message() {
  
  ::apache::rocketmq::v2::Message* temp = message_;
  message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Message* RecoverOrphanedTransactionCommand::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.RecoverOrphanedTransactionCommand.message)
  
  ::apache::rocketmq::v2::Message* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Message* RecoverOrphanedTransactionCommand::_internal_mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Message>(GetArenaForAllocation());
    message_ = p;
  }
  return message_;
}
inline ::apache::rocketmq::v2::Message* RecoverOrphanedTransactionCommand::mutable_message() {
  ::apache::rocketmq::v2::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.RecoverOrphanedTransactionCommand.message)
  return _msg;
}
inline void RecoverOrphanedTransactionCommand::set_allocated_message(::apache::rocketmq::v2::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message));
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.RecoverOrphanedTransactionCommand.message)
}

// string transaction_id = 2 [json_name = "transactionId"];
inline void RecoverOrphanedTransactionCommand::clear_transaction_id() {
  transaction_id_.ClearToEmpty();
}
inline const std::string& RecoverOrphanedTransactionCommand::transaction_id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.RecoverOrphanedTransactionCommand.transaction_id)
  return _internal_transaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecoverOrphanedTransactionCommand::set_transaction_id(ArgT0&& arg0, ArgT... args) {
 
 transaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.RecoverOrphanedTransactionCommand.transaction_id)
}
inline std::string* RecoverOrphanedTransactionCommand::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.RecoverOrphanedTransactionCommand.transaction_id)
  return _s;
}
inline const std::string& RecoverOrphanedTransactionCommand::_internal_transaction_id() const {
  return transaction_id_.Get();
}
inline void RecoverOrphanedTransactionCommand::_internal_set_transaction_id(const std::string& value) {
  
  transaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RecoverOrphanedTransactionCommand::_internal_mutable_transaction_id() {
  
  return transaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RecoverOrphanedTransactionCommand::release_transaction_id() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.RecoverOrphanedTransactionCommand.transaction_id)
  return transaction_id_.Release();
}
inline void RecoverOrphanedTransactionCommand::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    
  } else {
    
  }
  transaction_id_.SetAllocated(transaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transaction_id_.IsDefault()) {
    transaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.RecoverOrphanedTransactionCommand.transaction_id)
}

// -------------------------------------------------------------------

// Publishing

// repeated .apache.rocketmq.v2.Resource topics = 1 [json_name = "topics"];
inline int Publishing::_internal_topics_size() const {
  return topics_.size();
}
inline int Publishing::topics_size() const {
  return _internal_topics_size();
}
inline ::apache::rocketmq::v2::Resource* Publishing::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Publishing.topics)
  return topics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Resource >*
Publishing::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:apache.rocketmq.v2.Publishing.topics)
  return &topics_;
}
inline const ::apache::rocketmq::v2::Resource& Publishing::_internal_topics(int index) const {
  return topics_.Get(index);
}
inline const ::apache::rocketmq::v2::Resource& Publishing::topics(int index) const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Publishing.topics)
  return _internal_topics(index);
}
inline ::apache::rocketmq::v2::Resource* Publishing::_internal_add_topics() {
  return topics_.Add();
}
inline ::apache::rocketmq::v2::Resource* Publishing::add_topics() {
  ::apache::rocketmq::v2::Resource* _add = _internal_add_topics();
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.Publishing.topics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::Resource >&
Publishing::topics() const {
  // @@protoc_insertion_point(field_list:apache.rocketmq.v2.Publishing.topics)
  return topics_;
}

// int32 max_body_size = 2 [json_name = "maxBodySize"];
inline void Publishing::clear_max_body_size() {
  max_body_size_ = 0;
}
inline int32_t Publishing::_internal_max_body_size() const {
  return max_body_size_;
}
inline int32_t Publishing::max_body_size() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Publishing.max_body_size)
  return _internal_max_body_size();
}
inline void Publishing::_internal_set_max_body_size(int32_t value) {
  
  max_body_size_ = value;
}
inline void Publishing::set_max_body_size(int32_t value) {
  _internal_set_max_body_size(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Publishing.max_body_size)
}

// bool validate_message_type = 3 [json_name = "validateMessageType"];
inline void Publishing::clear_validate_message_type() {
  validate_message_type_ = false;
}
inline bool Publishing::_internal_validate_message_type() const {
  return validate_message_type_;
}
inline bool Publishing::validate_message_type() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Publishing.validate_message_type)
  return _internal_validate_message_type();
}
inline void Publishing::_internal_set_validate_message_type(bool value) {
  
  validate_message_type_ = value;
}
inline void Publishing::set_validate_message_type(bool value) {
  _internal_set_validate_message_type(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Publishing.validate_message_type)
}

// -------------------------------------------------------------------

// Subscription

// optional .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
inline bool Subscription::_internal_has_group() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || group_ != nullptr);
  return value;
}
inline bool Subscription::has_group() const {
  return _internal_has_group();
}
inline const ::apache::rocketmq::v2::Resource& Subscription::_internal_group() const {
  const ::apache::rocketmq::v2::Resource* p = group_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& Subscription::group() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Subscription.group)
  return _internal_group();
}
inline void Subscription::unsafe_arena_set_allocated_group(
    ::apache::rocketmq::v2::Resource* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  group_ = group;
  if (group) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Subscription.group)
}
inline ::apache::rocketmq::v2::Resource* Subscription::release_group() {
  _has_bits_[0] &= ~0x00000001u;
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* Subscription::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Subscription.group)
  _has_bits_[0] &= ~0x00000001u;
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* Subscription::_internal_mutable_group() {
  _has_bits_[0] |= 0x00000001u;
  if (group_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    group_ = p;
  }
  return group_;
}
inline ::apache::rocketmq::v2::Resource* Subscription::mutable_group() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Subscription.group)
  return _msg;
}
inline void Subscription::set_allocated_group(::apache::rocketmq::v2::Resource* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group));
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Subscription.group)
}

// repeated .apache.rocketmq.v2.SubscriptionEntry subscriptions = 2 [json_name = "subscriptions"];
inline int Subscription::_internal_subscriptions_size() const {
  return subscriptions_.size();
}
inline int Subscription::subscriptions_size() const {
  return _internal_subscriptions_size();
}
inline ::apache::rocketmq::v2::SubscriptionEntry* Subscription::mutable_subscriptions(int index) {
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Subscription.subscriptions)
  return subscriptions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::SubscriptionEntry >*
Subscription::mutable_subscriptions() {
  // @@protoc_insertion_point(field_mutable_list:apache.rocketmq.v2.Subscription.subscriptions)
  return &subscriptions_;
}
inline const ::apache::rocketmq::v2::SubscriptionEntry& Subscription::_internal_subscriptions(int index) const {
  return subscriptions_.Get(index);
}
inline const ::apache::rocketmq::v2::SubscriptionEntry& Subscription::subscriptions(int index) const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Subscription.subscriptions)
  return _internal_subscriptions(index);
}
inline ::apache::rocketmq::v2::SubscriptionEntry* Subscription::_internal_add_subscriptions() {
  return subscriptions_.Add();
}
inline ::apache::rocketmq::v2::SubscriptionEntry* Subscription::add_subscriptions() {
  ::apache::rocketmq::v2::SubscriptionEntry* _add = _internal_add_subscriptions();
  // @@protoc_insertion_point(field_add:apache.rocketmq.v2.Subscription.subscriptions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apache::rocketmq::v2::SubscriptionEntry >&
Subscription::subscriptions() const {
  // @@protoc_insertion_point(field_list:apache.rocketmq.v2.Subscription.subscriptions)
  return subscriptions_;
}

// optional bool fifo = 3 [json_name = "fifo"];
inline bool Subscription::_internal_has_fifo() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Subscription::has_fifo() const {
  return _internal_has_fifo();
}
inline void Subscription::clear_fifo() {
  fifo_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Subscription::_internal_fifo() const {
  return fifo_;
}
inline bool Subscription::fifo() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Subscription.fifo)
  return _internal_fifo();
}
inline void Subscription::_internal_set_fifo(bool value) {
  _has_bits_[0] |= 0x00000004u;
  fifo_ = value;
}
inline void Subscription::set_fifo(bool value) {
  _internal_set_fifo(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Subscription.fifo)
}

// optional int32 receive_batch_size = 4 [json_name = "receiveBatchSize"];
inline bool Subscription::_internal_has_receive_batch_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Subscription::has_receive_batch_size() const {
  return _internal_has_receive_batch_size();
}
inline void Subscription::clear_receive_batch_size() {
  receive_batch_size_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t Subscription::_internal_receive_batch_size() const {
  return receive_batch_size_;
}
inline int32_t Subscription::receive_batch_size() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Subscription.receive_batch_size)
  return _internal_receive_batch_size();
}
inline void Subscription::_internal_set_receive_batch_size(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  receive_batch_size_ = value;
}
inline void Subscription::set_receive_batch_size(int32_t value) {
  _internal_set_receive_batch_size(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Subscription.receive_batch_size)
}

// optional .google.protobuf.Duration long_polling_timeout = 5 [json_name = "longPollingTimeout"];
inline bool Subscription::_internal_has_long_polling_timeout() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || long_polling_timeout_ != nullptr);
  return value;
}
inline bool Subscription::has_long_polling_timeout() const {
  return _internal_has_long_polling_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Subscription::_internal_long_polling_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = long_polling_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Subscription::long_polling_timeout() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Subscription.long_polling_timeout)
  return _internal_long_polling_timeout();
}
inline void Subscription::unsafe_arena_set_allocated_long_polling_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* long_polling_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(long_polling_timeout_);
  }
  long_polling_timeout_ = long_polling_timeout;
  if (long_polling_timeout) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Subscription.long_polling_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Subscription::release_long_polling_timeout() {
  _has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = long_polling_timeout_;
  long_polling_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Subscription::unsafe_arena_release_long_polling_timeout() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Subscription.long_polling_timeout)
  _has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = long_polling_timeout_;
  long_polling_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Subscription::_internal_mutable_long_polling_timeout() {
  _has_bits_[0] |= 0x00000002u;
  if (long_polling_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    long_polling_timeout_ = p;
  }
  return long_polling_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Subscription::mutable_long_polling_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_long_polling_timeout();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Subscription.long_polling_timeout)
  return _msg;
}
inline void Subscription::set_allocated_long_polling_timeout(::PROTOBUF_NAMESPACE_ID::Duration* long_polling_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(long_polling_timeout_);
  }
  if (long_polling_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(long_polling_timeout));
    if (message_arena != submessage_arena) {
      long_polling_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, long_polling_timeout, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  long_polling_timeout_ = long_polling_timeout;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Subscription.long_polling_timeout)
}

// -------------------------------------------------------------------

// Metric

// bool on = 1 [json_name = "on"];
inline void Metric::clear_on() {
  on_ = false;
}
inline bool Metric::_internal_on() const {
  return on_;
}
inline bool Metric::on() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Metric.on)
  return _internal_on();
}
inline void Metric::_internal_set_on(bool value) {
  
  on_ = value;
}
inline void Metric::set_on(bool value) {
  _internal_set_on(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Metric.on)
}

// optional .apache.rocketmq.v2.Endpoints endpoints = 2 [json_name = "endpoints"];
inline bool Metric::_internal_has_endpoints() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || endpoints_ != nullptr);
  return value;
}
inline bool Metric::has_endpoints() const {
  return _internal_has_endpoints();
}
inline const ::apache::rocketmq::v2::Endpoints& Metric::_internal_endpoints() const {
  const ::apache::rocketmq::v2::Endpoints* p = endpoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Endpoints&>(
      ::apache::rocketmq::v2::_Endpoints_default_instance_);
}
inline const ::apache::rocketmq::v2::Endpoints& Metric::endpoints() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Metric.endpoints)
  return _internal_endpoints();
}
inline void Metric::unsafe_arena_set_allocated_endpoints(
    ::apache::rocketmq::v2::Endpoints* endpoints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoints_);
  }
  endpoints_ = endpoints;
  if (endpoints) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Metric.endpoints)
}
inline ::apache::rocketmq::v2::Endpoints* Metric::release_endpoints() {
  _has_bits_[0] &= ~0x00000001u;
  ::apache::rocketmq::v2::Endpoints* temp = endpoints_;
  endpoints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Endpoints* Metric::unsafe_arena_release_endpoints() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Metric.endpoints)
  _has_bits_[0] &= ~0x00000001u;
  ::apache::rocketmq::v2::Endpoints* temp = endpoints_;
  endpoints_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Endpoints* Metric::_internal_mutable_endpoints() {
  _has_bits_[0] |= 0x00000001u;
  if (endpoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Endpoints>(GetArenaForAllocation());
    endpoints_ = p;
  }
  return endpoints_;
}
inline ::apache::rocketmq::v2::Endpoints* Metric::mutable_endpoints() {
  ::apache::rocketmq::v2::Endpoints* _msg = _internal_mutable_endpoints();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Metric.endpoints)
  return _msg;
}
inline void Metric::set_allocated_endpoints(::apache::rocketmq::v2::Endpoints* endpoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoints_);
  }
  if (endpoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoints));
    if (message_arena != submessage_arena) {
      endpoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  endpoints_ = endpoints;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Metric.endpoints)
}

// -------------------------------------------------------------------

// Settings

// optional .apache.rocketmq.v2.ClientType client_type = 1 [json_name = "clientType"];
inline bool Settings::_internal_has_client_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Settings::has_client_type() const {
  return _internal_has_client_type();
}
inline void Settings::clear_client_type() {
  client_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::apache::rocketmq::v2::ClientType Settings::_internal_client_type() const {
  return static_cast< ::apache::rocketmq::v2::ClientType >(client_type_);
}
inline ::apache::rocketmq::v2::ClientType Settings::client_type() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Settings.client_type)
  return _internal_client_type();
}
inline void Settings::_internal_set_client_type(::apache::rocketmq::v2::ClientType value) {
  _has_bits_[0] |= 0x00000008u;
  client_type_ = value;
}
inline void Settings::set_client_type(::apache::rocketmq::v2::ClientType value) {
  _internal_set_client_type(value);
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.Settings.client_type)
}

// optional .apache.rocketmq.v2.Endpoints access_point = 2 [json_name = "accessPoint"];
inline bool Settings::_internal_has_access_point() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || access_point_ != nullptr);
  return value;
}
inline bool Settings::has_access_point() const {
  return _internal_has_access_point();
}
inline const ::apache::rocketmq::v2::Endpoints& Settings::_internal_access_point() const {
  const ::apache::rocketmq::v2::Endpoints* p = access_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Endpoints&>(
      ::apache::rocketmq::v2::_Endpoints_default_instance_);
}
inline const ::apache::rocketmq::v2::Endpoints& Settings::access_point() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Settings.access_point)
  return _internal_access_point();
}
inline void Settings::unsafe_arena_set_allocated_access_point(
    ::apache::rocketmq::v2::Endpoints* access_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(access_point_);
  }
  access_point_ = access_point;
  if (access_point) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Settings.access_point)
}
inline ::apache::rocketmq::v2::Endpoints* Settings::release_access_point() {
  _has_bits_[0] &= ~0x00000001u;
  ::apache::rocketmq::v2::Endpoints* temp = access_point_;
  access_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Endpoints* Settings::unsafe_arena_release_access_point() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Settings.access_point)
  _has_bits_[0] &= ~0x00000001u;
  ::apache::rocketmq::v2::Endpoints* temp = access_point_;
  access_point_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Endpoints* Settings::_internal_mutable_access_point() {
  _has_bits_[0] |= 0x00000001u;
  if (access_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Endpoints>(GetArenaForAllocation());
    access_point_ = p;
  }
  return access_point_;
}
inline ::apache::rocketmq::v2::Endpoints* Settings::mutable_access_point() {
  ::apache::rocketmq::v2::Endpoints* _msg = _internal_mutable_access_point();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Settings.access_point)
  return _msg;
}
inline void Settings::set_allocated_access_point(::apache::rocketmq::v2::Endpoints* access_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(access_point_);
  }
  if (access_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(access_point));
    if (message_arena != submessage_arena) {
      access_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, access_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  access_point_ = access_point;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Settings.access_point)
}

// optional .apache.rocketmq.v2.RetryPolicy backoff_policy = 3 [json_name = "backoffPolicy"];
inline bool Settings::_internal_has_backoff_policy() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || backoff_policy_ != nullptr);
  return value;
}
inline bool Settings::has_backoff_policy() const {
  return _internal_has_backoff_policy();
}
inline const ::apache::rocketmq::v2::RetryPolicy& Settings::_internal_backoff_policy() const {
  const ::apache::rocketmq::v2::RetryPolicy* p = backoff_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::RetryPolicy&>(
      ::apache::rocketmq::v2::_RetryPolicy_default_instance_);
}
inline const ::apache::rocketmq::v2::RetryPolicy& Settings::backoff_policy() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Settings.backoff_policy)
  return _internal_backoff_policy();
}
inline void Settings::unsafe_arena_set_allocated_backoff_policy(
    ::apache::rocketmq::v2::RetryPolicy* backoff_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(backoff_policy_);
  }
  backoff_policy_ = backoff_policy;
  if (backoff_policy) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Settings.backoff_policy)
}
inline ::apache::rocketmq::v2::RetryPolicy* Settings::release_backoff_policy() {
  _has_bits_[0] &= ~0x00000002u;
  ::apache::rocketmq::v2::RetryPolicy* temp = backoff_policy_;
  backoff_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::RetryPolicy* Settings::unsafe_arena_release_backoff_policy() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Settings.backoff_policy)
  _has_bits_[0] &= ~0x00000002u;
  ::apache::rocketmq::v2::RetryPolicy* temp = backoff_policy_;
  backoff_policy_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::RetryPolicy* Settings::_internal_mutable_backoff_policy() {
  _has_bits_[0] |= 0x00000002u;
  if (backoff_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::RetryPolicy>(GetArenaForAllocation());
    backoff_policy_ = p;
  }
  return backoff_policy_;
}
inline ::apache::rocketmq::v2::RetryPolicy* Settings::mutable_backoff_policy() {
  ::apache::rocketmq::v2::RetryPolicy* _msg = _internal_mutable_backoff_policy();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Settings.backoff_policy)
  return _msg;
}
inline void Settings::set_allocated_backoff_policy(::apache::rocketmq::v2::RetryPolicy* backoff_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(backoff_policy_);
  }
  if (backoff_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(backoff_policy));
    if (message_arena != submessage_arena) {
      backoff_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backoff_policy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  backoff_policy_ = backoff_policy;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Settings.backoff_policy)
}

// optional .google.protobuf.Duration request_timeout = 4 [json_name = "requestTimeout"];
inline bool Settings::_internal_has_request_timeout() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || request_timeout_ != nullptr);
  return value;
}
inline bool Settings::has_request_timeout() const {
  return _internal_has_request_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Settings::_internal_request_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = request_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Settings::request_timeout() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Settings.request_timeout)
  return _internal_request_timeout();
}
inline void Settings::unsafe_arena_set_allocated_request_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* request_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_timeout_);
  }
  request_timeout_ = request_timeout;
  if (request_timeout) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Settings.request_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Settings::release_request_timeout() {
  _has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = request_timeout_;
  request_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Settings::unsafe_arena_release_request_timeout() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Settings.request_timeout)
  _has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = request_timeout_;
  request_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Settings::_internal_mutable_request_timeout() {
  _has_bits_[0] |= 0x00000004u;
  if (request_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    request_timeout_ = p;
  }
  return request_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Settings::mutable_request_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_request_timeout();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Settings.request_timeout)
  return _msg;
}
inline void Settings::set_allocated_request_timeout(::PROTOBUF_NAMESPACE_ID::Duration* request_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_timeout_);
  }
  if (request_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_timeout));
    if (message_arena != submessage_arena) {
      request_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_timeout, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  request_timeout_ = request_timeout;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Settings.request_timeout)
}

// .apache.rocketmq.v2.Publishing publishing = 5 [json_name = "publishing"];
inline bool Settings::_internal_has_publishing() const {
  return pub_sub_case() == kPublishing;
}
inline bool Settings::has_publishing() const {
  return _internal_has_publishing();
}
inline void Settings::set_has_publishing() {
  _oneof_case_[0] = kPublishing;
}
inline void Settings::clear_publishing() {
  if (_internal_has_publishing()) {
    if (GetArenaForAllocation() == nullptr) {
      delete pub_sub_.publishing_;
    }
    clear_has_pub_sub();
  }
}
inline ::apache::rocketmq::v2::Publishing* Settings::release_publishing() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Settings.publishing)
  if (_internal_has_publishing()) {
    clear_has_pub_sub();
    ::apache::rocketmq::v2::Publishing* temp = pub_sub_.publishing_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    pub_sub_.publishing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apache::rocketmq::v2::Publishing& Settings::_internal_publishing() const {
  return _internal_has_publishing()
      ? *pub_sub_.publishing_
      : reinterpret_cast< ::apache::rocketmq::v2::Publishing&>(::apache::rocketmq::v2::_Publishing_default_instance_);
}
inline const ::apache::rocketmq::v2::Publishing& Settings::publishing() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Settings.publishing)
  return _internal_publishing();
}
inline ::apache::rocketmq::v2::Publishing* Settings::unsafe_arena_release_publishing() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.Settings.publishing)
  if (_internal_has_publishing()) {
    clear_has_pub_sub();
    ::apache::rocketmq::v2::Publishing* temp = pub_sub_.publishing_;
    pub_sub_.publishing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Settings::unsafe_arena_set_allocated_publishing(::apache::rocketmq::v2::Publishing* publishing) {
  clear_pub_sub();
  if (publishing) {
    set_has_publishing();
    pub_sub_.publishing_ = publishing;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Settings.publishing)
}
inline ::apache::rocketmq::v2::Publishing* Settings::_internal_mutable_publishing() {
  if (!_internal_has_publishing()) {
    clear_pub_sub();
    set_has_publishing();
    pub_sub_.publishing_ = CreateMaybeMessage< ::apache::rocketmq::v2::Publishing >(GetArenaForAllocation());
  }
  return pub_sub_.publishing_;
}
inline ::apache::rocketmq::v2::Publishing* Settings::mutable_publishing() {
  ::apache::rocketmq::v2::Publishing* _msg = _internal_mutable_publishing();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Settings.publishing)
  return _msg;
}

// .apache.rocketmq.v2.Subscription subscription = 6 [json_name = "subscription"];
inline bool Settings::_internal_has_subscription() const {
  return pub_sub_case() == kSubscription;
}
inline bool Settings::has_subscription() const {
  return _internal_has_subscription();
}
inline void Settings::set_has_subscription() {
  _oneof_case_[0] = kSubscription;
}
inline void Settings::clear_subscription() {
  if (_internal_has_subscription()) {
    if (GetArenaForAllocation() == nullptr) {
      delete pub_sub_.subscription_;
    }
    clear_has_pub_sub();
  }
}
inline ::apache::rocketmq::v2::Subscription* Settings::release_subscription() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Settings.subscription)
  if (_internal_has_subscription()) {
    clear_has_pub_sub();
    ::apache::rocketmq::v2::Subscription* temp = pub_sub_.subscription_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    pub_sub_.subscription_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apache::rocketmq::v2::Subscription& Settings::_internal_subscription() const {
  return _internal_has_subscription()
      ? *pub_sub_.subscription_
      : reinterpret_cast< ::apache::rocketmq::v2::Subscription&>(::apache::rocketmq::v2::_Subscription_default_instance_);
}
inline const ::apache::rocketmq::v2::Subscription& Settings::subscription() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Settings.subscription)
  return _internal_subscription();
}
inline ::apache::rocketmq::v2::Subscription* Settings::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.Settings.subscription)
  if (_internal_has_subscription()) {
    clear_has_pub_sub();
    ::apache::rocketmq::v2::Subscription* temp = pub_sub_.subscription_;
    pub_sub_.subscription_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Settings::unsafe_arena_set_allocated_subscription(::apache::rocketmq::v2::Subscription* subscription) {
  clear_pub_sub();
  if (subscription) {
    set_has_subscription();
    pub_sub_.subscription_ = subscription;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Settings.subscription)
}
inline ::apache::rocketmq::v2::Subscription* Settings::_internal_mutable_subscription() {
  if (!_internal_has_subscription()) {
    clear_pub_sub();
    set_has_subscription();
    pub_sub_.subscription_ = CreateMaybeMessage< ::apache::rocketmq::v2::Subscription >(GetArenaForAllocation());
  }
  return pub_sub_.subscription_;
}
inline ::apache::rocketmq::v2::Subscription* Settings::mutable_subscription() {
  ::apache::rocketmq::v2::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Settings.subscription)
  return _msg;
}

// .apache.rocketmq.v2.UA user_agent = 7 [json_name = "userAgent"];
inline bool Settings::_internal_has_user_agent() const {
  return this != internal_default_instance() && user_agent_ != nullptr;
}
inline bool Settings::has_user_agent() const {
  return _internal_has_user_agent();
}
inline const ::apache::rocketmq::v2::UA& Settings::_internal_user_agent() const {
  const ::apache::rocketmq::v2::UA* p = user_agent_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::UA&>(
      ::apache::rocketmq::v2::_UA_default_instance_);
}
inline const ::apache::rocketmq::v2::UA& Settings::user_agent() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Settings.user_agent)
  return _internal_user_agent();
}
inline void Settings::unsafe_arena_set_allocated_user_agent(
    ::apache::rocketmq::v2::UA* user_agent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_agent_);
  }
  user_agent_ = user_agent;
  if (user_agent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Settings.user_agent)
}
inline ::apache::rocketmq::v2::UA* Settings::release_user_agent() {
  
  ::apache::rocketmq::v2::UA* temp = user_agent_;
  user_agent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::UA* Settings::unsafe_arena_release_user_agent() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Settings.user_agent)
  
  ::apache::rocketmq::v2::UA* temp = user_agent_;
  user_agent_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::UA* Settings::_internal_mutable_user_agent() {
  
  if (user_agent_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::UA>(GetArenaForAllocation());
    user_agent_ = p;
  }
  return user_agent_;
}
inline ::apache::rocketmq::v2::UA* Settings::mutable_user_agent() {
  ::apache::rocketmq::v2::UA* _msg = _internal_mutable_user_agent();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Settings.user_agent)
  return _msg;
}
inline void Settings::set_allocated_user_agent(::apache::rocketmq::v2::UA* user_agent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_agent_);
  }
  if (user_agent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_agent));
    if (message_arena != submessage_arena) {
      user_agent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_agent, submessage_arena);
    }
    
  } else {
    
  }
  user_agent_ = user_agent;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Settings.user_agent)
}

// .apache.rocketmq.v2.Metric metric = 8 [json_name = "metric"];
inline bool Settings::_internal_has_metric() const {
  return this != internal_default_instance() && metric_ != nullptr;
}
inline bool Settings::has_metric() const {
  return _internal_has_metric();
}
inline void Settings::clear_metric() {
  if (GetArenaForAllocation() == nullptr && metric_ != nullptr) {
    delete metric_;
  }
  metric_ = nullptr;
}
inline const ::apache::rocketmq::v2::Metric& Settings::_internal_metric() const {
  const ::apache::rocketmq::v2::Metric* p = metric_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Metric&>(
      ::apache::rocketmq::v2::_Metric_default_instance_);
}
inline const ::apache::rocketmq::v2::Metric& Settings::metric() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.Settings.metric)
  return _internal_metric();
}
inline void Settings::unsafe_arena_set_allocated_metric(
    ::apache::rocketmq::v2::Metric* metric) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metric_);
  }
  metric_ = metric;
  if (metric) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.Settings.metric)
}
inline ::apache::rocketmq::v2::Metric* Settings::release_metric() {
  
  ::apache::rocketmq::v2::Metric* temp = metric_;
  metric_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Metric* Settings::unsafe_arena_release_metric() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.Settings.metric)
  
  ::apache::rocketmq::v2::Metric* temp = metric_;
  metric_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Metric* Settings::_internal_mutable_metric() {
  
  if (metric_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Metric>(GetArenaForAllocation());
    metric_ = p;
  }
  return metric_;
}
inline ::apache::rocketmq::v2::Metric* Settings::mutable_metric() {
  ::apache::rocketmq::v2::Metric* _msg = _internal_mutable_metric();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.Settings.metric)
  return _msg;
}
inline void Settings::set_allocated_metric(::apache::rocketmq::v2::Metric* metric) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metric_;
  }
  if (metric) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metric);
    if (message_arena != submessage_arena) {
      metric = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metric, submessage_arena);
    }
    
  } else {
    
  }
  metric_ = metric;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.Settings.metric)
}

inline bool Settings::has_pub_sub() const {
  return pub_sub_case() != PUB_SUB_NOT_SET;
}
inline void Settings::clear_has_pub_sub() {
  _oneof_case_[0] = PUB_SUB_NOT_SET;
}
inline Settings::PubSubCase Settings::pub_sub_case() const {
  return Settings::PubSubCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TelemetryCommand

// optional .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
inline bool TelemetryCommand::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool TelemetryCommand::has_status() const {
  return _internal_has_status();
}
inline const ::apache::rocketmq::v2::Status& TelemetryCommand::_internal_status() const {
  const ::apache::rocketmq::v2::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Status&>(
      ::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& TelemetryCommand::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.TelemetryCommand.status)
  return _internal_status();
}
inline void TelemetryCommand::unsafe_arena_set_allocated_status(
    ::apache::rocketmq::v2::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.TelemetryCommand.status)
}
inline ::apache::rocketmq::v2::Status* TelemetryCommand::release_status() {
  _has_bits_[0] &= ~0x00000001u;
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Status* TelemetryCommand::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.TelemetryCommand.status)
  _has_bits_[0] &= ~0x00000001u;
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Status* TelemetryCommand::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::apache::rocketmq::v2::Status* TelemetryCommand::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.TelemetryCommand.status)
  return _msg;
}
inline void TelemetryCommand::set_allocated_status(::apache::rocketmq::v2::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.TelemetryCommand.status)
}

// .apache.rocketmq.v2.Settings settings = 2 [json_name = "settings"];
inline bool TelemetryCommand::_internal_has_settings() const {
  return command_case() == kSettings;
}
inline bool TelemetryCommand::has_settings() const {
  return _internal_has_settings();
}
inline void TelemetryCommand::set_has_settings() {
  _oneof_case_[0] = kSettings;
}
inline void TelemetryCommand::clear_settings() {
  if (_internal_has_settings()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.settings_;
    }
    clear_has_command();
  }
}
inline ::apache::rocketmq::v2::Settings* TelemetryCommand::release_settings() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.TelemetryCommand.settings)
  if (_internal_has_settings()) {
    clear_has_command();
    ::apache::rocketmq::v2::Settings* temp = command_.settings_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apache::rocketmq::v2::Settings& TelemetryCommand::_internal_settings() const {
  return _internal_has_settings()
      ? *command_.settings_
      : reinterpret_cast< ::apache::rocketmq::v2::Settings&>(::apache::rocketmq::v2::_Settings_default_instance_);
}
inline const ::apache::rocketmq::v2::Settings& TelemetryCommand::settings() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.TelemetryCommand.settings)
  return _internal_settings();
}
inline ::apache::rocketmq::v2::Settings* TelemetryCommand::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.TelemetryCommand.settings)
  if (_internal_has_settings()) {
    clear_has_command();
    ::apache::rocketmq::v2::Settings* temp = command_.settings_;
    command_.settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TelemetryCommand::unsafe_arena_set_allocated_settings(::apache::rocketmq::v2::Settings* settings) {
  clear_command();
  if (settings) {
    set_has_settings();
    command_.settings_ = settings;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.TelemetryCommand.settings)
}
inline ::apache::rocketmq::v2::Settings* TelemetryCommand::_internal_mutable_settings() {
  if (!_internal_has_settings()) {
    clear_command();
    set_has_settings();
    command_.settings_ = CreateMaybeMessage< ::apache::rocketmq::v2::Settings >(GetArenaForAllocation());
  }
  return command_.settings_;
}
inline ::apache::rocketmq::v2::Settings* TelemetryCommand::mutable_settings() {
  ::apache::rocketmq::v2::Settings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.TelemetryCommand.settings)
  return _msg;
}

// .apache.rocketmq.v2.ThreadStackTrace thread_stack_trace = 3 [json_name = "threadStackTrace"];
inline bool TelemetryCommand::_internal_has_thread_stack_trace() const {
  return command_case() == kThreadStackTrace;
}
inline bool TelemetryCommand::has_thread_stack_trace() const {
  return _internal_has_thread_stack_trace();
}
inline void TelemetryCommand::set_has_thread_stack_trace() {
  _oneof_case_[0] = kThreadStackTrace;
}
inline void TelemetryCommand::clear_thread_stack_trace() {
  if (_internal_has_thread_stack_trace()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.thread_stack_trace_;
    }
    clear_has_command();
  }
}
inline ::apache::rocketmq::v2::ThreadStackTrace* TelemetryCommand::release_thread_stack_trace() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.TelemetryCommand.thread_stack_trace)
  if (_internal_has_thread_stack_trace()) {
    clear_has_command();
    ::apache::rocketmq::v2::ThreadStackTrace* temp = command_.thread_stack_trace_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.thread_stack_trace_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apache::rocketmq::v2::ThreadStackTrace& TelemetryCommand::_internal_thread_stack_trace() const {
  return _internal_has_thread_stack_trace()
      ? *command_.thread_stack_trace_
      : reinterpret_cast< ::apache::rocketmq::v2::ThreadStackTrace&>(::apache::rocketmq::v2::_ThreadStackTrace_default_instance_);
}
inline const ::apache::rocketmq::v2::ThreadStackTrace& TelemetryCommand::thread_stack_trace() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.TelemetryCommand.thread_stack_trace)
  return _internal_thread_stack_trace();
}
inline ::apache::rocketmq::v2::ThreadStackTrace* TelemetryCommand::unsafe_arena_release_thread_stack_trace() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.TelemetryCommand.thread_stack_trace)
  if (_internal_has_thread_stack_trace()) {
    clear_has_command();
    ::apache::rocketmq::v2::ThreadStackTrace* temp = command_.thread_stack_trace_;
    command_.thread_stack_trace_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TelemetryCommand::unsafe_arena_set_allocated_thread_stack_trace(::apache::rocketmq::v2::ThreadStackTrace* thread_stack_trace) {
  clear_command();
  if (thread_stack_trace) {
    set_has_thread_stack_trace();
    command_.thread_stack_trace_ = thread_stack_trace;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.TelemetryCommand.thread_stack_trace)
}
inline ::apache::rocketmq::v2::ThreadStackTrace* TelemetryCommand::_internal_mutable_thread_stack_trace() {
  if (!_internal_has_thread_stack_trace()) {
    clear_command();
    set_has_thread_stack_trace();
    command_.thread_stack_trace_ = CreateMaybeMessage< ::apache::rocketmq::v2::ThreadStackTrace >(GetArenaForAllocation());
  }
  return command_.thread_stack_trace_;
}
inline ::apache::rocketmq::v2::ThreadStackTrace* TelemetryCommand::mutable_thread_stack_trace() {
  ::apache::rocketmq::v2::ThreadStackTrace* _msg = _internal_mutable_thread_stack_trace();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.TelemetryCommand.thread_stack_trace)
  return _msg;
}

// .apache.rocketmq.v2.VerifyMessageResult verify_message_result = 4 [json_name = "verifyMessageResult"];
inline bool TelemetryCommand::_internal_has_verify_message_result() const {
  return command_case() == kVerifyMessageResult;
}
inline bool TelemetryCommand::has_verify_message_result() const {
  return _internal_has_verify_message_result();
}
inline void TelemetryCommand::set_has_verify_message_result() {
  _oneof_case_[0] = kVerifyMessageResult;
}
inline void TelemetryCommand::clear_verify_message_result() {
  if (_internal_has_verify_message_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.verify_message_result_;
    }
    clear_has_command();
  }
}
inline ::apache::rocketmq::v2::VerifyMessageResult* TelemetryCommand::release_verify_message_result() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.TelemetryCommand.verify_message_result)
  if (_internal_has_verify_message_result()) {
    clear_has_command();
    ::apache::rocketmq::v2::VerifyMessageResult* temp = command_.verify_message_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.verify_message_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apache::rocketmq::v2::VerifyMessageResult& TelemetryCommand::_internal_verify_message_result() const {
  return _internal_has_verify_message_result()
      ? *command_.verify_message_result_
      : reinterpret_cast< ::apache::rocketmq::v2::VerifyMessageResult&>(::apache::rocketmq::v2::_VerifyMessageResult_default_instance_);
}
inline const ::apache::rocketmq::v2::VerifyMessageResult& TelemetryCommand::verify_message_result() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.TelemetryCommand.verify_message_result)
  return _internal_verify_message_result();
}
inline ::apache::rocketmq::v2::VerifyMessageResult* TelemetryCommand::unsafe_arena_release_verify_message_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.TelemetryCommand.verify_message_result)
  if (_internal_has_verify_message_result()) {
    clear_has_command();
    ::apache::rocketmq::v2::VerifyMessageResult* temp = command_.verify_message_result_;
    command_.verify_message_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TelemetryCommand::unsafe_arena_set_allocated_verify_message_result(::apache::rocketmq::v2::VerifyMessageResult* verify_message_result) {
  clear_command();
  if (verify_message_result) {
    set_has_verify_message_result();
    command_.verify_message_result_ = verify_message_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.TelemetryCommand.verify_message_result)
}
inline ::apache::rocketmq::v2::VerifyMessageResult* TelemetryCommand::_internal_mutable_verify_message_result() {
  if (!_internal_has_verify_message_result()) {
    clear_command();
    set_has_verify_message_result();
    command_.verify_message_result_ = CreateMaybeMessage< ::apache::rocketmq::v2::VerifyMessageResult >(GetArenaForAllocation());
  }
  return command_.verify_message_result_;
}
inline ::apache::rocketmq::v2::VerifyMessageResult* TelemetryCommand::mutable_verify_message_result() {
  ::apache::rocketmq::v2::VerifyMessageResult* _msg = _internal_mutable_verify_message_result();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.TelemetryCommand.verify_message_result)
  return _msg;
}

// .apache.rocketmq.v2.RecoverOrphanedTransactionCommand recover_orphaned_transaction_command = 5 [json_name = "recoverOrphanedTransactionCommand"];
inline bool TelemetryCommand::_internal_has_recover_orphaned_transaction_command() const {
  return command_case() == kRecoverOrphanedTransactionCommand;
}
inline bool TelemetryCommand::has_recover_orphaned_transaction_command() const {
  return _internal_has_recover_orphaned_transaction_command();
}
inline void TelemetryCommand::set_has_recover_orphaned_transaction_command() {
  _oneof_case_[0] = kRecoverOrphanedTransactionCommand;
}
inline void TelemetryCommand::clear_recover_orphaned_transaction_command() {
  if (_internal_has_recover_orphaned_transaction_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.recover_orphaned_transaction_command_;
    }
    clear_has_command();
  }
}
inline ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* TelemetryCommand::release_recover_orphaned_transaction_command() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.TelemetryCommand.recover_orphaned_transaction_command)
  if (_internal_has_recover_orphaned_transaction_command()) {
    clear_has_command();
    ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* temp = command_.recover_orphaned_transaction_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.recover_orphaned_transaction_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand& TelemetryCommand::_internal_recover_orphaned_transaction_command() const {
  return _internal_has_recover_orphaned_transaction_command()
      ? *command_.recover_orphaned_transaction_command_
      : reinterpret_cast< ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand&>(::apache::rocketmq::v2::_RecoverOrphanedTransactionCommand_default_instance_);
}
inline const ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand& TelemetryCommand::recover_orphaned_transaction_command() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.TelemetryCommand.recover_orphaned_transaction_command)
  return _internal_recover_orphaned_transaction_command();
}
inline ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* TelemetryCommand::unsafe_arena_release_recover_orphaned_transaction_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.TelemetryCommand.recover_orphaned_transaction_command)
  if (_internal_has_recover_orphaned_transaction_command()) {
    clear_has_command();
    ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* temp = command_.recover_orphaned_transaction_command_;
    command_.recover_orphaned_transaction_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TelemetryCommand::unsafe_arena_set_allocated_recover_orphaned_transaction_command(::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* recover_orphaned_transaction_command) {
  clear_command();
  if (recover_orphaned_transaction_command) {
    set_has_recover_orphaned_transaction_command();
    command_.recover_orphaned_transaction_command_ = recover_orphaned_transaction_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.TelemetryCommand.recover_orphaned_transaction_command)
}
inline ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* TelemetryCommand::_internal_mutable_recover_orphaned_transaction_command() {
  if (!_internal_has_recover_orphaned_transaction_command()) {
    clear_command();
    set_has_recover_orphaned_transaction_command();
    command_.recover_orphaned_transaction_command_ = CreateMaybeMessage< ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand >(GetArenaForAllocation());
  }
  return command_.recover_orphaned_transaction_command_;
}
inline ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* TelemetryCommand::mutable_recover_orphaned_transaction_command() {
  ::apache::rocketmq::v2::RecoverOrphanedTransactionCommand* _msg = _internal_mutable_recover_orphaned_transaction_command();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.TelemetryCommand.recover_orphaned_transaction_command)
  return _msg;
}

// .apache.rocketmq.v2.PrintThreadStackTraceCommand print_thread_stack_trace_command = 6 [json_name = "printThreadStackTraceCommand"];
inline bool TelemetryCommand::_internal_has_print_thread_stack_trace_command() const {
  return command_case() == kPrintThreadStackTraceCommand;
}
inline bool TelemetryCommand::has_print_thread_stack_trace_command() const {
  return _internal_has_print_thread_stack_trace_command();
}
inline void TelemetryCommand::set_has_print_thread_stack_trace_command() {
  _oneof_case_[0] = kPrintThreadStackTraceCommand;
}
inline void TelemetryCommand::clear_print_thread_stack_trace_command() {
  if (_internal_has_print_thread_stack_trace_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.print_thread_stack_trace_command_;
    }
    clear_has_command();
  }
}
inline ::apache::rocketmq::v2::PrintThreadStackTraceCommand* TelemetryCommand::release_print_thread_stack_trace_command() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.TelemetryCommand.print_thread_stack_trace_command)
  if (_internal_has_print_thread_stack_trace_command()) {
    clear_has_command();
    ::apache::rocketmq::v2::PrintThreadStackTraceCommand* temp = command_.print_thread_stack_trace_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.print_thread_stack_trace_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apache::rocketmq::v2::PrintThreadStackTraceCommand& TelemetryCommand::_internal_print_thread_stack_trace_command() const {
  return _internal_has_print_thread_stack_trace_command()
      ? *command_.print_thread_stack_trace_command_
      : reinterpret_cast< ::apache::rocketmq::v2::PrintThreadStackTraceCommand&>(::apache::rocketmq::v2::_PrintThreadStackTraceCommand_default_instance_);
}
inline const ::apache::rocketmq::v2::PrintThreadStackTraceCommand& TelemetryCommand::print_thread_stack_trace_command() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.TelemetryCommand.print_thread_stack_trace_command)
  return _internal_print_thread_stack_trace_command();
}
inline ::apache::rocketmq::v2::PrintThreadStackTraceCommand* TelemetryCommand::unsafe_arena_release_print_thread_stack_trace_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.TelemetryCommand.print_thread_stack_trace_command)
  if (_internal_has_print_thread_stack_trace_command()) {
    clear_has_command();
    ::apache::rocketmq::v2::PrintThreadStackTraceCommand* temp = command_.print_thread_stack_trace_command_;
    command_.print_thread_stack_trace_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TelemetryCommand::unsafe_arena_set_allocated_print_thread_stack_trace_command(::apache::rocketmq::v2::PrintThreadStackTraceCommand* print_thread_stack_trace_command) {
  clear_command();
  if (print_thread_stack_trace_command) {
    set_has_print_thread_stack_trace_command();
    command_.print_thread_stack_trace_command_ = print_thread_stack_trace_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.TelemetryCommand.print_thread_stack_trace_command)
}
inline ::apache::rocketmq::v2::PrintThreadStackTraceCommand* TelemetryCommand::_internal_mutable_print_thread_stack_trace_command() {
  if (!_internal_has_print_thread_stack_trace_command()) {
    clear_command();
    set_has_print_thread_stack_trace_command();
    command_.print_thread_stack_trace_command_ = CreateMaybeMessage< ::apache::rocketmq::v2::PrintThreadStackTraceCommand >(GetArenaForAllocation());
  }
  return command_.print_thread_stack_trace_command_;
}
inline ::apache::rocketmq::v2::PrintThreadStackTraceCommand* TelemetryCommand::mutable_print_thread_stack_trace_command() {
  ::apache::rocketmq::v2::PrintThreadStackTraceCommand* _msg = _internal_mutable_print_thread_stack_trace_command();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.TelemetryCommand.print_thread_stack_trace_command)
  return _msg;
}

// .apache.rocketmq.v2.VerifyMessageCommand verify_message_command = 7 [json_name = "verifyMessageCommand"];
inline bool TelemetryCommand::_internal_has_verify_message_command() const {
  return command_case() == kVerifyMessageCommand;
}
inline bool TelemetryCommand::has_verify_message_command() const {
  return _internal_has_verify_message_command();
}
inline void TelemetryCommand::set_has_verify_message_command() {
  _oneof_case_[0] = kVerifyMessageCommand;
}
inline void TelemetryCommand::clear_verify_message_command() {
  if (_internal_has_verify_message_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.verify_message_command_;
    }
    clear_has_command();
  }
}
inline ::apache::rocketmq::v2::VerifyMessageCommand* TelemetryCommand::release_verify_message_command() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.TelemetryCommand.verify_message_command)
  if (_internal_has_verify_message_command()) {
    clear_has_command();
    ::apache::rocketmq::v2::VerifyMessageCommand* temp = command_.verify_message_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.verify_message_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apache::rocketmq::v2::VerifyMessageCommand& TelemetryCommand::_internal_verify_message_command() const {
  return _internal_has_verify_message_command()
      ? *command_.verify_message_command_
      : reinterpret_cast< ::apache::rocketmq::v2::VerifyMessageCommand&>(::apache::rocketmq::v2::_VerifyMessageCommand_default_instance_);
}
inline const ::apache::rocketmq::v2::VerifyMessageCommand& TelemetryCommand::verify_message_command() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.TelemetryCommand.verify_message_command)
  return _internal_verify_message_command();
}
inline ::apache::rocketmq::v2::VerifyMessageCommand* TelemetryCommand::unsafe_arena_release_verify_message_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apache.rocketmq.v2.TelemetryCommand.verify_message_command)
  if (_internal_has_verify_message_command()) {
    clear_has_command();
    ::apache::rocketmq::v2::VerifyMessageCommand* temp = command_.verify_message_command_;
    command_.verify_message_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TelemetryCommand::unsafe_arena_set_allocated_verify_message_command(::apache::rocketmq::v2::VerifyMessageCommand* verify_message_command) {
  clear_command();
  if (verify_message_command) {
    set_has_verify_message_command();
    command_.verify_message_command_ = verify_message_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.TelemetryCommand.verify_message_command)
}
inline ::apache::rocketmq::v2::VerifyMessageCommand* TelemetryCommand::_internal_mutable_verify_message_command() {
  if (!_internal_has_verify_message_command()) {
    clear_command();
    set_has_verify_message_command();
    command_.verify_message_command_ = CreateMaybeMessage< ::apache::rocketmq::v2::VerifyMessageCommand >(GetArenaForAllocation());
  }
  return command_.verify_message_command_;
}
inline ::apache::rocketmq::v2::VerifyMessageCommand* TelemetryCommand::mutable_verify_message_command() {
  ::apache::rocketmq::v2::VerifyMessageCommand* _msg = _internal_mutable_verify_message_command();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.TelemetryCommand.verify_message_command)
  return _msg;
}

inline bool TelemetryCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void TelemetryCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline TelemetryCommand::CommandCase TelemetryCommand::command_case() const {
  return TelemetryCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NotifyClientTerminationRequest

// optional .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
inline bool NotifyClientTerminationRequest::_internal_has_group() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || group_ != nullptr);
  return value;
}
inline bool NotifyClientTerminationRequest::has_group() const {
  return _internal_has_group();
}
inline const ::apache::rocketmq::v2::Resource& NotifyClientTerminationRequest::_internal_group() const {
  const ::apache::rocketmq::v2::Resource* p = group_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& NotifyClientTerminationRequest::group() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.NotifyClientTerminationRequest.group)
  return _internal_group();
}
inline void NotifyClientTerminationRequest::unsafe_arena_set_allocated_group(
    ::apache::rocketmq::v2::Resource* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  group_ = group;
  if (group) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.NotifyClientTerminationRequest.group)
}
inline ::apache::rocketmq::v2::Resource* NotifyClientTerminationRequest::release_group() {
  _has_bits_[0] &= ~0x00000001u;
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* NotifyClientTerminationRequest::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.NotifyClientTerminationRequest.group)
  _has_bits_[0] &= ~0x00000001u;
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* NotifyClientTerminationRequest::_internal_mutable_group() {
  _has_bits_[0] |= 0x00000001u;
  if (group_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    group_ = p;
  }
  return group_;
}
inline ::apache::rocketmq::v2::Resource* NotifyClientTerminationRequest::mutable_group() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.NotifyClientTerminationRequest.group)
  return _msg;
}
inline void NotifyClientTerminationRequest::set_allocated_group(::apache::rocketmq::v2::Resource* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group));
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.NotifyClientTerminationRequest.group)
}

// -------------------------------------------------------------------

// NotifyClientTerminationResponse

// .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
inline bool NotifyClientTerminationResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool NotifyClientTerminationResponse::has_status() const {
  return _internal_has_status();
}
inline const ::apache::rocketmq::v2::Status& NotifyClientTerminationResponse::_internal_status() const {
  const ::apache::rocketmq::v2::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Status&>(
      ::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& NotifyClientTerminationResponse::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.NotifyClientTerminationResponse.status)
  return _internal_status();
}
inline void NotifyClientTerminationResponse::unsafe_arena_set_allocated_status(
    ::apache::rocketmq::v2::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.NotifyClientTerminationResponse.status)
}
inline ::apache::rocketmq::v2::Status* NotifyClientTerminationResponse::release_status() {
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Status* NotifyClientTerminationResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.NotifyClientTerminationResponse.status)
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Status* NotifyClientTerminationResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::apache::rocketmq::v2::Status* NotifyClientTerminationResponse::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.NotifyClientTerminationResponse.status)
  return _msg;
}
inline void NotifyClientTerminationResponse::set_allocated_status(::apache::rocketmq::v2::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.NotifyClientTerminationResponse.status)
}

// -------------------------------------------------------------------

// ChangeInvisibleDurationRequest

// .apache.rocketmq.v2.Resource group = 1 [json_name = "group"];
inline bool ChangeInvisibleDurationRequest::_internal_has_group() const {
  return this != internal_default_instance() && group_ != nullptr;
}
inline bool ChangeInvisibleDurationRequest::has_group() const {
  return _internal_has_group();
}
inline const ::apache::rocketmq::v2::Resource& ChangeInvisibleDurationRequest::_internal_group() const {
  const ::apache::rocketmq::v2::Resource* p = group_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& ChangeInvisibleDurationRequest::group() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ChangeInvisibleDurationRequest.group)
  return _internal_group();
}
inline void ChangeInvisibleDurationRequest::unsafe_arena_set_allocated_group(
    ::apache::rocketmq::v2::Resource* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ChangeInvisibleDurationRequest.group)
}
inline ::apache::rocketmq::v2::Resource* ChangeInvisibleDurationRequest::release_group() {
  
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* ChangeInvisibleDurationRequest::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ChangeInvisibleDurationRequest.group)
  
  ::apache::rocketmq::v2::Resource* temp = group_;
  group_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* ChangeInvisibleDurationRequest::_internal_mutable_group() {
  
  if (group_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    group_ = p;
  }
  return group_;
}
inline ::apache::rocketmq::v2::Resource* ChangeInvisibleDurationRequest::mutable_group() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ChangeInvisibleDurationRequest.group)
  return _msg;
}
inline void ChangeInvisibleDurationRequest::set_allocated_group(::apache::rocketmq::v2::Resource* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_);
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group));
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ChangeInvisibleDurationRequest.group)
}

// .apache.rocketmq.v2.Resource topic = 2 [json_name = "topic"];
inline bool ChangeInvisibleDurationRequest::_internal_has_topic() const {
  return this != internal_default_instance() && topic_ != nullptr;
}
inline bool ChangeInvisibleDurationRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::apache::rocketmq::v2::Resource& ChangeInvisibleDurationRequest::_internal_topic() const {
  const ::apache::rocketmq::v2::Resource* p = topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Resource&>(
      ::apache::rocketmq::v2::_Resource_default_instance_);
}
inline const ::apache::rocketmq::v2::Resource& ChangeInvisibleDurationRequest::topic() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ChangeInvisibleDurationRequest.topic)
  return _internal_topic();
}
inline void ChangeInvisibleDurationRequest::unsafe_arena_set_allocated_topic(
    ::apache::rocketmq::v2::Resource* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ChangeInvisibleDurationRequest.topic)
}
inline ::apache::rocketmq::v2::Resource* ChangeInvisibleDurationRequest::release_topic() {
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Resource* ChangeInvisibleDurationRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ChangeInvisibleDurationRequest.topic)
  
  ::apache::rocketmq::v2::Resource* temp = topic_;
  topic_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Resource* ChangeInvisibleDurationRequest::_internal_mutable_topic() {
  
  if (topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Resource>(GetArenaForAllocation());
    topic_ = p;
  }
  return topic_;
}
inline ::apache::rocketmq::v2::Resource* ChangeInvisibleDurationRequest::mutable_topic() {
  ::apache::rocketmq::v2::Resource* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ChangeInvisibleDurationRequest.topic)
  return _msg;
}
inline void ChangeInvisibleDurationRequest::set_allocated_topic(::apache::rocketmq::v2::Resource* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ChangeInvisibleDurationRequest.topic)
}

// string receipt_handle = 3 [json_name = "receiptHandle"];
inline void ChangeInvisibleDurationRequest::clear_receipt_handle() {
  receipt_handle_.ClearToEmpty();
}
inline const std::string& ChangeInvisibleDurationRequest::receipt_handle() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ChangeInvisibleDurationRequest.receipt_handle)
  return _internal_receipt_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeInvisibleDurationRequest::set_receipt_handle(ArgT0&& arg0, ArgT... args) {
 
 receipt_handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.ChangeInvisibleDurationRequest.receipt_handle)
}
inline std::string* ChangeInvisibleDurationRequest::mutable_receipt_handle() {
  std::string* _s = _internal_mutable_receipt_handle();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ChangeInvisibleDurationRequest.receipt_handle)
  return _s;
}
inline const std::string& ChangeInvisibleDurationRequest::_internal_receipt_handle() const {
  return receipt_handle_.Get();
}
inline void ChangeInvisibleDurationRequest::_internal_set_receipt_handle(const std::string& value) {
  
  receipt_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeInvisibleDurationRequest::_internal_mutable_receipt_handle() {
  
  return receipt_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeInvisibleDurationRequest::release_receipt_handle() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ChangeInvisibleDurationRequest.receipt_handle)
  return receipt_handle_.Release();
}
inline void ChangeInvisibleDurationRequest::set_allocated_receipt_handle(std::string* receipt_handle) {
  if (receipt_handle != nullptr) {
    
  } else {
    
  }
  receipt_handle_.SetAllocated(receipt_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receipt_handle_.IsDefault()) {
    receipt_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ChangeInvisibleDurationRequest.receipt_handle)
}

// .google.protobuf.Duration invisible_duration = 4 [json_name = "invisibleDuration"];
inline bool ChangeInvisibleDurationRequest::_internal_has_invisible_duration() const {
  return this != internal_default_instance() && invisible_duration_ != nullptr;
}
inline bool ChangeInvisibleDurationRequest::has_invisible_duration() const {
  return _internal_has_invisible_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ChangeInvisibleDurationRequest::_internal_invisible_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = invisible_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ChangeInvisibleDurationRequest::invisible_duration() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ChangeInvisibleDurationRequest.invisible_duration)
  return _internal_invisible_duration();
}
inline void ChangeInvisibleDurationRequest::unsafe_arena_set_allocated_invisible_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invisible_duration_);
  }
  invisible_duration_ = invisible_duration;
  if (invisible_duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ChangeInvisibleDurationRequest.invisible_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ChangeInvisibleDurationRequest::release_invisible_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = invisible_duration_;
  invisible_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ChangeInvisibleDurationRequest::unsafe_arena_release_invisible_duration() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ChangeInvisibleDurationRequest.invisible_duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = invisible_duration_;
  invisible_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ChangeInvisibleDurationRequest::_internal_mutable_invisible_duration() {
  
  if (invisible_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    invisible_duration_ = p;
  }
  return invisible_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ChangeInvisibleDurationRequest::mutable_invisible_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_invisible_duration();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ChangeInvisibleDurationRequest.invisible_duration)
  return _msg;
}
inline void ChangeInvisibleDurationRequest::set_allocated_invisible_duration(::PROTOBUF_NAMESPACE_ID::Duration* invisible_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(invisible_duration_);
  }
  if (invisible_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invisible_duration));
    if (message_arena != submessage_arena) {
      invisible_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invisible_duration, submessage_arena);
    }
    
  } else {
    
  }
  invisible_duration_ = invisible_duration;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ChangeInvisibleDurationRequest.invisible_duration)
}

// string message_id = 5 [json_name = "messageId"];
inline void ChangeInvisibleDurationRequest::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& ChangeInvisibleDurationRequest::message_id() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ChangeInvisibleDurationRequest.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeInvisibleDurationRequest::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.ChangeInvisibleDurationRequest.message_id)
}
inline std::string* ChangeInvisibleDurationRequest::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ChangeInvisibleDurationRequest.message_id)
  return _s;
}
inline const std::string& ChangeInvisibleDurationRequest::_internal_message_id() const {
  return message_id_.Get();
}
inline void ChangeInvisibleDurationRequest::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeInvisibleDurationRequest::_internal_mutable_message_id() {
  
  return message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeInvisibleDurationRequest::release_message_id() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ChangeInvisibleDurationRequest.message_id)
  return message_id_.Release();
}
inline void ChangeInvisibleDurationRequest::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_id_.IsDefault()) {
    message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ChangeInvisibleDurationRequest.message_id)
}

// -------------------------------------------------------------------

// ChangeInvisibleDurationResponse

// .apache.rocketmq.v2.Status status = 1 [json_name = "status"];
inline bool ChangeInvisibleDurationResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool ChangeInvisibleDurationResponse::has_status() const {
  return _internal_has_status();
}
inline const ::apache::rocketmq::v2::Status& ChangeInvisibleDurationResponse::_internal_status() const {
  const ::apache::rocketmq::v2::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::apache::rocketmq::v2::Status&>(
      ::apache::rocketmq::v2::_Status_default_instance_);
}
inline const ::apache::rocketmq::v2::Status& ChangeInvisibleDurationResponse::status() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ChangeInvisibleDurationResponse.status)
  return _internal_status();
}
inline void ChangeInvisibleDurationResponse::unsafe_arena_set_allocated_status(
    ::apache::rocketmq::v2::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apache.rocketmq.v2.ChangeInvisibleDurationResponse.status)
}
inline ::apache::rocketmq::v2::Status* ChangeInvisibleDurationResponse::release_status() {
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apache::rocketmq::v2::Status* ChangeInvisibleDurationResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ChangeInvisibleDurationResponse.status)
  
  ::apache::rocketmq::v2::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::apache::rocketmq::v2::Status* ChangeInvisibleDurationResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::apache::rocketmq::v2::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::apache::rocketmq::v2::Status* ChangeInvisibleDurationResponse::mutable_status() {
  ::apache::rocketmq::v2::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ChangeInvisibleDurationResponse.status)
  return _msg;
}
inline void ChangeInvisibleDurationResponse::set_allocated_status(::apache::rocketmq::v2::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ChangeInvisibleDurationResponse.status)
}

// string receipt_handle = 2 [json_name = "receiptHandle"];
inline void ChangeInvisibleDurationResponse::clear_receipt_handle() {
  receipt_handle_.ClearToEmpty();
}
inline const std::string& ChangeInvisibleDurationResponse::receipt_handle() const {
  // @@protoc_insertion_point(field_get:apache.rocketmq.v2.ChangeInvisibleDurationResponse.receipt_handle)
  return _internal_receipt_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeInvisibleDurationResponse::set_receipt_handle(ArgT0&& arg0, ArgT... args) {
 
 receipt_handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apache.rocketmq.v2.ChangeInvisibleDurationResponse.receipt_handle)
}
inline std::string* ChangeInvisibleDurationResponse::mutable_receipt_handle() {
  std::string* _s = _internal_mutable_receipt_handle();
  // @@protoc_insertion_point(field_mutable:apache.rocketmq.v2.ChangeInvisibleDurationResponse.receipt_handle)
  return _s;
}
inline const std::string& ChangeInvisibleDurationResponse::_internal_receipt_handle() const {
  return receipt_handle_.Get();
}
inline void ChangeInvisibleDurationResponse::_internal_set_receipt_handle(const std::string& value) {
  
  receipt_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeInvisibleDurationResponse::_internal_mutable_receipt_handle() {
  
  return receipt_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeInvisibleDurationResponse::release_receipt_handle() {
  // @@protoc_insertion_point(field_release:apache.rocketmq.v2.ChangeInvisibleDurationResponse.receipt_handle)
  return receipt_handle_.Release();
}
inline void ChangeInvisibleDurationResponse::set_allocated_receipt_handle(std::string* receipt_handle) {
  if (receipt_handle != nullptr) {
    
  } else {
    
  }
  receipt_handle_.SetAllocated(receipt_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receipt_handle_.IsDefault()) {
    receipt_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apache.rocketmq.v2.ChangeInvisibleDurationResponse.receipt_handle)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace rocketmq
}  // namespace apache

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_apache_2frocketmq_2fv2_2fservice_2eproto
